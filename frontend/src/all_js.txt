
D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\components\index.js"   & echo.
/**
 * Components Barrel Export
 */

// Re-export from subdirectories
export * from "./common";
export * from "./layout";
// UI components are imported directly from @/components/ui/[component]


D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\components\common\index.js"   & echo.. 
/**
 * Common Components Barrel Export
 */

export { default as DataTable } from "./DataTable";
export { default as StatCard } from "./StatCard";
export { default as StatusBadge } from "./StatusBadge";
export { default as PageHeader } from "./PageHeader";
export {
  default as EmptyState,
  SearchEmptyState,
  ErrorEmptyState,
} from "./EmptyState";
export {
  default as LoadingSpinner,
  PageLoader,
  ButtonSpinner,
  CardLoader,
  LoadingScreen,
} from "./LoadingSpinner";
export {
  default as ConfirmDialog,
  GlobalConfirmDialog,
  useConfirm,
} from "./ConfirmDialog";
export { default as ErrorBoundary, withErrorBoundary } from "./ErrorBoundary";
export { default as SearchInput, CommandSearch } from "./SearchInput";
export { default as AccessibilityWidget } from "./AccessibilityWidget";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\components\layout\index.js"   & echo.. 
/**
 * Layout Components Barrel Export
 */

export { default as MainLayout } from "./MainLayout";
export { default as AuthLayout } from "./AuthLayout";
export { default as Sidebar } from "./Sidebar";
export { AppSidebar } from "./AppSidebar";
export { default as Header } from "./Header";
export { default as BranchSelector } from "./BranchSelector";
export { default as UserMenu } from "./UserMenu";
export { default as NotificationDropdown } from "./NotificationDropdown";
export { default as MobileNav } from "./MobileNav";
export {
  NAVIGATION,
  filterNavigationByRole,
  getFlatRoutes,
} from "./navigation.config";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\components\layout\navigation.config.js"   & echo.. 
/**
 * Navigation Configuration
 * Defines sidebar navigation items with role-based access control
 */

import {
  LayoutDashboard,
  ShoppingCart,
  Package,
  Boxes,
  Users,
  Building2,
  FileText,
  DollarSign,
  Settings,
  Truck,
  ClipboardList,
  PackageCheck,
  ArrowLeftRight,
  Bell,
  Shield,
  UserCog,
  Wallet,
  Receipt,
  TrendingUp,
  PieChart,
  Calendar,
  Archive,
  AlertTriangle,
  Pill,
  Tags,
} from "lucide-react";
import { ROLES } from "@/constants";
import { ROUTES } from "@/config";

/**
 * Navigation item structure
 * @typedef {Object} NavItem
 * @property {string} title - Display title
 * @property {string} href - Route path
 * @property {React.Component} icon - Lucide icon component
 * @property {Array<string>} roles - Allowed roles
 * @property {Array<NavItem>} children - Sub-navigation items
 * @property {string} badge - Optional badge text
 */

/**
 * Main navigation configuration
 */
export const NAVIGATION = [
  {
    title: "Dashboard",
    href: ROUTES.DASHBOARD,
    icon: LayoutDashboard,
    roles: [
      ROLES.SUPER_ADMIN,
      ROLES.OWNER,
      ROLES.BRANCH_ADMIN,
      ROLES.PHARMACIST,
      ROLES.CASHIER,
      ROLES.INVENTORY_MANAGER,
      ROLES.ACCOUNTANT,
    ],
  },
  {
    title: "Point of Sale",
    href: ROUTES.POS.ROOT,
    icon: ShoppingCart,
    roles: [
      ROLES.SUPER_ADMIN,
      ROLES.OWNER,
      ROLES.BRANCH_ADMIN,
      ROLES.PHARMACIST,
      ROLES.CASHIER,
    ],
    children: [
      {
        title: "New Sale",
        href: ROUTES.POS.NEW_SALE,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
          ROLES.CASHIER,
        ],
      },
      {
        title: "Held Sales",
        href: ROUTES.POS.HELD_SALES,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
          ROLES.CASHIER,
        ],
      },
      {
        title: "Sales History",
        href: ROUTES.POS.HISTORY,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
        ],
      },
      {
        title: "Returns",
        href: ROUTES.POS.RETURNS,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
        ],
      },
    ],
  },
  {
    title: "Products",
    href: ROUTES.PRODUCTS.ROOT,
    icon: Pill,
    roles: [
      ROLES.SUPER_ADMIN,
      ROLES.OWNER,
      ROLES.BRANCH_ADMIN,
      ROLES.PHARMACIST,
      ROLES.INVENTORY_MANAGER,
    ],
    children: [
      {
        title: "All Products",
        href: ROUTES.PRODUCTS.LIST,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Add Product",
        href: ROUTES.PRODUCTS.NEW,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Categories",
        href: ROUTES.CATEGORIES.ROOT,
        icon: Tags,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Low Stock",
        href: ROUTES.PRODUCTS.LOW_STOCK,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
        badge: "alert",
      },
      {
        title: "Expiring Soon",
        href: ROUTES.PRODUCTS.EXPIRING,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
          ROLES.INVENTORY_MANAGER,
        ],
        badge: "alert",
      },
    ],
  },
  {
    title: "Inventory",
    href: ROUTES.INVENTORY.ROOT,
    icon: Boxes,
    roles: [
      ROLES.SUPER_ADMIN,
      ROLES.OWNER,
      ROLES.BRANCH_ADMIN,
      ROLES.PHARMACIST,
      ROLES.INVENTORY_MANAGER,
    ],
    children: [
      {
        title: "Stock Overview",
        href: ROUTES.INVENTORY.STOCK,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Stock Movements",
        href: ROUTES.INVENTORY.MOVEMENTS,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Stock Transfers",
        href: ROUTES.INVENTORY.TRANSFERS.LIST,
        icon: ArrowLeftRight,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Stock Adjustments",
        href: ROUTES.INVENTORY.ADJUSTMENTS.LIST,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Batch Tracking",
        href: ROUTES.INVENTORY.BATCHES,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
          ROLES.INVENTORY_MANAGER,
        ],
      },
    ],
  },
  {
    title: "Purchase Orders",
    href: ROUTES.PURCHASE_ORDERS.ROOT,
    icon: ClipboardList,
    roles: [
      ROLES.SUPER_ADMIN,
      ROLES.OWNER,
      ROLES.BRANCH_ADMIN,
      ROLES.INVENTORY_MANAGER,
    ],
    children: [
      {
        title: "All Orders",
        href: ROUTES.PURCHASE_ORDERS.LIST,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Create Order",
        href: ROUTES.PURCHASE_ORDERS.NEW,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "GRN",
        href: ROUTES.GRN.ROOT,
        icon: PackageCheck,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
    ],
  },
  {
    title: "Suppliers",
    href: ROUTES.SUPPLIERS.ROOT,
    icon: Truck,
    roles: [
      ROLES.SUPER_ADMIN,
      ROLES.OWNER,
      ROLES.BRANCH_ADMIN,
      ROLES.INVENTORY_MANAGER,
    ],
    children: [
      {
        title: "All Suppliers",
        href: ROUTES.SUPPLIERS.LIST,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Add Supplier",
        href: ROUTES.SUPPLIERS.NEW,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
    ],
  },
  {
    title: "Customers",
    href: ROUTES.CUSTOMERS.ROOT,
    icon: Users,
    roles: [
      ROLES.SUPER_ADMIN,
      ROLES.OWNER,
      ROLES.BRANCH_ADMIN,
      ROLES.PHARMACIST,
      ROLES.CASHIER,
    ],
    children: [
      {
        title: "All Customers",
        href: ROUTES.CUSTOMERS.LIST,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
          ROLES.CASHIER,
        ],
      },
      {
        title: "Add Customer",
        href: ROUTES.CUSTOMERS.NEW,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.PHARMACIST,
        ],
      },
      {
        title: "Credit Accounts",
        href: ROUTES.CUSTOMERS.CREDITS,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
      },
    ],
  },
  {
    title: "Finance",
    href: ROUTES.FINANCE.ROOT,
    icon: DollarSign,
    roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
    children: [
      {
        title: "Overview",
        href: ROUTES.FINANCE.OVERVIEW,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
      },
      {
        title: "Transactions",
        href: ROUTES.FINANCE.TRANSACTIONS,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
      },
      {
        title: "Invoices",
        href: ROUTES.FINANCE.INVOICES,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
      },
      {
        title: "Cheques",
        href: ROUTES.FINANCE.CHEQUES,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
      },
      {
        title: "Cash Register",
        href: ROUTES.FINANCE.CASH_REGISTER,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.ACCOUNTANT,
        ],
      },
    ],
  },
  {
    title: "Payroll",
    href: ROUTES.PAYROLL.ROOT,
    icon: Wallet,
    roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
    children: [
      {
        title: "Salary Records",
        href: ROUTES.PAYROLL.SALARIES,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
      },
      {
        title: "Attendance",
        href: ROUTES.PAYROLL.ATTENDANCE,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.ACCOUNTANT,
        ],
      },
      {
        title: "Advances",
        href: ROUTES.PAYROLL.ADVANCES,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
      },
    ],
  },
  {
    title: "Reports",
    href: ROUTES.REPORTS.ROOT,
    icon: PieChart,
    roles: [
      ROLES.SUPER_ADMIN,
      ROLES.OWNER,
      ROLES.BRANCH_ADMIN,
      ROLES.ACCOUNTANT,
    ],
    children: [
      {
        title: "Sales Reports",
        href: ROUTES.REPORTS.SALES,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.ACCOUNTANT,
        ],
      },
      {
        title: "Inventory Reports",
        href: ROUTES.REPORTS.INVENTORY,
        roles: [
          ROLES.SUPER_ADMIN,
          ROLES.OWNER,
          ROLES.BRANCH_ADMIN,
          ROLES.INVENTORY_MANAGER,
        ],
      },
      {
        title: "Financial Reports",
        href: ROUTES.REPORTS.FINANCIAL,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.ACCOUNTANT],
      },
      {
        title: "Employee Reports",
        href: ROUTES.REPORTS.EMPLOYEES,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
      },
      {
        title: "Audit Trail",
        href: ROUTES.REPORTS.AUDIT,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER],
      },
    ],
  },
  {
    title: "Employees",
    href: ROUTES.EMPLOYEES.ROOT,
    icon: UserCog,
    roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
    children: [
      {
        title: "All Employees",
        href: ROUTES.EMPLOYEES.LIST,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
      },
      {
        title: "Add Employee",
        href: ROUTES.EMPLOYEES.NEW,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
      },
      {
        title: "Attendance",
        href: ROUTES.EMPLOYEES.ATTENDANCE,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
      },
    ],
  },
  {
    title: "Branches",
    href: ROUTES.BRANCHES.ROOT,
    icon: Building2,
    roles: [ROLES.SUPER_ADMIN, ROLES.OWNER],
    children: [
      {
        title: "All Branches",
        href: ROUTES.BRANCHES.LIST,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER],
      },
      {
        title: "Add Branch",
        href: ROUTES.BRANCHES.NEW,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER],
      },
    ],
  },
  {
    title: "Users",
    href: ROUTES.USERS.ROOT,
    icon: Shield,
    roles: [ROLES.SUPER_ADMIN],
    children: [
      {
        title: "All Users",
        href: ROUTES.USERS.LIST,
        roles: [ROLES.SUPER_ADMIN],
      },
      {
        title: "Add User",
        href: ROUTES.USERS.NEW,
        roles: [ROLES.SUPER_ADMIN],
      },
    ],
  },
  {
    title: "Settings",
    href: ROUTES.SETTINGS.ROOT,
    icon: Settings,
    roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
    children: [
      {
        title: "General",
        href: ROUTES.SETTINGS.GENERAL,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER],
      },
      {
        title: "Branch Settings",
        href: ROUTES.SETTINGS.BRANCH,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
      },
      {
        title: "Tax Settings",
        href: ROUTES.SETTINGS.TAX,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER],
      },
      {
        title: "Notifications",
        href: ROUTES.SETTINGS.NOTIFICATIONS,
        roles: [ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN],
      },
    ],
  },
];

/**
 * Filter navigation items based on user role
 * @param {Array<NavItem>} items - Navigation items
 * @param {string} userRole - Current user role
 * @returns {Array<NavItem>} Filtered navigation items
 */
export const filterNavigationByRole = (items, userRole) => {
  if (!userRole) return [];

  return items
    .filter((item) => item.roles.includes(userRole))
    .map((item) => ({
      ...item,
      children: item.children
        ? filterNavigationByRole(item.children, userRole)
        : undefined,
    }))
    .filter((item) => !item.children || item.children.length > 0);
};

/**
 * Get flattened list of all routes for quick access
 * @param {Array<NavItem>} items - Navigation items
 * @returns {Array<{title: string, href: string}>} Flat route list
 */
export const getFlatRoutes = (items = NAVIGATION) => {
  return items.reduce((acc, item) => {
    acc.push({ title: item.title, href: item.href, icon: item.icon });
    if (item.children) {
      acc.push(...getFlatRoutes(item.children));
    }
    return acc;
  }, []);
};

export default NAVIGATION;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\config\api.config.js"   & echo.. 
/**
 * API Configuration
 * Central configuration for all API-related settings
 */

export const API_CONFIG = {
  // Base URL for API calls
  BASE_URL: import.meta.env.VITE_API_BASE_URL || "http://localhost:8080/api",

  // Auth endpoints (no /api prefix as they're at root)
  AUTH_URL: import.meta.env.VITE_AUTH_URL || "http://localhost:8080",

  // WebSocket URL
  WS_URL: import.meta.env.VITE_WS_URL || "ws://localhost:8080/ws",

  // Request timeout in milliseconds
  TIMEOUT: 30000,

  // Retry configuration
  RETRY: {
    MAX_RETRIES: 3,
    RETRY_DELAY: 1000,
  },

  // Token configuration
  TOKEN: {
    ACCESS_KEY: "accessToken",
    REFRESH_KEY: "refreshToken",
    USER_KEY: "user",
  },

  // Headers
  HEADERS: {
    CONTENT_TYPE: "application/json",
    ACCEPT: "application/json",
  },
};

// API Endpoints organized by domain
export const API_ENDPOINTS = {
  // Auth
  AUTH: {
    LOGIN: "/auth/login",
    LOGOUT: "/auth/logout",
    REFRESH: "/auth/refresh",
    ME: "/auth/me",
    CHANGE_PASSWORD: "/auth/change-password",
    FORGOT_PASSWORD: "/auth/forgot-password",
    RESET_PASSWORD: "/auth/reset-password",
    REGISTER_INITIAL: "/auth/register/initial",
  },

  // Users
  USERS: {
    BASE: "/users",
    BY_ID: (id) => `/users/${id}`,
    BY_USERNAME: (username) => `/users/username/${username}`,
    ACTIVE: "/users/active",
    BY_ROLE: (role) => `/users/role/${role}`,
    BY_BRANCH: (branchId) => `/users/branch/${branchId}`,
    RESET_PASSWORD: (id) => `/users/${id}/reset-password`,
    ACTIVATE: (id) => `/users/${id}/activate`,
    DEACTIVATE: (id) => `/users/${id}/deactivate`,
  },

  // Branches
  BRANCHES: {
    BASE: "/branches",
    BY_ID: (id) => `/branches/${id}`,
    BY_CODE: (code) => `/branches/code/${code}`,
    ALL: "/branches/all",
    ACTIVE: "/branches/active",
    STAFF: (id) => `/branches/${id}/staff`,
    ACTIVATE: (id) => `/branches/${id}/activate`,
    DEACTIVATE: (id) => `/branches/${id}/deactivate`,
  },

  // Branch Staff
  BRANCH_STAFF: {
    BASE: "/branch-staff",
    BY_ID: (id) => `/branch-staff/${id}`,
    BY_BRANCH: (branchId) => `/branch-staff/branch/${branchId}`,
  },

  // Products
  PRODUCTS: {
    BASE: "/products",
    BY_ID: (id) => `/products/${id}`,
    BY_CODE: (code) => `/products/code/${code}`,
    SEARCH: "/products/search",
    LOW_STOCK: "/products/low-stock",
    BARCODE: (barcode) => `/products/barcode/${barcode}`,
    DISCONTINUE: (id) => `/products/${id}/discontinue`,
    EXPORT: "/products/export",
    IMPORT: "/products/import",
    TEMPLATE: "/products/import/template",
  },

  // Categories
  CATEGORIES: {
    BASE: "/categories",
    BY_ID: (id) => `/categories/${id}`,
    ACTIVE: "/categories/active",
  },

  // Sub-Categories
  SUB_CATEGORIES: {
    BASE: "/subcategories",
    BY_ID: (id) => `/subcategories/${id}`,
    BY_CATEGORY: (categoryId) => `/subcategories/category/${categoryId}`,
  },

  // Units
  UNITS: {
    BASE: "/units",
    BY_ID: (id) => `/units/${id}`,
  },

  // Inventory
  INVENTORY: {
    BASE: "/inventory",
    BY_BRANCH: (branchId) => `/inventory/branch/${branchId}`,
    BY_PRODUCT_AND_BRANCH: (productId, branchId) =>
      `/inventory/product/${productId}/branch/${branchId}`,
    LOW_STOCK: (branchId) => `/inventory/branch/${branchId}/low-stock`,
    OUT_OF_STOCK: (branchId) => `/inventory/branch/${branchId}/out-of-stock`,
    EXPIRING: (branchId) => `/inventory/branch/${branchId}/expiring`,
    EXPIRED: (branchId) => `/inventory/branch/${branchId}/expired`,
    BATCHES: (productId, branchId) =>
      `/inventory/product/${productId}/branch/${branchId}/batches`,
    AVAILABLE_QUANTITY: (productId, branchId) =>
      `/inventory/product/${productId}/branch/${branchId}/available`,
    ALL_LOW_STOCK: "/inventory/low-stock",
    ALL_OUT_OF_STOCK: "/inventory/out-of-stock",
    ALL_EXPIRING: "/inventory/expiring",
    ALL_EXPIRED: "/inventory/expired",
  },

  // Inventory Transactions
  INVENTORY_TRANSACTIONS: {
    BASE: "/inventory-transactions",
    BY_ID: (id) => `/inventory-transactions/${id}`,
    BY_BRANCH: (branchId) => `/inventory-transactions/branch/${branchId}`,
  },

  // GRN
  GRN: {
    BASE: "/grn",
    BY_ID: (id) => `/grn/${id}`,
    BY_NUMBER: (number) => `/grn/number/${number}`,
    BY_BRANCH: (branchId) => `/grn/branch/${branchId}`,
    BY_SUPPLIER: (supplierId) => `/grn/supplier/${supplierId}`,
    BY_STATUS: (status) => `/grn/status/${status}`,
    PENDING: (branchId) => `/grn/branch/${branchId}/pending`,
    APPROVE: (id) => `/grn/${id}/approve`,
    REJECT: (id) => `/grn/${id}/reject`,
    CANCEL: (id) => `/grn/${id}/cancel`,
  },

  // RGRN (Return GRN)
  RGRN: {
    BASE: "/rgrns",
    BY_ID: (id) => `/rgrns/${id}`,
    BY_NUMBER: (number) => `/rgrns/number/${number}`,
    BY_BRANCH: (branchId) => `/rgrns/branch/${branchId}`,
    BY_SUPPLIER: (supplierId) => `/rgrns/supplier/${supplierId}`,
    BY_GRN: (grnId) => `/rgrns/grn/${grnId}`,
    UPDATE_REFUND_STATUS: (id) => `/rgrns/${id}/refund-status`,
  },

  // Stock Transfers
  STOCK_TRANSFERS: {
    BASE: "/stock-transfers",
    BY_ID: (id) => `/stock-transfers/${id}`,
    BY_NUMBER: (number) => `/stock-transfers/number/${number}`,
    BY_BRANCH: (branchId) => `/stock-transfers/branch/${branchId}`,
    BY_SOURCE: (branchId) => `/stock-transfers/from-branch/${branchId}`,
    BY_DESTINATION: (branchId) => `/stock-transfers/to-branch/${branchId}`,
    BY_STATUS: (status) => `/stock-transfers/status/${status}`,
    PENDING: (branchId) => `/stock-transfers/branch/${branchId}/pending`,
    APPROVE: (id) => `/stock-transfers/${id}/approve`,
    REJECT: (id) => `/stock-transfers/${id}/reject`,
    RECEIVE: (id) => `/stock-transfers/${id}/receive`,
    CANCEL: (id) => `/stock-transfers/${id}/cancel`,
  },

  // Suppliers
  SUPPLIERS: {
    BASE: "/suppliers",
    BY_ID: (id) => `/suppliers/${id}`,
    BY_CODE: (code) => `/suppliers/code/${code}`,
    SEARCH: "/suppliers/search",
    ACTIVE: "/suppliers/active",
    ACTIVATE: (id) => `/suppliers/${id}/activate`,
    DEACTIVATE: (id) => `/suppliers/${id}/deactivate`,
  },

  // Purchase Orders
  PURCHASE_ORDERS: {
    BASE: "/purchase-orders",
    BY_ID: (id) => `/purchase-orders/${id}`,
    BY_NUMBER: (number) => `/purchase-orders/number/${number}`,
    BY_BRANCH: (branchId) => `/purchase-orders/branch/${branchId}`,
    BY_SUPPLIER: (supplierId) => `/purchase-orders/supplier/${supplierId}`,
    BY_STATUS: (status) => `/purchase-orders/status/${status}`,
    PENDING: (branchId) => `/purchase-orders/branch/${branchId}/pending`,
    UPDATE_STATUS: (id) => `/purchase-orders/${id}/status`,
    SUBMIT: (id) => `/purchase-orders/${id}/status`,
    APPROVE: (id) => `/purchase-orders/${id}/approve`,
    REJECT: (id) => `/purchase-orders/${id}/reject`,
    CANCEL: (id) => `/purchase-orders/${id}/cancel`,
  },

  // Supplier Payments
  SUPPLIER_PAYMENTS: {
    BASE: "/supplier-payments",
    BY_ID: (id) => `/supplier-payments/${id}`,
    BY_SUPPLIER: (supplierId) => `/supplier-payments/supplier/${supplierId}`,
  },

  // Customers
  CUSTOMERS: {
    BASE: "/customers",
    BY_ID: (id) => `/customers/${id}`,
    BY_CODE: (code) => `/customers/code/${code}`,
    SEARCH: "/customers/search",
    ACTIVE: "/customers/active",
    ACTIVATE: (id) => `/customers/${id}/activate`,
    DEACTIVATE: (id) => `/customers/${id}/deactivate`,
  },

  // Sales
  SALES: {
    BASE: "/sales",
    LIST: "/sales",
    BY_ID: (id) => `/sales/${id}`,
    BY_NUMBER: (number) => `/sales/number/${number}`,
    BY_BRANCH: (branchId) => `/sales/branch/${branchId}`,
    BY_CUSTOMER: (customerId) => `/sales/customer/${customerId}`,
    BY_DATE_RANGE: "/sales/date-range",
    BY_STATUS: (status) => `/sales/status/${status}`,
    CANCEL: (id) => `/sales/${id}/cancel`,
    VOID: (id) => `/sales/${id}/void`,
    TOTAL_AMOUNT: "/sales/total-amount",
    COUNT: "/sales/count",
  },

  // Sale Returns
  SALE_RETURNS: {
    BASE: "/sale-returns",
    BY_ID: (id) => `/sale-returns/${id}`,
    BY_NUMBER: (number) => `/sale-returns/number/${number}`,
    BY_BRANCH: (branchId) => `/sale-returns/branch/${branchId}`,
    BY_CUSTOMER: (customerId) => `/sale-returns/customer/${customerId}`,
    BY_SALE: (saleId) => `/sale-returns/sale/${saleId}`,
  },

  // Invoices
  INVOICES: {
    BASE: "/invoices",
    BY_ID: (id) => `/invoices/${id}`,
    BY_NUMBER: (number) => `/invoices/number/${number}`,
    BY_BRANCH: (branchId) => `/invoices/branch/${branchId}`,
    BY_CUSTOMER: (customerId) => `/invoices/customer/${customerId}`,
    BY_STATUS: (status) => `/invoices/status/${status}`,
    BY_PAYMENT_STATUS: (status) => `/invoices/payment-status/${status}`,
    OVERDUE: "/invoices/overdue",
    RECORD_PAYMENT: (id) => `/invoices/${id}/payment`,
    OUTSTANDING_BY_CUSTOMER: (customerId) =>
      `/invoices/customer/${customerId}/outstanding`,
    BY_SALE: (saleId) => `/invoices/sale/${saleId}`,
  },

  // Prescriptions
  PRESCRIPTIONS: {
    BASE: "/prescriptions",
    BY_ID: (id) => `/prescriptions/${id}`,
    BY_CUSTOMER: (customerId) => `/prescriptions/customer/${customerId}`,
  },

  // Customer Prescriptions
  CUSTOMER_PRESCRIPTIONS: {
    BASE: "/customer-prescriptions",
    BY_ID: (id) => `/customer-prescriptions/${id}`,
    BY_CUSTOMER: (customerId) =>
      `/customer-prescriptions/customer/${customerId}`,
  },

  // Finance - Banks
  BANKS: {
    BASE: "/banks",
    BY_ID: (id) => `/banks/${id}`,
  },

  // Finance - Cash Book
  CASH_BOOK: {
    BASE: "/cashbook",
    BY_BRANCH: (branchId) => `/cashbook/branch/${branchId}`,
  },

  // Finance - Cheques
  CHEQUES: {
    BASE: "/cheques",
    BY_ID: (id) => `/cheques/${id}`,
  },

  // Payroll
  PAYROLL: {
    BASE: "/payroll",
    BY_ID: (id) => `/payroll/${id}`,
    BY_EMPLOYEE: (employeeId) => `/payroll/employee/${employeeId}`,
  },

  // Dashboard
  DASHBOARD: {
    STATS: "/dashboard/summary",
    SUMMARY: "/dashboard/summary",
    SALES_CHART: "/dashboard/sales-chart",
  },

  // Reports
  REPORTS: {
    // Sales Reports
    SALES: {
      TOTAL: "/reports/sales/total",
      COUNT: "/reports/sales/count",
      DETAILS: "/reports/sales/details",
      DAILY: "/reports/sales/daily",
      TOP_PRODUCTS: "/reports/sales/top-products",
      BY_PAYMENT_METHOD: "/reports/sales/by-payment-method",
      COMPARISON: "/reports/sales/comparison",
    },
    // Inventory Reports
    INVENTORY: {
      STOCK_VALUE: "/reports/inventory/stock-value",
      VALUE_BY_CATEGORY: "/reports/inventory/value-by-category",
      LOW_STOCK: "/reports/inventory/low-stock",
      EXPIRING: "/reports/inventory/expiring",
      EXPIRED: "/reports/inventory/expired",
      SUMMARY: "/reports/inventory/summary",
      DEAD_STOCK: "/reports/inventory/dead-stock",
    },
    // Financial Reports
    FINANCIAL: {
      REVENUE: "/reports/financial/revenue",
      DAILY_REVENUE: "/reports/financial/daily-revenue",
      PROFIT_LOSS: "/reports/financial/profit-loss",
      CASH_FLOW: "/reports/financial/cash-flow",
      RECEIVABLES: "/reports/financial/receivables",
      AGEING: "/reports/financial/ageing",
      TAX: "/reports/financial/tax",
    },
    // Alerts
    ALERTS: {
      ALL: "/reports/alerts",
      COUNT: "/reports/alerts/count",
      LOW_STOCK: "/reports/alerts/low-stock",
      EXPIRY: "/reports/alerts/expiry",
      OVERDUE: "/reports/alerts/overdue",
      ACKNOWLEDGE: (id) => `/reports/alerts/${id}/acknowledge`,
    },
  },

  // Notifications
  NOTIFICATIONS: {
    BASE: "/notifications",
    BY_ID: (id) => `/notifications/${id}`,
    UNREAD: "/notifications/unread",
    MARK_READ: (id) => `/notifications/${id}/read`,
    MARK_ALL_READ: "/notifications/read-all",
  },

  // System Config
  SYSTEM_CONFIG: {
    BASE: "/system-config",
    BY_KEY: (key) => `/system-config/${key}`,
  },

  // Bin Cards
  BIN_CARDS: {
    BASE: "/bin-cards",
    BY_PRODUCT: (productId) => `/bin-cards/product/${productId}`,
    BY_BRANCH_PRODUCT: (branchId, productId) =>
      `/bin-cards/branch/${branchId}/product/${productId}`,
  },
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\config\app.config.js"   & echo.. 
/**
 * Application Configuration
 * Central configuration for app-wide settings
 */

export const APP_CONFIG = {
  // App info
  NAME: import.meta.env.VITE_APP_NAME || "MedLan Pharmacy",
  SHORT_NAME: "MedLan",
  VERSION: import.meta.env.VITE_APP_VERSION || "1.0.0",
  DESCRIPTION: "Pharmacy Management System",

  // Locale settings
  LOCALE: {
    CURRENCY: "LKR",
    CURRENCY_SYMBOL: "Rs.",
    DATE_FORMAT: "dd/MM/yyyy",
    TIME_FORMAT: "HH:mm",
    DATETIME_FORMAT: "dd/MM/yyyy HH:mm",
    TIMEZONE: "Asia/Colombo",
  },

  // Pagination defaults
  PAGINATION: {
    DEFAULT_PAGE_SIZE: 10,
    PAGE_SIZE_OPTIONS: [10, 20, 50, 100],
  },

  // UI settings
  UI: {
    SIDEBAR_COLLAPSED_KEY: "sidebarCollapsed",
    THEME_KEY: "theme",
    DEFAULT_THEME: "light",
  },

  // Debounce delays (ms)
  DEBOUNCE: {
    SEARCH: 300,
    INPUT: 500,
  },

  // Toast durations (ms)
  TOAST: {
    SUCCESS: 3000,
    ERROR: 5000,
    INFO: 4000,
    WARNING: 4000,
  },

  // File upload
  UPLOAD: {
    MAX_SIZE: 5 * 1024 * 1024, // 5MB
    ALLOWED_TYPES: ["image/jpeg", "image/png", "image/gif", "application/pdf"],
    ALLOWED_IMAGE_TYPES: ["image/jpeg", "image/png", "image/gif"],
  },

  // Inventory settings
  INVENTORY: {
    LOW_STOCK_THRESHOLD: 10,
    EXPIRY_WARNING_DAYS: 90, // 3 months
    EXPIRY_CRITICAL_DAYS: 30, // 1 month
  },

  // POS settings
  POS: {
    DEFAULT_TAX_RATE: 0, // No tax by default
    MAX_DISCOUNT_PERCENT: 100,
    PRINT_RECEIPT_AUTO: true,
    SHOW_STOCK_WARNING: true,
  },

  // Session settings
  SESSION: {
    IDLE_TIMEOUT: 30 * 60 * 1000, // 30 minutes
    TOKEN_REFRESH_THRESHOLD: 5 * 60 * 1000, // Refresh 5 minutes before expiry
  },
};

// Feature flags
export const FEATURES = {
  PRESCRIPTION_REQUIRED: true,
  DRUG_INTERACTION_CHECK: true,
  MULTI_BRANCH: true,
  OFFLINE_MODE: false,
  BARCODE_SCANNER: true,
  BATCH_TRACKING: true,
  EXPIRY_ALERTS: true,
  LOW_STOCK_ALERTS: true,
  REAL_TIME_NOTIFICATIONS: true,
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\config\index.js"   & echo.. 
export * from "./api.config";
export * from "./app.config";
export * from "./routes.config";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\config\routes.config.js"   & echo.. 
/**
 * Route Configuration
 * Central configuration for all application routes
 */

export const ROUTES = {
  // Auth routes (public)
  AUTH: {
    LOGIN: "/login",
    FORGOT_PASSWORD: "/forgot-password",
    RESET_PASSWORD: "/reset-password",
    CHANGE_PASSWORD: "/change-password",
  },

  // Dashboard
  DASHBOARD: "/dashboard",

  // POS (Point of Sale)
  POS: {
    ROOT: "/pos",
    NEW_SALE: "/pos/new",
    HELD_SALES: "/pos/held",
    HISTORY: "/pos/history",
    RETURNS: "/pos/returns",
  },

  // Products
  PRODUCTS: {
    ROOT: "/products",
    LIST: "/products",
    NEW: "/products/new",
    EDIT: (id = ":id") => `/products/${id}/edit`,
    VIEW: (id = ":id") => `/products/${id}`,
    LOW_STOCK: "/products/low-stock",
    EXPIRING: "/products/expiring",
  },

  // Categories
  CATEGORIES: {
    ROOT: "/categories",
    LIST: "/categories",
    SUB_CATEGORIES: "/categories/sub",
    UNITS: "/units",
  },

  // Inventory
  INVENTORY: {
    ROOT: "/inventory",
    STOCK: "/inventory",
    LIST: "/inventory",
    AVAILABLE: "/inventory/available",
    MOVEMENTS: "/inventory/movements",
    TRANSFERS: {
      LIST: "/inventory/transfers",
      NEW: "/inventory/transfers/new",
      VIEW: (id = ":id") => `/inventory/transfers/${id}`,
      RECEIVE: (id = ":id") => `/inventory/transfers/${id}/receive`,
    },
    BATCHES: "/inventory/batches",
    ADJUSTMENTS: {
      LIST: "/inventory/adjustments",
      NEW: "/inventory/adjustments/new",
      VIEW: (id = ":id") => `/inventory/adjustments/${id}`,
    },
    LOW_STOCK: "/inventory/low-stock",
    EXPIRY: "/inventory/expiry",
    BIN_CARD: (productId = ":productId") => `/inventory/bin-card/${productId}`,
  },

  // Purchase Orders
  PURCHASE_ORDERS: {
    ROOT: "/purchase-orders",
    LIST: "/purchase-orders",
    NEW: "/purchase-orders/new",
    CREATE: "/purchase-orders/new",
    EDIT: (id = ":id") => `/purchase-orders/${id}/edit`,
    VIEW: (id = ":id") => `/purchase-orders/${id}`,
  },

  // GRN (Goods Received Note)
  GRN: {
    ROOT: "/grn",
    LIST: "/grn",
    CREATE: "/grn/new",
    DIRECT: "/grn/direct",
    EDIT: (id = ":id") => `/grn/${id}/edit`,
    VIEW: (id = ":id") => `/grn/${id}`,
  },

  // RGRN (Return GRN)
  RGRN: {
    ROOT: "/rgrn",
    LIST: "/rgrn",
    CREATE: "/rgrn/new",
    VIEW: (id = ":id") => `/rgrn/${id}`,
  },

  // Suppliers
  SUPPLIERS: {
    ROOT: "/suppliers",
    LIST: "/suppliers",
    NEW: "/suppliers/new",
    CREATE: "/suppliers/new",
    EDIT: (id = ":id") => `/suppliers/${id}/edit`,
    VIEW: (id = ":id") => `/suppliers/${id}`,
  },

  // Customers
  CUSTOMERS: {
    ROOT: "/customers",
    LIST: "/customers",
    NEW: "/customers/new",
    CREATE: "/customers/new",
    EDIT: (id = ":id") => `/customers/${id}/edit`,
    VIEW: (id = ":id") => `/customers/${id}`,
    CREDITS: "/customers/credits",
  },

  // Finance
  FINANCE: {
    ROOT: "/finance",
    OVERVIEW: "/finance",
    TRANSACTIONS: "/finance/transactions",
    INVOICES: "/finance/invoices",
    CHEQUES: "/finance/cheques",
    CASH_REGISTER: "/finance/cash-register",
    BANKS: "/finance/banks",
    CASH_BOOK: "/finance/cash-book",
    SUMMARY: "/finance/summary",
  },

  // Payroll
  PAYROLL: {
    ROOT: "/payroll",
    LIST: "/payroll",
    SALARIES: "/payroll/salaries",
    ATTENDANCE: "/payroll/attendance",
    ADVANCES: "/payroll/advances",
    PAYSLIP: (id = ":id") => `/payroll/${id}`,
  },

  // Reports
  REPORTS: {
    ROOT: "/reports",
    SALES: "/reports/sales",
    INVENTORY: "/reports/inventory",
    FINANCIAL: "/reports/financial",
    EMPLOYEES: "/reports/employees",
    AUDIT: "/reports/audit",
    PURCHASE: "/reports/purchase",
    EXPIRY: "/reports/expiry",
    PROFIT_LOSS: "/reports/profit-loss",
  },

  // Employees
  EMPLOYEES: {
    ROOT: "/employees",
    LIST: "/employees",
    NEW: "/employees/new",
    EDIT: (id = ":id") => `/employees/${id}/edit`,
    VIEW: (id = ":id") => `/employees/${id}`,
    ATTENDANCE: "/employees/attendance",
  },

  // Branches
  BRANCHES: {
    ROOT: "/branches",
    LIST: "/branches",
    NEW: "/branches/new",
    CREATE: "/branches/new",
    EDIT: (id = ":id") => `/branches/${id}/edit`,
    STAFF: (id = ":id") => `/branches/${id}/staff`,
  },

  // Users
  USERS: {
    ROOT: "/users",
    LIST: "/users",
    NEW: "/users/new",
    CREATE: "/users/new",
    EDIT: (id = ":id") => `/users/${id}/edit`,
    VIEW: (id = ":id") => `/users/${id}`,
  },

  // Settings
  SETTINGS: {
    ROOT: "/settings",
    GENERAL: "/settings/general",
    BRANCH: "/settings/branch",
    TAX: "/settings/tax",
    NOTIFICATIONS: "/settings/notifications",
    PROFILE: "/settings/profile",
    SYSTEM: "/settings/system",
    BACKUP: "/settings/backup",
  },

  // Sales
  SALES: {
    LIST: "/sales",
    VIEW: (id = ":id") => `/sales/${id}`,
  },

  // Sale Returns
  SALE_RETURNS: {
    LIST: "/sale-returns",
    CREATE: "/sale-returns/new",
    VIEW: (id = ":id") => `/sale-returns/${id}`,
  },

  // Invoices
  INVOICES: {
    LIST: "/invoices",
    VIEW: (id = ":id") => `/invoices/${id}`,
  },

  // Prescriptions
  PRESCRIPTIONS: {
    LIST: "/prescriptions",
    VIEW: (id = ":id") => `/prescriptions/${id}`,
  },

  // Supplier Payments
  SUPPLIER_PAYMENTS: {
    LIST: "/supplier-payments",
    CREATE: "/supplier-payments/new",
    VIEW: (id = ":id") => `/supplier-payments/${id}`,
  },

  // Stock Transfers
  STOCK_TRANSFERS: {
    LIST: "/stock-transfers",
    CREATE: "/stock-transfers/new",
    VIEW: (id = ":id") => `/stock-transfers/${id}`,
  },

  // Audit
  AUDIT: {
    LOGS: "/audit/logs",
  },

  // Error pages
  ERRORS: {
    NOT_FOUND: "/404",
    UNAUTHORIZED: "/401",
    SERVER_ERROR: "/500",
  },
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\alertLevel.js"   & echo.. 
/**
 * Alert Level - Matching backend AlertLevel.java enum
 */
export const ALERT_LEVEL = {
  INFO: "INFO",
  WARNING: "WARNING",
  CRITICAL: "CRITICAL",
  LOW: "LOW",
  MEDIUM: "MEDIUM",
  HIGH: "HIGH",
};

export const ALERT_LEVEL_LABELS = {
  [ALERT_LEVEL.INFO]: "Information",
  [ALERT_LEVEL.WARNING]: "Warning",
  [ALERT_LEVEL.CRITICAL]: "Critical",
  [ALERT_LEVEL.LOW]: "Low",
  [ALERT_LEVEL.MEDIUM]: "Medium",
  [ALERT_LEVEL.HIGH]: "High",
};

export const ALERT_LEVEL_COLORS = {
  [ALERT_LEVEL.INFO]: "bg-blue-100 text-blue-800",
  [ALERT_LEVEL.WARNING]: "bg-yellow-100 text-yellow-800",
  [ALERT_LEVEL.CRITICAL]: "bg-red-100 text-red-800",
  [ALERT_LEVEL.LOW]: "bg-green-100 text-green-800",
  [ALERT_LEVEL.MEDIUM]: "bg-yellow-100 text-yellow-800",
  [ALERT_LEVEL.HIGH]: "bg-red-100 text-red-800",
};

export const ALERT_LEVEL_OPTIONS = Object.entries(ALERT_LEVEL_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\authorizationStatus.js"   & echo.. 
/**
 * Authorization Status - Matching backend AuthorizationStatus.java enum
 */
export const AUTHORIZATION_STATUS = {
  PENDING: "PENDING",
  APPROVED: "APPROVED",
  REJECTED: "REJECTED",
  EXPIRED: "EXPIRED",
  CANCELLED: "CANCELLED",
};

export const AUTHORIZATION_STATUS_LABELS = {
  [AUTHORIZATION_STATUS.PENDING]: "Pending",
  [AUTHORIZATION_STATUS.APPROVED]: "Approved",
  [AUTHORIZATION_STATUS.REJECTED]: "Rejected",
  [AUTHORIZATION_STATUS.EXPIRED]: "Expired",
  [AUTHORIZATION_STATUS.CANCELLED]: "Cancelled",
};

export const AUTHORIZATION_STATUS_COLORS = {
  [AUTHORIZATION_STATUS.PENDING]: "bg-yellow-100 text-yellow-800",
  [AUTHORIZATION_STATUS.APPROVED]: "bg-green-100 text-green-800",
  [AUTHORIZATION_STATUS.REJECTED]: "bg-red-100 text-red-800",
  [AUTHORIZATION_STATUS.EXPIRED]: "bg-gray-100 text-gray-800",
  [AUTHORIZATION_STATUS.CANCELLED]: "bg-gray-200 text-gray-600",
};

export const AUTHORIZATION_STATUS_OPTIONS = Object.entries(
  AUTHORIZATION_STATUS_LABELS
).map(([value, label]) => ({
  value,
  label,
}));
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\chequeStatus.js"   & echo.. 
/**
 * Cheque Status - Matching backend ChequeStatus.java enum
 */
export const CHEQUE_STATUS = {
  PENDING: "PENDING",
  DEPOSITED: "DEPOSITED",
  CLEARED: "CLEARED",
  BOUNCED: "BOUNCED",
  CANCELLED: "CANCELLED",
  REPLACED: "REPLACED",
};

export const CHEQUE_STATUS_LABELS = {
  [CHEQUE_STATUS.PENDING]: "Pending",
  [CHEQUE_STATUS.DEPOSITED]: "Deposited",
  [CHEQUE_STATUS.CLEARED]: "Cleared",
  [CHEQUE_STATUS.BOUNCED]: "Bounced",
  [CHEQUE_STATUS.CANCELLED]: "Cancelled",
  [CHEQUE_STATUS.REPLACED]: "Replaced",
};

export const CHEQUE_STATUS_COLORS = {
  [CHEQUE_STATUS.PENDING]: "bg-yellow-100 text-yellow-800",
  [CHEQUE_STATUS.DEPOSITED]: "bg-blue-100 text-blue-800",
  [CHEQUE_STATUS.CLEARED]: "bg-green-100 text-green-800",
  [CHEQUE_STATUS.BOUNCED]: "bg-red-100 text-red-800",
  [CHEQUE_STATUS.CANCELLED]: "bg-gray-100 text-gray-800",
  [CHEQUE_STATUS.REPLACED]: "bg-purple-100 text-purple-800",
};

export const CHEQUE_STATUS_OPTIONS = Object.entries(CHEQUE_STATUS_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\customerStatus.js"   & echo.. 
/**
 * Customer Status - Matching backend CustomerStatus.java enum
 */
export const CUSTOMER_STATUS = {
  ACTIVE: "ACTIVE",
  INACTIVE: "INACTIVE",
  BLOCKED: "BLOCKED",
  PENDING: "PENDING",
};

export const CUSTOMER_STATUS_LABELS = {
  [CUSTOMER_STATUS.ACTIVE]: "Active",
  [CUSTOMER_STATUS.INACTIVE]: "Inactive",
  [CUSTOMER_STATUS.BLOCKED]: "Blocked",
  [CUSTOMER_STATUS.PENDING]: "Pending",
};

export const CUSTOMER_STATUS_COLORS = {
  [CUSTOMER_STATUS.ACTIVE]: "bg-green-100 text-green-800",
  [CUSTOMER_STATUS.INACTIVE]: "bg-gray-100 text-gray-800",
  [CUSTOMER_STATUS.BLOCKED]: "bg-red-100 text-red-800",
  [CUSTOMER_STATUS.PENDING]: "bg-yellow-100 text-yellow-800",
};

export const CUSTOMER_STATUS_OPTIONS = Object.entries(
  CUSTOMER_STATUS_LABELS
).map(([value, label]) => ({
  value,
  label,
}));
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\dosageForm.js"   & echo.. 
/**
 * Dosage Form - Matching backend DosageForm.java enum
 */
export const DOSAGE_FORM = {
  TABLET: "TABLET",
  CAPSULE: "CAPSULE",
  SYRUP: "SYRUP",
  SUSPENSION: "SUSPENSION",
  INJECTION: "INJECTION",
  CREAM: "CREAM",
  OINTMENT: "OINTMENT",
  GEL: "GEL",
  DROPS: "DROPS",
  INHALER: "INHALER",
  POWDER: "POWDER",
  LOTION: "LOTION",
  SPRAY: "SPRAY",
  SUPPOSITORY: "SUPPOSITORY",
  PATCH: "PATCH",
};

export const DOSAGE_FORM_LABELS = {
  [DOSAGE_FORM.TABLET]: "Tablet",
  [DOSAGE_FORM.CAPSULE]: "Capsule",
  [DOSAGE_FORM.SYRUP]: "Syrup",
  [DOSAGE_FORM.SUSPENSION]: "Suspension",
  [DOSAGE_FORM.INJECTION]: "Injection",
  [DOSAGE_FORM.CREAM]: "Cream",
  [DOSAGE_FORM.OINTMENT]: "Ointment",
  [DOSAGE_FORM.GEL]: "Gel",
  [DOSAGE_FORM.DROPS]: "Drops",
  [DOSAGE_FORM.INHALER]: "Inhaler",
  [DOSAGE_FORM.POWDER]: "Powder",
  [DOSAGE_FORM.LOTION]: "Lotion",
  [DOSAGE_FORM.SPRAY]: "Spray",
  [DOSAGE_FORM.PATCH]: "Patch",
  [DOSAGE_FORM.SUPPOSITORY]: "Suppository",
};

export const DOSAGE_FORM_OPTIONS = Object.entries(DOSAGE_FORM_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\drugSchedule.js"   & echo.. 
/**
 * Drug Schedule - Matching backend DrugSchedule.java enum
 * Based on Indian pharmaceutical regulations
 */
export const DRUG_SCHEDULE = {
  H: "H",
  H1: "H1",
  X: "X",
  G: "G",
  C: "C",
  C1: "C1",
};

export const DRUG_SCHEDULE_LABELS = {
  [DRUG_SCHEDULE.H]: "Schedule H - Prescription Required",
  [DRUG_SCHEDULE.H1]: "Schedule H1 - Restricted Prescription",
  [DRUG_SCHEDULE.X]: "Schedule X - Narcotic/Psychotropic",
  [DRUG_SCHEDULE.G]: "Schedule G - General Sale (OTC)",
  [DRUG_SCHEDULE.C]: "Schedule C - Controlled Drug",
  [DRUG_SCHEDULE.C1]: "Schedule C1 - Controlled Drug (Restricted)",
};

export const DRUG_SCHEDULE_SHORT_LABELS = {
  [DRUG_SCHEDULE.H]: "Schedule H",
  [DRUG_SCHEDULE.H1]: "Schedule H1",
  [DRUG_SCHEDULE.X]: "Schedule X",
  [DRUG_SCHEDULE.G]: "Schedule G",
  [DRUG_SCHEDULE.C]: "Schedule C",
  [DRUG_SCHEDULE.C1]: "Schedule C1",
};

export const DRUG_SCHEDULE_COLORS = {
  [DRUG_SCHEDULE.H]: "bg-red-100 text-red-800",
  [DRUG_SCHEDULE.H1]: "bg-red-200 text-red-900",
  [DRUG_SCHEDULE.X]: "bg-purple-100 text-purple-800",
  [DRUG_SCHEDULE.G]: "bg-green-100 text-green-800",
  [DRUG_SCHEDULE.C]: "bg-orange-100 text-orange-800",
  [DRUG_SCHEDULE.C1]: "bg-orange-200 text-orange-900",
};

export const DRUG_SCHEDULE_OPTIONS = Object.entries(DRUG_SCHEDULE_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);

// Schedules that require prescription
export const PRESCRIPTION_REQUIRED_SCHEDULES = [
  DRUG_SCHEDULE.H,
  DRUG_SCHEDULE.H1,
  DRUG_SCHEDULE.X,
  DRUG_SCHEDULE.C,
  DRUG_SCHEDULE.C1,
  DRUG_SCHEDULE.H1,
  DRUG_SCHEDULE.X,
];

export const requiresPrescription = (schedule) => {
  return PRESCRIPTION_REQUIRED_SCHEDULES.includes(schedule);
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\employmentType.js"   & echo.. 
/**
 * Employment Type - Matching backend EmploymentType.java enum
 */
export const EMPLOYMENT_TYPE = {
  FULL_TIME: "FULL_TIME",
  PART_TIME: "PART_TIME",
  CONTRACT: "CONTRACT",
  TEMPORARY: "TEMPORARY",
  INTERN: "INTERN",
  CONSULTANT: "CONSULTANT",
};

export const EMPLOYMENT_TYPE_LABELS = {
  [EMPLOYMENT_TYPE.FULL_TIME]: "Full Time",
  [EMPLOYMENT_TYPE.PART_TIME]: "Part Time",
  [EMPLOYMENT_TYPE.CONTRACT]: "Contract",
  [EMPLOYMENT_TYPE.TEMPORARY]: "Temporary",
  [EMPLOYMENT_TYPE.INTERN]: "Intern",
  [EMPLOYMENT_TYPE.CONSULTANT]: "Consultant",
};

export const EMPLOYMENT_TYPE_OPTIONS = Object.entries(
  EMPLOYMENT_TYPE_LABELS
).map(([value, label]) => ({
  value,
  label,
}));
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\gender.js"   & echo.. 
/**
 * Gender - Matching backend Gender.java enum
 */
export const GENDER = {
  MALE: "MALE",
  FEMALE: "FEMALE",
  OTHER: "OTHER",
};

export const GENDER_LABELS = {
  [GENDER.MALE]: "Male",
  [GENDER.FEMALE]: "Female",
  [GENDER.OTHER]: "Other",
};

export const GENDER_OPTIONS = Object.entries(GENDER_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\grnStatus.js"   & echo.. 
/**
 * GRN Status - Matching backend GRNStatus.java enum
 */
export const GRN_STATUS = {
  PENDING: "PENDING",
  APPROVED: "APPROVED",
  REJECTED: "REJECTED",
  CANCELLED: "CANCELLED",
};

export const GRN_STATUS_LABELS = {
  [GRN_STATUS.PENDING]: "Pending",
  [GRN_STATUS.APPROVED]: "Approved",
  [GRN_STATUS.REJECTED]: "Rejected",
  [GRN_STATUS.CANCELLED]: "Cancelled",
};

export const GRN_STATUS_COLORS = {
  [GRN_STATUS.PENDING]: "bg-yellow-100 text-yellow-800",
  [GRN_STATUS.APPROVED]: "bg-green-100 text-green-800",
  [GRN_STATUS.REJECTED]: "bg-red-100 text-red-800",
  [GRN_STATUS.CANCELLED]: "bg-gray-100 text-gray-800",
};

export const GRN_STATUS_OPTIONS = Object.entries(GRN_STATUS_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\index.js"   & echo.. 
/**
 * Constants barrel export
 * Central export for all constant definitions
 */

// Roles & Permissions
export * from "./roles";
export * from "./permissions";

// User related
export * from "./gender";
export * from "./employmentType";

// Product related
export * from "./dosageForm";
export * from "./drugSchedule";
export * from "./unitOfMeasure";

// Inventory related
export * from "./stockMovementType";
export * from "./transferStatus";
export * from "./grnStatus";

// Purchasing related
export * from "./poStatus";

// Sales related
export * from "./saleStatus";
export * from "./paymentMethods";
export * from "./paymentStatus";
export * from "./returnReason";
export * from "./customerStatus";
export * from "./invoiceStatus";

// Finance related
export * from "./chequeStatus";
export * from "./transactionType";

// System related
export * from "./notificationType";
export * from "./alertLevel";
export * from "./authorizationStatus";
export * from "./syncStatus";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\invoiceStatus.js"   & echo.. 
/**
 * Invoice Status - Matching backend InvoiceStatus.java enum
 */
export const INVOICE_STATUS = {
  DRAFT: "DRAFT",
  SENT: "SENT",
  PAID: "PAID",
  PARTIAL: "PARTIAL",
  OVERDUE: "OVERDUE",
  CANCELLED: "CANCELLED",
};

export const INVOICE_STATUS_LABELS = {
  [INVOICE_STATUS.DRAFT]: "Draft",
  [INVOICE_STATUS.SENT]: "Sent",
  [INVOICE_STATUS.PAID]: "Paid",
  [INVOICE_STATUS.PARTIAL]: "Partial Payment",
  [INVOICE_STATUS.OVERDUE]: "Overdue",
  [INVOICE_STATUS.CANCELLED]: "Cancelled",
};

export const INVOICE_STATUS_COLORS = {
  [INVOICE_STATUS.DRAFT]: "bg-gray-100 text-gray-800",
  [INVOICE_STATUS.SENT]: "bg-blue-100 text-blue-800",
  [INVOICE_STATUS.PAID]: "bg-green-100 text-green-800",
  [INVOICE_STATUS.PARTIAL]: "bg-yellow-100 text-yellow-800",
  [INVOICE_STATUS.OVERDUE]: "bg-red-100 text-red-800",
  [INVOICE_STATUS.CANCELLED]: "bg-gray-200 text-gray-600",
};

export const INVOICE_STATUS_OPTIONS = Object.entries(INVOICE_STATUS_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\notificationType.js"   & echo.. 
/**
 * Notification Type - Matching backend NotificationType.java enum
 */
export const NOTIFICATION_TYPE = {
  LOW_STOCK: "LOW_STOCK",
  OUT_OF_STOCK: "OUT_OF_STOCK",
  EXPIRY_ALERT: "EXPIRY_ALERT",
  EXPIRED: "EXPIRED",
  NEW_ORDER: "NEW_ORDER",
  ORDER_APPROVED: "ORDER_APPROVED",
  ORDER_REJECTED: "ORDER_REJECTED",
  TRANSFER_REQUEST: "TRANSFER_REQUEST",
  TRANSFER_APPROVED: "TRANSFER_APPROVED",
  PAYMENT_DUE: "PAYMENT_DUE",
  SYSTEM: "SYSTEM",
  INFO: "INFO",
};

export const NOTIFICATION_TYPE_LABELS = {
  [NOTIFICATION_TYPE.LOW_STOCK]: "Low Stock",
  [NOTIFICATION_TYPE.OUT_OF_STOCK]: "Out of Stock",
  [NOTIFICATION_TYPE.EXPIRY_ALERT]: "Expiry Alert",
  [NOTIFICATION_TYPE.EXPIRED]: "Expired",
  [NOTIFICATION_TYPE.NEW_ORDER]: "New Order",
  [NOTIFICATION_TYPE.ORDER_APPROVED]: "Order Approved",
  [NOTIFICATION_TYPE.ORDER_REJECTED]: "Order Rejected",
  [NOTIFICATION_TYPE.TRANSFER_REQUEST]: "Transfer Request",
  [NOTIFICATION_TYPE.TRANSFER_APPROVED]: "Transfer Approved",
  [NOTIFICATION_TYPE.PAYMENT_DUE]: "Payment Due",
  [NOTIFICATION_TYPE.SYSTEM]: "System",
  [NOTIFICATION_TYPE.INFO]: "Information",
};

export const NOTIFICATION_TYPE_COLORS = {
  [NOTIFICATION_TYPE.LOW_STOCK]: "bg-yellow-100 text-yellow-800",
  [NOTIFICATION_TYPE.OUT_OF_STOCK]: "bg-red-100 text-red-800",
  [NOTIFICATION_TYPE.EXPIRY_ALERT]: "bg-orange-100 text-orange-800",
  [NOTIFICATION_TYPE.EXPIRED]: "bg-red-200 text-red-900",
  [NOTIFICATION_TYPE.NEW_ORDER]: "bg-blue-100 text-blue-800",
  [NOTIFICATION_TYPE.ORDER_APPROVED]: "bg-green-100 text-green-800",
  [NOTIFICATION_TYPE.ORDER_REJECTED]: "bg-red-100 text-red-800",
  [NOTIFICATION_TYPE.TRANSFER_REQUEST]: "bg-purple-100 text-purple-800",
  [NOTIFICATION_TYPE.TRANSFER_APPROVED]: "bg-green-100 text-green-800",
  [NOTIFICATION_TYPE.PAYMENT_DUE]: "bg-orange-100 text-orange-800",
  [NOTIFICATION_TYPE.SYSTEM]: "bg-gray-100 text-gray-800",
  [NOTIFICATION_TYPE.INFO]: "bg-cyan-100 text-cyan-800",
};

export const NOTIFICATION_TYPE_ICONS = {
  [NOTIFICATION_TYPE.LOW_STOCK]: "AlertTriangle",
  [NOTIFICATION_TYPE.OUT_OF_STOCK]: "XCircle",
  [NOTIFICATION_TYPE.EXPIRY_ALERT]: "Clock",
  [NOTIFICATION_TYPE.EXPIRED]: "AlertOctagon",
  [NOTIFICATION_TYPE.NEW_ORDER]: "ShoppingCart",
  [NOTIFICATION_TYPE.ORDER_APPROVED]: "CheckCircle",
  [NOTIFICATION_TYPE.ORDER_REJECTED]: "XCircle",
  [NOTIFICATION_TYPE.TRANSFER_REQUEST]: "ArrowRightLeft",
  [NOTIFICATION_TYPE.TRANSFER_APPROVED]: "CheckCircle",
  [NOTIFICATION_TYPE.PAYMENT_DUE]: "DollarSign",
  [NOTIFICATION_TYPE.SYSTEM]: "Settings",
  [NOTIFICATION_TYPE.INFO]: "Info",
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\paymentMethods.js"   & echo.. 
/**
 * Payment Methods - Matching backend PaymentMethod.java enum
 */
export const PAYMENT_METHOD = {
  CASH: "CASH",
  CARD: "CARD",
  UPI: "UPI",
  BANK_TRANSFER: "BANK_TRANSFER",
  CHEQUE: "CHEQUE",
  CREDIT: "CREDIT",
  MIXED: "MIXED",
};

export const PAYMENT_METHOD_LABELS = {
  [PAYMENT_METHOD.CASH]: "Cash",
  [PAYMENT_METHOD.CARD]: "Card",
  [PAYMENT_METHOD.UPI]: "UPI",
  [PAYMENT_METHOD.BANK_TRANSFER]: "Bank Transfer",
  [PAYMENT_METHOD.CHEQUE]: "Cheque",
  [PAYMENT_METHOD.CREDIT]: "Credit",
  [PAYMENT_METHOD.MIXED]: "Mixed Payment",
};

export const PAYMENT_METHOD_COLORS = {
  [PAYMENT_METHOD.CASH]: "bg-green-100 text-green-800",
  [PAYMENT_METHOD.CARD]: "bg-blue-100 text-blue-800",
  [PAYMENT_METHOD.UPI]: "bg-purple-100 text-purple-800",
  [PAYMENT_METHOD.BANK_TRANSFER]: "bg-cyan-100 text-cyan-800",
  [PAYMENT_METHOD.CHEQUE]: "bg-yellow-100 text-yellow-800",
  [PAYMENT_METHOD.CREDIT]: "bg-orange-100 text-orange-800",
  [PAYMENT_METHOD.MIXED]: "bg-gray-100 text-gray-800",
};

export const PAYMENT_METHOD_ICONS = {
  [PAYMENT_METHOD.CASH]: "Banknote",
  [PAYMENT_METHOD.CARD]: "CreditCard",
  [PAYMENT_METHOD.UPI]: "Smartphone",
  [PAYMENT_METHOD.BANK_TRANSFER]: "Building2",
  [PAYMENT_METHOD.CHEQUE]: "FileText",
  [PAYMENT_METHOD.CREDIT]: "Clock",
  [PAYMENT_METHOD.MIXED]: "Layers",
};

export const PAYMENT_METHOD_OPTIONS = Object.entries(PAYMENT_METHOD_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\paymentStatus.js"   & echo.. 
/**
 * Payment Status - Matching backend PaymentStatus.java enum
 */
export const PAYMENT_STATUS = {
  PAID: "PAID",
  PARTIAL: "PARTIAL",
  PENDING: "PENDING",
  OVERDUE: "OVERDUE",
  REFUNDED: "REFUNDED",
};

export const PAYMENT_STATUS_LABELS = {
  [PAYMENT_STATUS.PAID]: "Paid",
  [PAYMENT_STATUS.PARTIAL]: "Partial",
  [PAYMENT_STATUS.PENDING]: "Pending",
  [PAYMENT_STATUS.OVERDUE]: "Overdue",
  [PAYMENT_STATUS.REFUNDED]: "Refunded",
};

export const PAYMENT_STATUS_COLORS = {
  [PAYMENT_STATUS.PAID]: "bg-green-100 text-green-800",
  [PAYMENT_STATUS.PARTIAL]: "bg-yellow-100 text-yellow-800",
  [PAYMENT_STATUS.PENDING]: "bg-blue-100 text-blue-800",
  [PAYMENT_STATUS.OVERDUE]: "bg-red-100 text-red-800",
  [PAYMENT_STATUS.REFUNDED]: "bg-purple-100 text-purple-800",
};

export const PAYMENT_STATUS_OPTIONS = Object.entries(PAYMENT_STATUS_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\permissions.js"   & echo.. 
/**
 * Role-Based Permissions Matrix
 * Maps roles to feature access levels
 */
import { ROLES } from "./roles";

export const PERMISSIONS = {
  [ROLES.SUPER_ADMIN]: {
    dashboard: { view: true },
    users: {
      view: true,
      create: true,
      edit: true,
      delete: true,
      resetPassword: true,
    },
    branches: { view: true, create: true, edit: true, delete: true },
    categories: { view: true, create: true, edit: true, delete: true },
    products: {
      view: true,
      create: true,
      edit: true,
      delete: true,
      pricing: true,
    },
    inventory: { view: true, adjust: true, transfer: true, receive: true },
    purchaseOrders: {
      view: true,
      create: true,
      edit: true,
      delete: true,
      approve: true,
      reject: true,
    },
    grn: { view: true, create: true, approve: true, reject: true },
    sales: {
      view: true,
      create: true,
      cancel: true,
      void: true,
      discount: 100,
      credit: true,
      creditLimit: Infinity,
    },
    returns: { view: true, create: true, approve: true },
    customers: { view: true, create: true, edit: true, delete: true },
    suppliers: { view: true, create: true, edit: true, delete: true },
    reports: { view: true, export: true },
    finance: { view: true, manage: true },
    payroll: { view: true, manage: true },
    settings: { view: true, edit: true },
    audit: { view: true },
  },

  [ROLES.ADMIN]: {
    dashboard: { view: true },
    users: {
      view: true,
      create: true,
      edit: true,
      delete: false,
      resetPassword: true,
    },
    branches: { view: true, create: false, edit: true, delete: false },
    categories: { view: true, create: true, edit: true, delete: true },
    products: {
      view: true,
      create: true,
      edit: true,
      delete: false,
      pricing: true,
    },
    inventory: { view: true, adjust: true, transfer: true, receive: true },
    purchaseOrders: {
      view: true,
      create: true,
      edit: true,
      delete: true,
      approve: true,
      reject: true,
    },
    grn: { view: true, create: true, approve: true, reject: true },
    sales: {
      view: true,
      create: true,
      cancel: true,
      void: false,
      discount: 20,
      credit: true,
      creditLimit: 50000,
    },
    returns: { view: true, create: true, approve: true },
    customers: { view: true, create: true, edit: true, delete: false },
    suppliers: { view: true, create: true, edit: true, delete: false },
    reports: { view: true, export: true },
    finance: { view: true, manage: true },
    payroll: { view: true, manage: false },
    settings: { view: true, edit: false },
    audit: { view: true },
  },

  [ROLES.BRANCH_MANAGER]: {
    dashboard: { view: true },
    users: {
      view: true,
      create: false,
      edit: false,
      delete: false,
      resetPassword: false,
    },
    branches: { view: true, create: false, edit: false, delete: false },
    categories: { view: true, create: false, edit: false, delete: false },
    products: {
      view: true,
      create: false,
      edit: false,
      delete: false,
      pricing: false,
    },
    inventory: { view: true, adjust: true, transfer: true, receive: false },
    purchaseOrders: {
      view: true,
      create: true,
      edit: true,
      approve: false,
      reject: false,
    },
    grn: { view: true, create: false, approve: false, reject: false },
    sales: {
      view: true,
      create: true,
      cancel: true,
      void: false,
      discount: 15,
      credit: true,
      creditLimit: 20000,
    },
    returns: { view: true, create: true, approve: true },
    customers: { view: true, create: true, edit: true, delete: false },
    suppliers: { view: true, create: false, edit: false, delete: false },
    reports: { view: true, export: true },
    finance: { view: true, manage: false },
    payroll: { view: false, manage: false },
    settings: { view: false, edit: false },
    audit: { view: false },
  },

  [ROLES.PHARMACIST]: {
    dashboard: { view: true },
    users: {
      view: false,
      create: false,
      edit: false,
      delete: false,
      resetPassword: false,
    },
    branches: { view: true, create: false, edit: false, delete: false },
    categories: { view: true, create: false, edit: false, delete: false },
    products: {
      view: true,
      create: false,
      edit: false,
      delete: false,
      pricing: false,
    },
    inventory: { view: true, adjust: false, transfer: false, receive: false },
    purchaseOrders: {
      view: false,
      create: false,
      edit: false,
      approve: false,
      reject: false,
    },
    grn: { view: false, create: false, approve: false, reject: false },
    sales: {
      view: true,
      create: true,
      cancel: false,
      void: false,
      discount: 10,
      credit: true,
      creditLimit: 5000,
    },
    returns: { view: true, create: true, approve: false },
    customers: { view: true, create: true, edit: true, delete: false },
    suppliers: { view: false, create: false, edit: false, delete: false },
    reports: { view: false, export: false },
    finance: { view: false, manage: false },
    payroll: { view: false, manage: false },
    settings: { view: false, edit: false },
    audit: { view: false },
    prescriptions: { view: true, create: true, verify: true },
  },

  [ROLES.CASHIER]: {
    dashboard: { view: true },
    users: {
      view: false,
      create: false,
      edit: false,
      delete: false,
      resetPassword: false,
    },
    branches: { view: true, create: false, edit: false, delete: false },
    categories: { view: true, create: false, edit: false, delete: false },
    products: {
      view: true,
      create: false,
      edit: false,
      delete: false,
      pricing: false,
    },
    inventory: { view: true, adjust: false, transfer: false, receive: false },
    purchaseOrders: {
      view: false,
      create: false,
      edit: false,
      approve: false,
      reject: false,
    },
    grn: { view: false, create: false, approve: false, reject: false },
    sales: {
      view: true,
      create: true,
      cancel: false,
      void: false,
      discount: 5,
      credit: false,
      creditLimit: 0,
    },
    returns: { view: true, create: true, approve: false },
    customers: { view: true, create: true, edit: false, delete: false },
    suppliers: { view: false, create: false, edit: false, delete: false },
    reports: { view: false, export: false },
    finance: { view: false, manage: false },
    payroll: { view: false, manage: false },
    settings: { view: false, edit: false },
    audit: { view: false },
  },

  [ROLES.INVENTORY_MANAGER]: {
    dashboard: { view: true },
    users: {
      view: false,
      create: false,
      edit: false,
      delete: false,
      resetPassword: false,
    },
    branches: { view: true, create: false, edit: false, delete: false },
    categories: { view: true, create: true, edit: true, delete: false },
    products: {
      view: true,
      create: true,
      edit: true,
      delete: false,
      pricing: false,
    },
    inventory: { view: true, adjust: true, transfer: true, receive: true },
    purchaseOrders: {
      view: true,
      create: true,
      edit: true,
      approve: false,
      reject: false,
    },
    grn: { view: true, create: true, approve: false, reject: false },
    sales: {
      view: false,
      create: false,
      cancel: false,
      void: false,
      discount: 0,
      credit: false,
      creditLimit: 0,
    },
    returns: { view: true, create: false, approve: false },
    customers: { view: false, create: false, edit: false, delete: false },
    suppliers: { view: true, create: true, edit: true, delete: false },
    reports: { view: true, export: true },
    finance: { view: false, manage: false },
    payroll: { view: false, manage: false },
    settings: { view: false, edit: false },
    audit: { view: false },
  },

  [ROLES.ACCOUNTANT]: {
    dashboard: { view: true },
    users: {
      view: false,
      create: false,
      edit: false,
      delete: false,
      resetPassword: false,
    },
    branches: { view: true, create: false, edit: false, delete: false },
    categories: { view: true, create: false, edit: false, delete: false },
    products: {
      view: true,
      create: false,
      edit: false,
      delete: false,
      pricing: true,
    },
    inventory: { view: true, adjust: false, transfer: false, receive: false },
    purchaseOrders: {
      view: true,
      create: false,
      edit: false,
      approve: true,
      reject: true,
    },
    grn: { view: true, create: false, approve: true, reject: true },
    sales: {
      view: true,
      create: false,
      cancel: false,
      void: false,
      discount: 0,
      credit: false,
      creditLimit: 0,
    },
    returns: { view: true, create: false, approve: true },
    customers: { view: true, create: false, edit: false, delete: false },
    suppliers: { view: true, create: false, edit: false, delete: false },
    reports: { view: true, export: true },
    finance: { view: true, manage: true },
    payroll: { view: true, manage: false },
    settings: { view: false, edit: false },
    audit: { view: true },
  },
};

/**
 * Check if a role has permission for a feature action
 * @param {string} role - User role
 * @param {string} feature - Feature name (e.g., 'products', 'sales')
 * @param {string} action - Action name (e.g., 'view', 'create', 'edit')
 * @returns {boolean}
 */
export const hasPermission = (role, feature, action) => {
  const rolePermissions = PERMISSIONS[role];
  if (!rolePermissions) return false;

  const featurePermissions = rolePermissions[feature];
  if (!featurePermissions) return false;

  return featurePermissions[action] === true;
};

/**
 * Get the maximum discount percentage for a role
 * @param {string} role - User role
 * @returns {number}
 */
export const getMaxDiscount = (role) => {
  return PERMISSIONS[role]?.sales?.discount || 0;
};

/**
 * Check if role can give credit
 * @param {string} role - User role
 * @returns {boolean}
 */
export const canGiveCredit = (role) => {
  return PERMISSIONS[role]?.sales?.credit || false;
};

/**
 * Get credit limit for a role
 * @param {string} role - User role
 * @returns {number}
 */
export const getCreditLimit = (role) => {
  return PERMISSIONS[role]?.sales?.creditLimit || 0;
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\poStatus.js"   & echo.. 
/**
 * Purchase Order Status - Matching backend POStatus.java enum
 */
export const PO_STATUS = {
  DRAFT: "DRAFT",
  PENDING: "PENDING",
  APPROVED: "APPROVED",
  REJECTED: "REJECTED",
  PARTIAL: "PARTIAL",
  COMPLETED: "COMPLETED",
  CANCELLED: "CANCELLED",
};

export const PO_STATUS_LABELS = {
  [PO_STATUS.DRAFT]: "Draft",
  [PO_STATUS.PENDING]: "Pending Approval",
  [PO_STATUS.APPROVED]: "Approved",
  [PO_STATUS.REJECTED]: "Rejected",
  [PO_STATUS.PARTIAL]: "Partially Received",
  [PO_STATUS.COMPLETED]: "Completed",
  [PO_STATUS.CANCELLED]: "Cancelled",
};

export const PO_STATUS_COLORS = {
  [PO_STATUS.DRAFT]: "bg-gray-100 text-gray-800",
  [PO_STATUS.PENDING]: "bg-yellow-100 text-yellow-800",
  [PO_STATUS.APPROVED]: "bg-blue-100 text-blue-800",
  [PO_STATUS.REJECTED]: "bg-red-100 text-red-800",
  [PO_STATUS.PARTIAL]: "bg-orange-100 text-orange-800",
  [PO_STATUS.COMPLETED]: "bg-green-100 text-green-800",
  [PO_STATUS.CANCELLED]: "bg-gray-200 text-gray-600",
};

export const PO_STATUS_OPTIONS = Object.entries(PO_STATUS_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\returnReason.js"   & echo.. 
/**
 * Return Reason - Matching backend ReturnReason.java enum
 */
export const RETURN_REASON = {
  DAMAGED: "DAMAGED",
  EXPIRED: "EXPIRED",
  WRONG_ITEM: "WRONG_ITEM",
  QUALITY_ISSUE: "QUALITY_ISSUE",
  CUSTOMER_REQUEST: "CUSTOMER_REQUEST",
  OTHER: "OTHER",
};

export const RETURN_REASON_LABELS = {
  [RETURN_REASON.DAMAGED]: "Damaged",
  [RETURN_REASON.EXPIRED]: "Expired",
  [RETURN_REASON.WRONG_ITEM]: "Wrong Item",
  [RETURN_REASON.QUALITY_ISSUE]: "Quality Issue",
  [RETURN_REASON.CUSTOMER_REQUEST]: "Customer Request",
  [RETURN_REASON.OTHER]: "Other",
};

export const RETURN_REASON_COLORS = {
  [RETURN_REASON.DAMAGED]: "bg-red-100 text-red-800",
  [RETURN_REASON.EXPIRED]: "bg-orange-100 text-orange-800",
  [RETURN_REASON.WRONG_ITEM]: "bg-yellow-100 text-yellow-800",
  [RETURN_REASON.QUALITY_ISSUE]: "bg-purple-100 text-purple-800",
  [RETURN_REASON.CUSTOMER_REQUEST]: "bg-blue-100 text-blue-800",
  [RETURN_REASON.OTHER]: "bg-gray-100 text-gray-800",
};

export const RETURN_REASON_OPTIONS = Object.entries(RETURN_REASON_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\roles.js"   & echo.. 
/**
 * User Roles - Matching backend Role.java enum
 */
export const ROLES = {
  SUPER_ADMIN: "SUPER_ADMIN",
  ADMIN: "ADMIN",
  OWNER: "ADMIN", // Alias for backward compatibility
  BRANCH_MANAGER: "BRANCH_MANAGER",
  BRANCH_ADMIN: "BRANCH_MANAGER", // Alias for backward compatibility
  PHARMACIST: "PHARMACIST",
  CASHIER: "CASHIER",
  INVENTORY_MANAGER: "INVENTORY_MANAGER",
  ACCOUNTANT: "ACCOUNTANT",
};

export const ROLE_LABELS = {
  [ROLES.SUPER_ADMIN]: "Super Admin",
  [ROLES.ADMIN]: "Admin",
  [ROLES.BRANCH_MANAGER]: "Branch Manager",
  [ROLES.PHARMACIST]: "Pharmacist",
  [ROLES.CASHIER]: "Cashier",
  [ROLES.INVENTORY_MANAGER]: "Inventory Manager",
  [ROLES.ACCOUNTANT]: "Accountant",
};

export const ROLE_COLORS = {
  [ROLES.SUPER_ADMIN]: "#9333ea", // purple-600
  [ROLES.ADMIN]: "#2563eb", // blue-600
  [ROLES.BRANCH_MANAGER]: "#16a34a", // green-600
  [ROLES.PHARMACIST]: "#0891b2", // cyan-600
  [ROLES.CASHIER]: "#ca8a04", // yellow-600
  [ROLES.INVENTORY_MANAGER]: "#ea580c", // orange-600
  [ROLES.ACCOUNTANT]: "#db2777", // pink-600
};

// Role hierarchy for authorization checks
export const ROLE_HIERARCHY = {
  [ROLES.SUPER_ADMIN]: 7,
  [ROLES.ADMIN]: 6,
  [ROLES.BRANCH_MANAGER]: 5,
  [ROLES.ACCOUNTANT]: 4,
  [ROLES.INVENTORY_MANAGER]: 3,
  [ROLES.PHARMACIST]: 2,
  [ROLES.CASHIER]: 1,
};

export const getRoleLabel = (role) => ROLE_LABELS[role] || role;
export const getRoleColor = (role) => ROLE_COLORS[role] || "#6b7280";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\saleStatus.js"   & echo.. 
/**
 * Sale Status - Matching backend SaleStatus.java enum
 */
export const SALE_STATUS = {
  COMPLETED: "COMPLETED",
  CANCELLED: "CANCELLED",
  VOIDED: "VOIDED",
  PENDING: "PENDING",
  ON_HOLD: "ON_HOLD",
};

export const SALE_STATUS_LABELS = {
  [SALE_STATUS.COMPLETED]: "Completed",
  [SALE_STATUS.CANCELLED]: "Cancelled",
  [SALE_STATUS.VOIDED]: "Voided",
  [SALE_STATUS.PENDING]: "Pending",
  [SALE_STATUS.ON_HOLD]: "On Hold",
};

export const SALE_STATUS_COLORS = {
  [SALE_STATUS.COMPLETED]: "bg-green-100 text-green-800",
  [SALE_STATUS.CANCELLED]: "bg-red-100 text-red-800",
  [SALE_STATUS.VOIDED]: "bg-gray-100 text-gray-800",
  [SALE_STATUS.PENDING]: "bg-yellow-100 text-yellow-800",
  [SALE_STATUS.ON_HOLD]: "bg-orange-100 text-orange-800",
};

export const SALE_STATUS_OPTIONS = Object.entries(SALE_STATUS_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\stockMovementType.js"   & echo.. 
/**
 * Stock Movement Type - Matching backend StockMovementType.java enum
 */
export const STOCK_MOVEMENT_TYPE = {
  PURCHASE: "PURCHASE",
  SALE: "SALE",
  SALE_RETURN: "SALE_RETURN",
  PURCHASE_RETURN: "PURCHASE_RETURN",
  TRANSFER_IN: "TRANSFER_IN",
  TRANSFER_OUT: "TRANSFER_OUT",
  ADJUSTMENT_IN: "ADJUSTMENT_IN",
  ADJUSTMENT_OUT: "ADJUSTMENT_OUT",
  EXPIRED: "EXPIRED",
  DAMAGED: "DAMAGED",
  OPENING_STOCK: "OPENING_STOCK",
};

export const STOCK_MOVEMENT_TYPE_LABELS = {
  [STOCK_MOVEMENT_TYPE.PURCHASE]: "Purchase",
  [STOCK_MOVEMENT_TYPE.SALE]: "Sale",
  [STOCK_MOVEMENT_TYPE.SALE_RETURN]: "Sale Return",
  [STOCK_MOVEMENT_TYPE.PURCHASE_RETURN]: "Purchase Return",
  [STOCK_MOVEMENT_TYPE.TRANSFER_IN]: "Transfer In",
  [STOCK_MOVEMENT_TYPE.TRANSFER_OUT]: "Transfer Out",
  [STOCK_MOVEMENT_TYPE.ADJUSTMENT_IN]: "Adjustment In",
  [STOCK_MOVEMENT_TYPE.ADJUSTMENT_OUT]: "Adjustment Out",
  [STOCK_MOVEMENT_TYPE.EXPIRED]: "Expired",
  [STOCK_MOVEMENT_TYPE.DAMAGED]: "Damaged",
  [STOCK_MOVEMENT_TYPE.OPENING_STOCK]: "Opening Stock",
};

export const STOCK_MOVEMENT_TYPE_COLORS = {
  [STOCK_MOVEMENT_TYPE.PURCHASE]: "bg-green-100 text-green-800",
  [STOCK_MOVEMENT_TYPE.SALE]: "bg-blue-100 text-blue-800",
  [STOCK_MOVEMENT_TYPE.SALE_RETURN]: "bg-yellow-100 text-yellow-800",
  [STOCK_MOVEMENT_TYPE.PURCHASE_RETURN]: "bg-orange-100 text-orange-800",
  [STOCK_MOVEMENT_TYPE.TRANSFER_IN]: "bg-cyan-100 text-cyan-800",
  [STOCK_MOVEMENT_TYPE.TRANSFER_OUT]: "bg-purple-100 text-purple-800",
  [STOCK_MOVEMENT_TYPE.ADJUSTMENT_IN]: "bg-teal-100 text-teal-800",
  [STOCK_MOVEMENT_TYPE.ADJUSTMENT_OUT]: "bg-pink-100 text-pink-800",
  [STOCK_MOVEMENT_TYPE.EXPIRED]: "bg-red-100 text-red-800",
  [STOCK_MOVEMENT_TYPE.DAMAGED]: "bg-red-200 text-red-900",
  [STOCK_MOVEMENT_TYPE.OPENING_STOCK]: "bg-gray-100 text-gray-800",
};

// Movement types that increase stock
export const STOCK_IN_TYPES = [
  STOCK_MOVEMENT_TYPE.PURCHASE,
  STOCK_MOVEMENT_TYPE.SALE_RETURN,
  STOCK_MOVEMENT_TYPE.TRANSFER_IN,
  STOCK_MOVEMENT_TYPE.ADJUSTMENT_IN,
  STOCK_MOVEMENT_TYPE.OPENING_STOCK,
];

// Movement types that decrease stock
export const STOCK_OUT_TYPES = [
  STOCK_MOVEMENT_TYPE.SALE,
  STOCK_MOVEMENT_TYPE.PURCHASE_RETURN,
  STOCK_MOVEMENT_TYPE.TRANSFER_OUT,
  STOCK_MOVEMENT_TYPE.ADJUSTMENT_OUT,
  STOCK_MOVEMENT_TYPE.EXPIRED,
  STOCK_MOVEMENT_TYPE.DAMAGED,
];

export const isStockIn = (type) => STOCK_IN_TYPES.includes(type);
export const isStockOut = (type) => STOCK_OUT_TYPES.includes(type);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\syncStatus.js"   & echo.. 
/**
 * Sync Status - Matching backend SyncStatus.java enum
 */
export const SYNC_STATUS = {
  PENDING: "PENDING",
  IN_PROGRESS: "IN_PROGRESS",
  COMPLETED: "COMPLETED",
  FAILED: "FAILED",
};

export const SYNC_STATUS_LABELS = {
  [SYNC_STATUS.PENDING]: "Pending",
  [SYNC_STATUS.IN_PROGRESS]: "In Progress",
  [SYNC_STATUS.COMPLETED]: "Completed",
  [SYNC_STATUS.FAILED]: "Failed",
};

export const SYNC_STATUS_COLORS = {
  [SYNC_STATUS.PENDING]: "bg-yellow-100 text-yellow-800",
  [SYNC_STATUS.IN_PROGRESS]: "bg-blue-100 text-blue-800",
  [SYNC_STATUS.COMPLETED]: "bg-green-100 text-green-800",
  [SYNC_STATUS.FAILED]: "bg-red-100 text-red-800",
};

export const SYNC_STATUS_OPTIONS = Object.entries(SYNC_STATUS_LABELS).map(
  ([value, label]) => ({
    value,
    label,
  })
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\transactionType.js"   & echo.. 
/**
 * Transaction Type - Matching backend TransactionType.java enum
 */
export const TRANSACTION_TYPE = {
  INCOME: "INCOME",
  EXPENSE: "EXPENSE",
  TRANSFER: "TRANSFER",
  ADJUSTMENT: "ADJUSTMENT",
};

export const TRANSACTION_TYPE_LABELS = {
  [TRANSACTION_TYPE.INCOME]: "Income",
  [TRANSACTION_TYPE.EXPENSE]: "Expense",
  [TRANSACTION_TYPE.TRANSFER]: "Transfer",
  [TRANSACTION_TYPE.ADJUSTMENT]: "Adjustment",
};

export const TRANSACTION_TYPE_COLORS = {
  [TRANSACTION_TYPE.INCOME]: "bg-green-100 text-green-800",
  [TRANSACTION_TYPE.EXPENSE]: "bg-red-100 text-red-800",
  [TRANSACTION_TYPE.TRANSFER]: "bg-blue-100 text-blue-800",
  [TRANSACTION_TYPE.ADJUSTMENT]: "bg-yellow-100 text-yellow-800",
};

export const TRANSACTION_TYPE_OPTIONS = Object.entries(
  TRANSACTION_TYPE_LABELS
).map(([value, label]) => ({
  value,
  label,
}));
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\transferStatus.js"   & echo.. 
/**
 * Transfer Status - Matching backend TransferStatus.java enum
 */
export const TRANSFER_STATUS = {
  PENDING: "PENDING",
  APPROVED: "APPROVED",
  REJECTED: "REJECTED",
  IN_TRANSIT: "IN_TRANSIT",
  RECEIVED: "RECEIVED",
  CANCELLED: "CANCELLED",
};

export const TRANSFER_STATUS_LABELS = {
  [TRANSFER_STATUS.PENDING]: "Pending",
  [TRANSFER_STATUS.APPROVED]: "Approved",
  [TRANSFER_STATUS.REJECTED]: "Rejected",
  [TRANSFER_STATUS.IN_TRANSIT]: "In Transit",
  [TRANSFER_STATUS.RECEIVED]: "Received",
  [TRANSFER_STATUS.CANCELLED]: "Cancelled",
};

export const TRANSFER_STATUS_COLORS = {
  [TRANSFER_STATUS.PENDING]: "bg-yellow-100 text-yellow-800",
  [TRANSFER_STATUS.APPROVED]: "bg-blue-100 text-blue-800",
  [TRANSFER_STATUS.REJECTED]: "bg-red-100 text-red-800",
  [TRANSFER_STATUS.IN_TRANSIT]: "bg-purple-100 text-purple-800",
  [TRANSFER_STATUS.RECEIVED]: "bg-green-100 text-green-800",
  [TRANSFER_STATUS.CANCELLED]: "bg-gray-100 text-gray-800",
};

export const TRANSFER_STATUS_OPTIONS = Object.entries(
  TRANSFER_STATUS_LABELS
).map(([value, label]) => ({
  value,
  label,
}));
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\constants\unitOfMeasure.js"   & echo.. 
/**
 * Unit of Measure - Matching backend UnitOfMeasure.java enum
 */
export const UNIT_OF_MEASURE = {
  PIECE: "PIECE",
  TABLET: "TABLET",
  CAPSULE: "CAPSULE",
  STRIP: "STRIP",
  BOX: "BOX",
  BOTTLE: "BOTTLE",
  VIAL: "VIAL",
  AMPOULE: "AMPOULE",
  TUBE: "TUBE",
  SACHET: "SACHET",
  ML: "ML",
  LITER: "LITER",
  GRAM: "GRAM",
  KG: "KG",
  MG: "MG",
};

export const UNIT_OF_MEASURE_LABELS = {
  [UNIT_OF_MEASURE.PIECE]: "Piece",
  [UNIT_OF_MEASURE.TABLET]: "Tablet",
  [UNIT_OF_MEASURE.CAPSULE]: "Capsule",
  [UNIT_OF_MEASURE.STRIP]: "Strip",
  [UNIT_OF_MEASURE.BOX]: "Box",
  [UNIT_OF_MEASURE.BOTTLE]: "Bottle",
  [UNIT_OF_MEASURE.VIAL]: "Vial",
  [UNIT_OF_MEASURE.AMPOULE]: "Ampoule",
  [UNIT_OF_MEASURE.TUBE]: "Tube",
  [UNIT_OF_MEASURE.SACHET]: "Sachet",
  [UNIT_OF_MEASURE.ML]: "ml",
  [UNIT_OF_MEASURE.LITER]: "Liter",
  [UNIT_OF_MEASURE.GRAM]: "Gram",
  [UNIT_OF_MEASURE.KG]: "Kg",
  [UNIT_OF_MEASURE.MG]: "mg",
};

export const UNIT_OF_MEASURE_ABBREVIATIONS = {
  [UNIT_OF_MEASURE.PIECE]: "pc",
  [UNIT_OF_MEASURE.TABLET]: "tab",
  [UNIT_OF_MEASURE.CAPSULE]: "cap",
  [UNIT_OF_MEASURE.STRIP]: "strip",
  [UNIT_OF_MEASURE.BOX]: "box",
  [UNIT_OF_MEASURE.BOTTLE]: "btl",
  [UNIT_OF_MEASURE.VIAL]: "vial",
  [UNIT_OF_MEASURE.AMPOULE]: "amp",
  [UNIT_OF_MEASURE.TUBE]: "tube",
  [UNIT_OF_MEASURE.SACHET]: "sach",
  [UNIT_OF_MEASURE.ML]: "ml",
  [UNIT_OF_MEASURE.LITER]: "L",
  [UNIT_OF_MEASURE.GRAM]: "g",
  [UNIT_OF_MEASURE.KG]: "kg",
  [UNIT_OF_MEASURE.MG]: "mg",
};

export const UNIT_OF_MEASURE_OPTIONS = Object.entries(
  UNIT_OF_MEASURE_LABELS
).map(([value, label]) => ({
  value,
  label,
}));
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\index.js"   & echo.. 
/**
 * Features Barrel Export
 */

export * from "./auth";
export * from "./dashboard";
export * from "./products";
export * from "./categories";
export * from "./inventory";
export * from "./customers";
export * from "./suppliers";
export * from "./users";
export * from "./branches";
export * from "./purchase-orders";
export * from "./grn";
export * from "./reports";
export * from "./sales";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\auth\index.js"   & echo.. 
/**
 * Auth Feature Barrel Export
 */

// Components
export { default as LoginForm } from "./components/LoginForm";

// Hooks
export { useLogin, useLogout } from "./hooks/useLogin";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\auth\hooks\useLogin.js"   & echo.. 
/**
 * useLogin Hook
 * Handles login API call and authentication state
 */

import { useMutation } from "@tanstack/react-query";
import { useNavigate, useLocation } from "react-router-dom";
import { toast } from "sonner";
import { api } from "@/utils";
import { useAuthStore } from "@/store";
import { API_ENDPOINTS, ROUTES } from "@/config";
import { ROLES } from "@/constants";

/**
 * Get the default landing page based on user role
 * @param {string} role - User's role
 * @returns {string} - Route path for the role
 */
const getDefaultRouteForRole = (role) => {
  switch (role) {
    // POS-focused roles go directly to POS
    case ROLES.CASHIER:
    case ROLES.PHARMACIST:
      return ROUTES.POS.ROOT;
    
    // Finance-focused role
    case ROLES.ACCOUNTANT:
      return ROUTES.DASHBOARD; // Could be ROUTES.FINANCE.ROOT
    
    // Inventory-focused role
    case ROLES.INVENTORY_MANAGER:
      return ROUTES.DASHBOARD; // Could be ROUTES.INVENTORY.ROOT
    
    // Admin roles go to dashboard
    case ROLES.SUPER_ADMIN:
    case ROLES.ADMIN:
    case ROLES.BRANCH_MANAGER:
    default:
      return ROUTES.DASHBOARD;
  }
};

/**
 * Login mutation hook
 */
export const useLogin = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { setAuth } = useAuthStore();

  // Get redirect path from location state (if user was redirected from a protected route)
  const intendedDestination = location.state?.from;

  return useMutation({
    mutationFn: async (credentials) => {
      const response = await api.post(API_ENDPOINTS.AUTH.LOGIN, credentials);
      // Backend returns: { success, message, data: { accessToken, refreshToken, userId, username, ... } }
      return response.data.data; // Extract the actual login data from ApiResponse wrapper
    },
    onSuccess: (data) => {
      // Build user object from response fields
      const user = {
        id: data.userId,
        username: data.username,
        fullName: data.fullName,
        email: data.email,
        role: data.role,
      };

      // Set auth state
      setAuth({
        user,
        accessToken: data.accessToken,
        refreshToken: data.refreshToken,
      });

      toast.success(`Welcome back, ${user.fullName || user.username}!`);

      // Navigate to intended destination if exists, otherwise role-based default
      const destination = intendedDestination || getDefaultRouteForRole(user.role);
      navigate(destination, { replace: true });
    },
    onError: (error) => {
      const message = error.response?.data?.message || "Invalid credentials";
      toast.error(message);
    },
  });
};

/**
 * Logout hook
 */
export const useLogout = () => {
  const navigate = useNavigate();
  const { clearAuth } = useAuthStore();

  return useMutation({
    mutationFn: async () => {
      try {
        // Call logout endpoint if exists
        await api.post(API_ENDPOINTS.AUTH.LOGOUT);
      } catch {
        // Ignore logout API errors
      }
    },
    onSettled: () => {
      // Always clear auth state
      clearAuth();
      toast.success("Logged out successfully");
      navigate(ROUTES.AUTH.LOGIN, { replace: true });
    },
  });
};

export default useLogin;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\branches\index.js"   & echo.. 
/**
 * Branches Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\branches\components\index.js"   & echo.. 
/**
 * Branches Components Barrel Export
 */

export { default as BranchForm } from "./BranchForm";
export { default as getBranchColumns } from "./BranchColumns";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\branches\hooks\index.js"   & echo.. 
/**
 * Branches Hooks Barrel Export
 */

export * from "./useBranches";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\branches\hooks\useBranches.js"   & echo.. 
/**
 * Branch Hooks
 * React Query hooks for branch management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { branchService } from "@/services";
import { toast } from "sonner";

// Query keys factory
export const branchKeys = {
  all: ["branches"],
  lists: () => [...branchKeys.all, "list"],
  list: (filters) => [...branchKeys.lists(), filters],
  details: () => [...branchKeys.all, "detail"],
  detail: (id) => [...branchKeys.details(), id],
  active: () => [...branchKeys.all, "active"],
};

/**
 * Hook to fetch branches list
 */
export const useBranches = (params = {}, options = {}) => {
  return useQuery({
    queryKey: branchKeys.list(params),
    queryFn: () => branchService.getAll(params),
    select: (response) => response.data.data, // ApiResponse.data contains PageResponse or List
    ...options,
  });
};

/**
 * Hook to fetch active branches (for dropdowns)
 */
export const useActiveBranches = (options = {}) => {
  return useQuery({
    queryKey: branchKeys.active(),
    queryFn: () => branchService.getAllList(),
    select: (response) => {
      const data = response.data.data; // ApiResponse.data contains List
      return Array.isArray(data) ? data.filter((b) => b.isActive) : [];
    },
    staleTime: 5 * 60 * 1000,
    ...options,
  });
};

/**
 * Hook to fetch a single branch
 */
export const useBranch = (id, options = {}) => {
  return useQuery({
    queryKey: branchKeys.detail(id),
    queryFn: () => branchService.getById(id),
    select: (response) => response.data.data, // ApiResponse.data contains BranchResponse
    enabled: Boolean(id),
    ...options,
  });
};

/**
 * Hook to create branch
 */
export const useCreateBranch = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => branchService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: branchKeys.all });
      toast.success("Branch created successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to create branch");
    },
  });
};

/**
 * Hook to update branch
 */
export const useUpdateBranch = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => branchService.update(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: branchKeys.all });
      queryClient.invalidateQueries({ queryKey: branchKeys.detail(id) });
      toast.success("Branch updated successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to update branch");
    },
  });
};

/**
 * Hook to delete branch
 */
export const useDeleteBranch = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => branchService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: branchKeys.all });
      toast.success("Branch deleted successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to delete branch");
    },
  });
};

/**
 * Hook to activate branch
 */
export const useActivateBranch = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => branchService.activate(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: branchKeys.all });
      toast.success("Branch activated");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to activate branch");
    },
  });
};

/**
 * Hook to deactivate branch
 */
export const useDeactivateBranch = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => branchService.deactivate(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: branchKeys.all });
      toast.success("Branch deactivated");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to deactivate branch"
      );
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\categories\index.js"   & echo.. 
/**
 * Categories Feature Barrel Export
 */

// Re-export hooks from products (categories are managed there)
export {
  useCategories,
  useActiveCategories,
  useCategory,
  useCreateCategory,
  useUpdateCategory,
  useDeleteCategory,
  categoryKeys,
} from "@/features/products/hooks/useCategories";

// Export components
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\categories\components\index.js"   & echo.. 
/**
 * Categories Components Barrel Export
 */

export { default as CategoryFormDialog } from "./CategoryFormDialog";
export {
  default as getCategoryColumns,
  getCategoryColumns as categoryColumns,
} from "./CategoryColumns";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\customers\index.js"   & echo.. 
/**
 * Customers Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\customers\components\index.js"   & echo.. 
/**
 * Customers Components Barrel Export
 */

export { default as CustomerForm } from "./CustomerForm";
export { default as getCustomerColumns } from "./CustomerColumns";
export { getCreditAccountColumns } from "./CreditAccountColumns";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\customers\hooks\index.js"   & echo.. 
/**
 * Customers Hooks Barrel Export
 */

export * from "./useCustomers";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\customers\hooks\useCustomers.js"   & echo.. 
/**
 * Customer Hooks
 * React Query hooks for customer data management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { customerService } from "@/services";
import { toast } from "sonner";

// Query keys factory
export const customerKeys = {
  all: ["customers"],
  lists: () => [...customerKeys.all, "list"],
  list: (filters) => [...customerKeys.lists(), filters],
  details: () => [...customerKeys.all, "detail"],
  detail: (id) => [...customerKeys.details(), id],
  search: (query) => [...customerKeys.all, "search", query],
};

/**
 * Hook to fetch customers list
 */
export const useCustomers = (params = {}, options = {}) => {
  return useQuery({
    queryKey: customerKeys.list(params),
    queryFn: () => customerService.getAll(params),
    ...options,
  });
};

/**
 * Hook to fetch a single customer
 */
export const useCustomer = (id, options = {}) => {
  return useQuery({
    queryKey: customerKeys.detail(id),
    queryFn: () => customerService.getById(id),
    enabled: Boolean(id),
    ...options,
  });
};

/**
 * Hook to search customers
 */
export const useCustomerSearch = (query, options = {}) => {
  return useQuery({
    queryKey: customerKeys.search(query),
    queryFn: () => customerService.search(query),
    enabled: Boolean(query) && query.length >= 2,
    ...options,
  });
};

/**
 * Hook to create customer
 */
export const useCreateCustomer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => customerService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.all });
      toast.success("Customer created successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to create customer");
    },
  });
};

/**
 * Hook to update customer
 */
export const useUpdateCustomer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => customerService.update(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: customerKeys.all });
      queryClient.invalidateQueries({ queryKey: customerKeys.detail(id) });
      toast.success("Customer updated successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to update customer");
    },
  });
};

/**
 * Hook to delete customer
 */
export const useDeleteCustomer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => customerService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.all });
      toast.success("Customer deleted successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to delete customer");
    },
  });
};

/**
 * Hook to activate customer
 */
export const useActivateCustomer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => customerService.activate(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.all });
      toast.success("Customer activated");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to activate customer"
      );
    },
  });
};

/**
 * Hook to deactivate customer
 */
export const useDeactivateCustomer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => customerService.deactivate(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: customerKeys.all });
      toast.success("Customer deactivated");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to deactivate customer"
      );
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\dashboard\index.js"   & echo.. 
/**
 * Dashboard Feature Barrel Export
 */

// Components - Widgets
export { default as SalesOverviewWidget } from "./components/SalesOverviewWidget";
export { default as InventoryAlertsWidget } from "./components/InventoryAlertsWidget";
export { default as RecentSalesWidget } from "./components/RecentSalesWidget";
export { default as QuickActionsWidget } from "./components/QuickActionsWidget";

// Components - Dashboard Router
export { default as DashboardRouter } from "./components/DashboardRouter";

// Components - Role-specific Dashboards
export {
  AdminDashboard,
  CashierDashboard,
  PharmacistDashboard,
  AccountantDashboard,
  InventoryManagerDashboard,
} from "./components/dashboards";

// Hooks
export {
  useDashboardStats,
  useRecentSales,
  useLowStockAlerts,
  useExpiringProducts,
  useSalesChart,
} from "./hooks/useDashboard";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\dashboard\components\dashboards\index.js"   & echo.. 
/**
 * Dashboard Components Index
 * Exports all role-specific dashboards
 */

export { default as AdminDashboard } from "./AdminDashboard";
export { default as CashierDashboard } from "./CashierDashboard";
export { default as PharmacistDashboard } from "./PharmacistDashboard";
export { default as AccountantDashboard } from "./AccountantDashboard";
export { default as InventoryManagerDashboard } from "./InventoryManagerDashboard";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\dashboard\hooks\useDashboard.js"   & echo.. 
/**
 * useDashboard Hook
 * Fetches dashboard data based on user role
 */

import { useApiQuery } from "@/hooks";
import { usePermissions } from "@/hooks";
import { useBranchStore } from "@/store";
import { API_ENDPOINTS } from "@/config";

/**
 * Dashboard stats query hook
 */
export const useDashboardStats = () => {
  const { selectedBranch } = useBranchStore();

  return useApiQuery(
    ["dashboard-stats", selectedBranch?.id],
    API_ENDPOINTS.DASHBOARD.STATS,
    {
      params: {
        branchId: selectedBranch?.id,
      },
      enabled: !!selectedBranch?.id,
      staleTime: 60 * 1000, // 1 minute
    }
  );
};

/**
 * Recent sales query hook
 */
export const useRecentSales = (limit = 10) => {
  const { selectedBranch } = useBranchStore();

  return useApiQuery(
    ["recent-sales", selectedBranch?.id, limit],
    selectedBranch?.id
      ? API_ENDPOINTS.SALES.BY_BRANCH(selectedBranch.id)
      : null,
    {
      params: {
        size: limit,
        sort: "createdAt,desc",
      },
      enabled: !!selectedBranch?.id,
    }
  );
};

/**
 * Low stock alerts query hook
 */
export const useLowStockAlerts = (limit = 10) => {
  const { selectedBranch } = useBranchStore();

  return useApiQuery(
    ["low-stock", selectedBranch?.id, limit],
    selectedBranch?.id
      ? API_ENDPOINTS.INVENTORY.LOW_STOCK(selectedBranch.id)
      : null,
    {
      params: {
        size: limit,
      },
      enabled: !!selectedBranch?.id,
    }
  );
};

/**
 * Expiring products query hook
 */
export const useExpiringProducts = (days = 30, limit = 10) => {
  const { selectedBranch } = useBranchStore();

  // Calculate alert date (today + days)
  const alertDate = new Date();
  alertDate.setDate(alertDate.getDate() + days);
  const alertDateStr = alertDate.toISOString().split("T")[0];

  return useApiQuery(
    ["expiring-products", selectedBranch?.id, days, limit],
    selectedBranch?.id
      ? API_ENDPOINTS.INVENTORY.EXPIRING(selectedBranch.id)
      : null,
    {
      params: {
        alertDate: alertDateStr,
      },
      enabled: !!selectedBranch?.id,
    }
  );
};

/**
 * Sales chart data hook
 */
export const useSalesChart = (period = "week") => {
  const { selectedBranch } = useBranchStore();

  return useApiQuery(
    ["sales-chart", selectedBranch?.id, period],
    `${API_ENDPOINTS.DASHBOARD.STATS}/sales-chart`,
    {
      params: {
        branchId: selectedBranch?.id,
        period,
      },
      enabled: !!selectedBranch?.id,
    }
  );
};

export default useDashboardStats;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\grn\index.js"   & echo.. 
/**
 * GRN Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\grn\components\index.js"   & echo.. 
/**
 * GRN Components Barrel Export
 */

export { default as getGRNColumns } from "./GRNColumns";
export { default as GRNForm } from "./GRNForm";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\grn\hooks\index.js"   & echo.. 
/**
 * GRN Hooks Barrel Export
 */

export * from "./useGRN";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\grn\hooks\useGRN.js"   & echo.. 
/**
 * GRN Hooks
 * React Query hooks for Goods Received Note management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { grnService, rgrnService } from "@/services";
import { toast } from "sonner";

// Query keys factory
export const grnKeys = {
  all: ["grns"],
  lists: () => [...grnKeys.all, "list"],
  list: (filters) => [...grnKeys.lists(), filters],
  details: () => [...grnKeys.all, "detail"],
  detail: (id) => [...grnKeys.details(), id],
  byPo: (poId) => [...grnKeys.all, "by-po", poId],
};

export const rgrnKeys = {
  all: ["rgrns"],
  lists: () => [...rgrnKeys.all, "list"],
  list: (filters) => [...rgrnKeys.lists(), filters],
  details: () => [...rgrnKeys.all, "detail"],
  detail: (id) => [...rgrnKeys.details(), id],
};

/**
 * Hook to fetch GRN list
 */
export const useGRNs = (params = {}, options = {}) => {
  return useQuery({
    queryKey: grnKeys.list(params),
    queryFn: () => grnService.getAll(params),
    select: (response) => response.data?.data || response.data || response,
    ...options,
  });
};

/**
 * Hook to fetch a single GRN
 */
export const useGRN = (id, options = {}) => {
  return useQuery({
    queryKey: grnKeys.detail(id),
    queryFn: () => grnService.getById(id),
    select: (response) => response.data?.data || response.data || response,
    enabled: Boolean(id),
    staleTime: 30 * 60 * 1000, // 30 minutes - prevent unnecessary refetches
    refetchOnMount: false, // Don't refetch on mount if data is already in cache
    ...options,
  });
};

/**
 * Hook to fetch GRNs by Purchase Order
 */
export const useGRNsByPO = (poId, options = {}) => {
  return useQuery({
    queryKey: grnKeys.byPo(poId),
    queryFn: () => grnService.getByPurchaseOrder(poId),
    select: (response) => response.data?.data?.content || response.data?.content || [],
    enabled: Boolean(poId),
    ...options,
  });
};

/**
 * Hook to create GRN
 */
export const useCreateGRN = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data) => {
      // Create GRN (will be DRAFT status in backend)
      const createResponse = await grnService.create(data);
      
      // Note: SUPER_ADMIN created GRNs remain in DRAFT status like all others
      // They can directly verify and complete without additional approval
      
      return createResponse;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: grnKeys.lists() });
      // Automatically refresh ALL inventory data after GRN creation (using partial matching)
      queryClient.invalidateQueries({ 
        queryKey: ["inventory"],
        exact: false,
        refetchType: 'active'
      });
      // Refresh purchase orders as GRN affects PO status (partially/fully received)
      queryClient.invalidateQueries({ queryKey: ["purchaseOrders"] });
      
      toast.success("GRN created successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to create GRN");
    },
  });
};

/**
 * Hook to update GRN
 */
export const useUpdateGRN = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => grnService.update(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: grnKeys.lists() });
      // Automatically refresh inventory data after GRN update
      queryClient.invalidateQueries({ 
        queryKey: ["inventory"],
        exact: false,
        refetchType: 'active'
      });
      toast.success("GRN updated successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to update GRN");
    },
  });
};

/**
 * Hook to delete GRN
 */
export const useDeleteGRN = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => grnService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: grnKeys.lists() });
      toast.success("GRN deleted successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to delete GRN");
    },
  });
};

/**
 * Hook to verify GRN
 */
export const useVerifyGRN = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => grnService.verify(id),
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: grnKeys.lists() });
      // Automatically refresh inventory data after GRN verification
      queryClient.invalidateQueries({ 
        queryKey: ["inventory"],
        exact: false,
        refetchType: 'active'
      });
      toast.success("GRN verified successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to verify GRN");
    },
  });
};

/**
 * Hook to complete GRN
 */
export const useCompleteGRN = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => grnService.complete(id),
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: grnKeys.lists() });
      // Automatically refresh inventory data after GRN completion
      queryClient.invalidateQueries({ 
        queryKey: ["inventory"],
        exact: false,
        refetchType: 'active'
      });
      // Refresh purchase orders as completing GRN affects PO status
      queryClient.invalidateQueries({ queryKey: ["purchaseOrders"] });
      toast.success("GRN completed - stock updated");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to complete GRN");
    },
  });
};

// ===== RGRN Hooks =====

/**
 * Hook to fetch RGRN list
 */
export const useRGRNs = (params = {}, options = {}) => {
  return useQuery({
    queryKey: rgrnKeys.list(params),
    queryFn: () => rgrnService.getAll(params),
    ...options,
  });
};

/**
 * Hook to fetch a single RGRN
 */
export const useRGRN = (id, options = {}) => {
  return useQuery({
    queryKey: rgrnKeys.detail(id),
    queryFn: () => rgrnService.getById(id),
    enabled: Boolean(id),
    staleTime: 30 * 60 * 1000, // 30 minutes - prevent unnecessary refetches
    refetchOnMount: false, // Don't refetch on mount if data is already in cache
    ...options,
  });
};

/**
 * Hook to create RGRN (Return Goods Received Note)
 */
export const useCreateRGRN = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => rgrnService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: rgrnKeys.lists() });
      queryClient.invalidateQueries({ queryKey: grnKeys.lists() });
      toast.success("Return GRN created successfully");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to create return GRN"
      );
    },
  });
};

/**
 * Hook to approve RGRN
 */
export const useApproveRGRN = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => rgrnService.approve(id),
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: rgrnKeys.lists() });
      // Automatically refresh inventory data after RGRN approval (returns reduce stock)
      queryClient.invalidateQueries({ queryKey: ["inventory"] });
      toast.success("Return GRN approved");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to approve return GRN"
      );
    },
  });
};

/**
 * Hook to reject RGRN
 */
export const useRejectRGRN = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, reason }) => rgrnService.reject(id, reason),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: rgrnKeys.lists() });
      toast.success("Return GRN rejected");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to reject return GRN"
      );
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\inventory\index.js"   & echo.. 
/**
 * Inventory Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\inventory\components\index.js"   & echo.. 
/**
 * Inventory Components Barrel Export
 */

export { default as getStockTransferColumns } from "./StockTransferColumns";
export { default as getLowStockColumns } from "./LowStockColumns";
export { default as getExpiringColumns } from "./ExpiringColumns";
export { default as StockTransferForm } from "./StockTransferForm";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\inventory\hooks\index.js"   & echo.. 
/**
 * Inventory Hooks Barrel Export
 */

export * from "./useInventory";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\inventory\hooks\useInventory.js"   & echo.. 
/**
 * Inventory Hooks
 * React Query hooks for inventory data management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { inventoryService, stockTransferService } from "@/services";
import { toast } from "sonner";

// Query keys factory
export const inventoryKeys = {
  all: ["inventory"],
  stock: () => [...inventoryKeys.all, "stock"],
  stockByBranch: (branchId) => [...inventoryKeys.stock(), branchId],
  lowStock: () => [...inventoryKeys.all, "low-stock"],
  expiring: () => [...inventoryKeys.all, "expiring"],
  expired: () => [...inventoryKeys.all, "expired"],
};

export const stockTransferKeys = {
  all: ["stock-transfers"],
  lists: () => [...stockTransferKeys.all, "list"],
  list: (filters) => [...stockTransferKeys.lists(), filters],
  details: () => [...stockTransferKeys.all, "detail"],
  detail: (id) => [...stockTransferKeys.details(), id],
  pending: () => [...stockTransferKeys.all, "pending"],
};

/**
 * Hook to fetch stock levels by branch
 */
export const useStockByBranch = (branchId, options = {}) => {
  return useQuery({
    queryKey: inventoryKeys.stockByBranch(branchId),
    queryFn: () => inventoryService.getStockByBranch(branchId),
    enabled: Boolean(branchId),
    ...options,
  });
};

/**
 * Hook to fetch inventory by branch (paginated)
 */
export const useInventory = (branchId, params = {}, options = {}) => {
  return useQuery({
    queryKey: [...inventoryKeys.stockByBranch(branchId), params],
    queryFn: () => inventoryService.getByBranch(branchId, params),
    enabled: Boolean(branchId),
    ...options,
  });
};

/**
 * Hook to fetch low stock products
 */
export const useLowStockProducts = (params = {}, options = {}) => {
  return useQuery({
    queryKey: [...inventoryKeys.lowStock(), params],
    queryFn: () => inventoryService.getLowStockProducts(params),
    ...options,
  });
};

/**
 * Hook to fetch expiring products
 */
export const useExpiringProducts = (params = {}, options = {}) => {
  return useQuery({
    queryKey: [...inventoryKeys.expiring(), params],
    queryFn: () => inventoryService.getExpiringProducts(params),
    ...options,
  });
};

/**
 * Hook to fetch expired products
 */
export const useExpiredProducts = (params = {}, options = {}) => {
  return useQuery({
    queryKey: [...inventoryKeys.expired(), params],
    queryFn: () => inventoryService.getExpiredProducts(params),
    ...options,
  });
};

/**
 * Hook to fetch stock transfers list
 */
export const useStockTransfers = (params = {}, options = {}) => {
  return useQuery({
    queryKey: stockTransferKeys.list(params),
    queryFn: () => stockTransferService.getAll(params),
    ...options,
  });
};

/**
 * Hook to fetch a single stock transfer
 */
export const useStockTransfer = (id, options = {}) => {
  return useQuery({
    queryKey: stockTransferKeys.detail(id),
    queryFn: () => stockTransferService.getById(id),
    enabled: Boolean(id),
    ...options,
  });
};

/**
 * Hook to fetch pending stock transfers
 */
export const usePendingStockTransfers = (options = {}) => {
  return useQuery({
    queryKey: stockTransferKeys.pending(),
    queryFn: () => stockTransferService.getPending(),
    ...options,
  });
};

/**
 * Hook to create stock transfer
 */
export const useCreateStockTransfer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => stockTransferService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: stockTransferKeys.all });
      toast.success("Stock transfer created successfully");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to create stock transfer"
      );
    },
  });
};

/**
 * Hook to approve stock transfer
 */
export const useApproveStockTransfer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => stockTransferService.approve(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: stockTransferKeys.all });
      queryClient.invalidateQueries({ queryKey: inventoryKeys.all });
      toast.success("Stock transfer approved successfully");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to approve stock transfer"
      );
    },
  });
};

/**
 * Hook to reject stock transfer
 */
export const useRejectStockTransfer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, reason }) => stockTransferService.reject(id, reason),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: stockTransferKeys.all });
      toast.success("Stock transfer rejected");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to reject stock transfer"
      );
    },
  });
};

/**
 * Hook to dispatch stock transfer
 */
export const useDispatchStockTransfer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => stockTransferService.dispatch(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: stockTransferKeys.all });
      toast.success("Stock transfer dispatched");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to dispatch stock transfer"
      );
    },
  });
};

/**
 * Hook to receive stock transfer
 */
export const useReceiveStockTransfer = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => stockTransferService.receive(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: stockTransferKeys.all });
      queryClient.invalidateQueries({ queryKey: inventoryKeys.all });
      toast.success("Stock transfer received successfully");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to receive stock transfer"
      );
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\products\index.js"   & echo.. 
/**
 * Products Feature Barrel Export
 */

// Hooks
export * from "./hooks";

// Components
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\products\components\index.js"   & echo.. 
/**
 * Products Components Barrel Export
 */

export { default as ProductForm } from "./ProductForm";
export { default as ProductFilters } from "./ProductFilters";
export { getProductColumns } from "./ProductColumns";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\products\hooks\index.js"   & echo.. 
/**
 * Products Hooks Barrel Export
 */

export * from "./useProducts";
export * from "./useCategories";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\products\hooks\useCategories.js"   & echo.. 
/**
 * Categories Feature - Hooks
 * React Query hooks for category management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import { categoryService } from "@/services";

// Query keys
export const categoryKeys = {
  all: ["categories"],
  lists: () => [...categoryKeys.all, "list"],
  active: () => [...categoryKeys.all, "active"],
  details: () => [...categoryKeys.all, "detail"],
  detail: (id) => [...categoryKeys.details(), id],
};

/**
 * Hook to fetch all categories
 */
export const useCategories = () => {
  return useQuery({
    queryKey: categoryKeys.lists(),
    queryFn: () => categoryService.getAll(),
    select: (response) => {
      // Axios response: { data: { success, message, data: [...], timestamp } }
      const apiResponse = response.data;

      // Extract the actual data from ApiResponse wrapper
      const categories = apiResponse?.data;

      // Ensure we have an array and filter out soft-deleted categories
      const categoryList = Array.isArray(categories)
        ? categories.filter((cat) => !cat.deleted)
        : [];

      // Return in paginated format for DataTable compatibility
      return {
        content: categoryList,
        totalElements: categoryList.length,
        totalPages: 1,
      };
    },
  });
};

/**
 * Hook to fetch active categories
 */
export const useActiveCategories = () => {
  return useQuery({
    queryKey: categoryKeys.active(),
    queryFn: () => categoryService.getActive(),
    select: (response) => {
      // Axios response: { data: { success, message, data: [...], timestamp } }
      const apiResponse = response.data;
      const categories = apiResponse?.data;

      // Return array of categories
      return Array.isArray(categories) ? categories : [];
    },
  });
};

/**
 * Hook to fetch single category by ID
 */
export const useCategory = (id) => {
  return useQuery({
    queryKey: categoryKeys.detail(id),
    queryFn: () => categoryService.getById(id),
    select: (response) => response.data.data, // ApiResponse.data contains CategoryResponse
    enabled: !!id,
  });
};

/**
 * Hook to create category
 */
export const useCreateCategory = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => categoryService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: categoryKeys.all });
      toast.success("Category created successfully");
    },
    onError: (error) => {
      console.error("Create category error:", error);
      const message =
        error.response?.data?.message ||
        error.response?.data?.error ||
        error.message ||
        "Failed to create category";
      toast.error(message);
    },
  });
};

/**
 * Hook to update category
 */
export const useUpdateCategory = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => categoryService.update(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: categoryKeys.all });
      toast.success("Category updated successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to update category");
    },
  });
};

/**
 * Hook to delete category
 */
export const useDeleteCategory = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => categoryService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: categoryKeys.all });
      toast.success("Category deleted successfully");
    },
    onError: (error) => {
      console.error("Delete category error:", error);

      // Handle network errors
      if (
        error.code === "ERR_NETWORK" ||
        error.message.includes("Network Error")
      ) {
        toast.error(
          "Network error. Please check your connection and try again."
        );
        return;
      }

      // Handle connection errors
      if (error.code === "ERR_CONNECTION_CLOSED" || !error.response) {
        toast.error(
          "Connection lost. Please ensure the backend server is running."
        );
        return;
      }

      // Handle server errors
      const message =
        error.response?.data?.message ||
        error.response?.data?.error ||
        error.message ||
        "Failed to delete category";
      toast.error(message);
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\products\hooks\useProducts.js"   & echo.. 
/**
 * Products Feature - Hooks
 * React Query hooks for product management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { toast } from "sonner";
import { productService } from "@/services";

// Query keys
export const productKeys = {
  all: ["products"],
  lists: () => [...productKeys.all, "list"],
  list: (filters) => [...productKeys.lists(), filters],
  details: () => [...productKeys.all, "detail"],
  detail: (id) => [...productKeys.details(), id],
  search: (query) => [...productKeys.all, "search", query],
  lowStock: (branchId) => [...productKeys.all, "low-stock", branchId],
};

/**
 * Hook to fetch products list with pagination
 */
export const useProducts = (params = {}) => {
  return useQuery({
    queryKey: productKeys.list(params),
    queryFn: () => productService.getAll(params),
    select: (response) => response.data.data, // ApiResponse.data contains PageResponse
  });
};

/**
 * Hook to fetch single product by ID
 */
export const useProduct = (id) => {
  return useQuery({
    queryKey: productKeys.detail(id),
    queryFn: () => productService.getById(id),
    select: (response) => response.data.data, // ApiResponse.data contains ProductResponse
    enabled: !!id,
  });
};

/**
 * Hook to search products
 */
export const useProductSearch = (query, params = {}) => {
  return useQuery({
    queryKey: productKeys.search(query),
    queryFn: () => productService.search(query, params),
    select: (response) => response.data.data, // ApiResponse.data contains List<ProductResponse>
    enabled: !!query && query.length >= 2,
  });
};

/**
 * Hook to get low stock products
 */
export const useLowStockProducts = (branchId, params = {}) => {
  return useQuery({
    queryKey: productKeys.lowStock(branchId),
    queryFn: () => productService.getLowStock(branchId, params),
    select: (response) => response.data.data, // ApiResponse.data contains List<ProductResponse>
    enabled: !!branchId,
  });
};

/**
 * Hook to create product
 */
export const useCreateProduct = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => productService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: productKeys.lists() });
      toast.success("Product created successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to create product");
    },
  });
};

/**
 * Hook to update product
 */
export const useUpdateProduct = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => productService.update(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: productKeys.lists() });
      queryClient.invalidateQueries({
        queryKey: productKeys.detail(variables.id),
      });
      toast.success("Product updated successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to update product");
    },
  });
};

/**
 * Hook to delete product
 */
export const useDeleteProduct = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => productService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: productKeys.lists() });
      toast.success("Product deleted successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to delete product");
    },
  });
};

/**
 * Hook to discontinue product
 */
export const useDiscontinueProduct = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => productService.discontinue(id),
    onSuccess: (_, id) => {
      queryClient.invalidateQueries({ queryKey: productKeys.lists() });
      queryClient.invalidateQueries({ queryKey: productKeys.detail(id) });
      toast.success("Product discontinued successfully");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to discontinue product"
      );
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\purchase-orders\index.js"   & echo.. 
/**
 * Purchase Orders Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\purchase-orders\components\index.js"   & echo.. 
/**
 * Purchase Orders Components Barrel Export
 */

export { default as getPurchaseOrderColumns } from "./PurchaseOrderColumns";
export { default as PurchaseOrderForm } from "./PurchaseOrderForm";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\purchase-orders\hooks\index.js"   & echo.. 
/**
 * Purchase Orders Hooks Barrel Export
 */

export * from "./usePurchaseOrders";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\purchase-orders\hooks\usePurchaseOrders.js"   & echo.. 
/**
 * Purchase Orders Hooks
 * React Query hooks for purchase order management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { purchaseOrderService } from "@/services";
import { toast } from "sonner";

// Query keys factory
export const purchaseOrderKeys = {
  all: ["purchaseOrders"],
  lists: () => [...purchaseOrderKeys.all, "list"],
  list: (filters) => [...purchaseOrderKeys.lists(), filters],
  details: () => [...purchaseOrderKeys.all, "detail"],
  detail: (id) => [...purchaseOrderKeys.details(), id],
  pending: () => [...purchaseOrderKeys.all, "pending"],
};

/**
 * Hook to fetch purchase orders list
 */
export const usePurchaseOrders = (params = {}, options = {}) => {
  return useQuery({
    queryKey: purchaseOrderKeys.list(params),
    queryFn: () => purchaseOrderService.getAll(params),
    select: (response) => response.data?.data || response.data || response,
    ...options,
  });
};

/**
 * Hook to fetch pending purchase orders
 */
export const usePendingPurchaseOrders = (options = {}) => {
  return useQuery({
    queryKey: purchaseOrderKeys.pending(),
    queryFn: () => purchaseOrderService.getPending(),
    select: (response) => {
      // Extract data from nested response structure
      const data = response.data?.data || response.data || response;
      // If it's paginated, get the content array, otherwise return as-is
      const items = data?.content || data || [];
      console.log('usePendingPurchaseOrders - Raw response:', response);
      console.log('usePendingPurchaseOrders - Extracted data:', data);
      console.log('usePendingPurchaseOrders - Items:', items);
      return items;
    },
    ...options,
  });
};

/**
 * Hook to fetch a single purchase order
 */
export const usePurchaseOrder = (id, options = {}) => {
  return useQuery({
    queryKey: purchaseOrderKeys.detail(id),
    queryFn: () => purchaseOrderService.getById(id),
    select: (response) => response.data?.data || response.data || response,
    enabled: Boolean(id),
    ...options,
  });
};

/**
 * Hook to create purchase order
 */
export const useCreatePurchaseOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => purchaseOrderService.create(data),
    onSuccess: (response) => {
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.all });
      
      // Check if the order was auto-approved (SUPER_ADMIN creates orders as APPROVED)
      const orderStatus = response.data?.data?.status || response.data?.status;
      if (orderStatus === "APPROVED") {
        toast.success("Purchase order created and automatically approved");
      } else {
        toast.success("Purchase order created successfully");
      }
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to create purchase order"
      );
    },
  });
};

/**
 * Hook to update purchase order
 */
export const useUpdatePurchaseOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => purchaseOrderService.update(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.all });
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.detail(id) });
      toast.success("Purchase order updated successfully");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to update purchase order"
      );
    },
  });
};

/**
 * Hook to delete purchase order
 */
export const useDeletePurchaseOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => purchaseOrderService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.all });
      toast.success("Purchase order deleted successfully");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to delete purchase order"
      );
    },
  });
};

/**
 * Hook to submit purchase order for approval
 */
export const useSubmitPurchaseOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => purchaseOrderService.submit(id),
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.all });
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.detail(id) });
      toast.success("Purchase order submitted for approval");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to submit purchase order"
      );
    },
  });
};

/**
 * Hook to approve purchase order
 */
export const useApprovePurchaseOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => purchaseOrderService.approve(id),
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.all });
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.detail(id) });
      toast.success("Purchase order approved");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to approve purchase order"
      );
    },
  });
};

/**
 * Hook to reject purchase order
 */
export const useRejectPurchaseOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, reason }) => purchaseOrderService.reject(id, reason),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.all });
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.detail(id) });
      toast.success("Purchase order rejected");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to reject purchase order"
      );
    },
  });
};

/**
 * Hook to cancel purchase order
 */
export const useCancelPurchaseOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => purchaseOrderService.cancel(id),
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.all });
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.detail(id) });
      toast.success("Purchase order cancelled");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to cancel purchase order"
      );
    },
  });
};

/**
 * Hook to receive purchase order (create GRN)
 */
export const useReceivePurchaseOrder = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => purchaseOrderService.receive(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.all });
      queryClient.invalidateQueries({ queryKey: purchaseOrderKeys.detail(id) });
      toast.success("Purchase order received successfully");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to receive purchase order"
      );
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\reports\index.js"   & echo.. 
/**
 * Reports Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\reports\components\index.js"   & echo.. 
/**
 * Reports Components Barrel Export
 */

export { default as ReportFilters } from "./ReportFilters";
export { default as ReportSummaryCard } from "./ReportSummaryCard";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\reports\hooks\index.js"   & echo.. 
/**
 * Reports Hooks Barrel Export
 */

export * from "./useReports";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\reports\hooks\useReports.js"   & echo.. 
/**
 * Reports Hooks
 * React Query hooks for report generation
 */

import { useQuery } from "@tanstack/react-query";
import { reportService } from "@/services";

// Query keys factory
export const reportKeys = {
  all: ["reports"],
  sales: (params) => [...reportKeys.all, "sales", params],
  inventory: (params) => [...reportKeys.all, "inventory", params],
  financial: (params) => [...reportKeys.all, "financial", params],
  purchase: (params) => [...reportKeys.all, "purchase", params],
  expiry: (params) => [...reportKeys.all, "expiry", params],
  profitLoss: (params) => [...reportKeys.all, "profit-loss", params],
};

/**
 * Hook to fetch sales report
 */
export const useSalesReport = (params = {}, options = {}) => {
  return useQuery({
    queryKey: reportKeys.sales(params),
    queryFn: () => reportService.getSalesReport(params),
    enabled: Boolean(params.startDate && params.endDate),
    ...options,
  });
};

/**
 * Hook to fetch inventory report
 */
export const useInventoryReport = (params = {}, options = {}) => {
  return useQuery({
    queryKey: reportKeys.inventory(params),
    queryFn: () => reportService.getInventoryReport(params),
    ...options,
  });
};

/**
 * Hook to fetch financial report
 */
export const useFinancialReport = (params = {}, options = {}) => {
  return useQuery({
    queryKey: reportKeys.financial(params),
    queryFn: () => reportService.getFinancialReport(params),
    enabled: Boolean(params.startDate && params.endDate),
    ...options,
  });
};

/**
 * Hook to fetch purchase report
 */
export const usePurchaseReport = (params = {}, options = {}) => {
  return useQuery({
    queryKey: reportKeys.purchase(params),
    queryFn: () =>
      reportService.getPurchaseReport?.(params) || Promise.resolve(null),
    enabled: Boolean(params.startDate && params.endDate),
    ...options,
  });
};

/**
 * Hook to fetch expiry report
 */
export const useExpiryReport = (params = {}, options = {}) => {
  return useQuery({
    queryKey: reportKeys.expiry(params),
    queryFn: () =>
      reportService.getExpiryReport?.(params) || Promise.resolve(null),
    ...options,
  });
};

/**
 * Hook to fetch profit/loss report
 */
export const useProfitLossReport = (params = {}, options = {}) => {
  return useQuery({
    queryKey: reportKeys.profitLoss(params),
    queryFn: () =>
      reportService.getProfitLossReport?.(params) || Promise.resolve(null),
    enabled: Boolean(params.startDate && params.endDate),
    ...options,
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\sales\index.js"   & echo.. 
/**
 * Sales Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
export * from "./store";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\sales\components\index.js"   & echo.. 
/**
 * Sales Components Barrel Export
 */

export { default as POSProductSearch } from "./POSProductSearch";
export { default as POSCart } from "./POSCart";
export { default as POSTotals } from "./POSTotals";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\sales\hooks\index.js"   & echo.. 
/**
 * Sales Hooks Barrel Export
 */

export * from "./useSales";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\sales\hooks\useSales.js"   & echo.. 
/**
 * Sales Hooks
 * React Query hooks for sales/POS management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { saleService, saleReturnService, invoiceService } from "@/services";
import { toast } from "sonner";

// Query keys factory
export const saleKeys = {
  all: ["sales"],
  lists: () => [...saleKeys.all, "list"],
  list: (filters) => [...saleKeys.lists(), filters],
  details: () => [...saleKeys.all, "detail"],
  detail: (id) => [...saleKeys.details(), id],
  held: () => [...saleKeys.all, "held"],
};

export const saleReturnKeys = {
  all: ["saleReturns"],
  lists: () => [...saleReturnKeys.all, "list"],
  list: (filters) => [...saleReturnKeys.lists(), filters],
  details: () => [...saleReturnKeys.all, "detail"],
  detail: (id) => [...saleReturnKeys.details(), id],
};

/**
 * Hook to fetch sales list
 */
export const useSales = (params = {}, options = {}) => {
  return useQuery({
    queryKey: saleKeys.list(params),
    queryFn: () => saleService.getAll(params),
    ...options,
  });
};

/**
 * Hook to fetch held/pending sales
 */
export const useHeldSales = (options = {}) => {
  return useQuery({
    queryKey: saleKeys.held(),
    queryFn: () => saleService.getHeldSales?.() || Promise.resolve([]),
    ...options,
  });
};

/**
 * Hook to fetch a single sale
 */
export const useSale = (id, options = {}) => {
  return useQuery({
    queryKey: saleKeys.detail(id),
    queryFn: () => saleService.getById(id),
    enabled: Boolean(id),
    ...options,
  });
};

/**
 * Hook to create sale (checkout)
 */
export const useCreateSale = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => saleService.create(data),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: saleKeys.all });
      toast.success(`Sale completed! Invoice: ${data?.invoiceNumber || ""}`);
      return data;
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to complete sale");
    },
  });
};

/**
 * Hook to hold/save sale for later
 */
export const useHoldSale = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => saleService.holdSale?.(data) || Promise.resolve(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: saleKeys.held() });
      toast.success("Sale held for later");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to hold sale");
    },
  });
};

/**
 * Hook to void a sale
 */
export const useVoidSale = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, reason }) =>
      saleService.voidSale?.(id, reason) || Promise.resolve(),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: saleKeys.all });
      queryClient.invalidateQueries({ queryKey: saleKeys.detail(id) });
      toast.success("Sale voided");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to void sale");
    },
  });
};

// ===== Sale Returns Hooks =====

/**
 * Hook to fetch sale returns list
 */
export const useSaleReturns = (params = {}, options = {}) => {
  return useQuery({
    queryKey: saleReturnKeys.list(params),
    queryFn: () => saleReturnService.getAll(params),
    ...options,
  });
};

/**
 * Hook to fetch a single sale return
 */
export const useSaleReturn = (id, options = {}) => {
  return useQuery({
    queryKey: saleReturnKeys.detail(id),
    queryFn: () => saleReturnService.getById(id),
    enabled: Boolean(id),
    ...options,
  });
};

/**
 * Hook to create sale return
 */
export const useCreateSaleReturn = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => saleReturnService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: saleReturnKeys.all });
      queryClient.invalidateQueries({ queryKey: saleKeys.all });
      toast.success("Sale return processed successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to process return");
    },
  });
};

/**
 * Hook to approve sale return
 */
export const useApproveSaleReturn = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => saleReturnService.approve(id),
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: saleReturnKeys.all });
      queryClient.invalidateQueries({ queryKey: saleReturnKeys.detail(id) });
      toast.success("Return approved");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to approve return");
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\sales\store\index.js"   & echo.. 
/**
 * Sales Store Barrel Export
 */

export { default as usePOSStore } from "./usePOSStore";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\sales\store\usePOSStore.js"   & echo.. 
/**
 * POS Cart Store
 * Zustand store for managing POS cart state
 */

import { create } from "zustand";
import { persist } from "zustand/middleware";

const usePOSStore = create(
  persist(
    (set, get) => ({
      // Cart items
      items: [],

      // Selected customer
      customer: null,

      // Discount (percentage or fixed)
      discount: { type: "percentage", value: 0 },

      // Payment info
      payment: {
        method: "CASH",
        amountTendered: 0,
        cardNumber: "",
        reference: "",
      },

      // Held sales (for quick switch)
      heldSales: [],

      // Add item to cart
      addItem: (product, quantity = 1) => {
        const items = get().items;
        const existingIndex = items.findIndex(
          (item) =>
            item.productId === product.id && item.batchId === product.batchId
        );

        if (existingIndex >= 0) {
          // Update quantity if already in cart
          const updated = [...items];
          updated[existingIndex].quantity += quantity;
          set({ items: updated });
        } else {
          // Add new item with comprehensive product information
          set({
            items: [
              ...items,
              {
                productId: product.id,
                batchId: product.batchId,
                productName: product.name || product.productName,
                productCode: product.productCode || product.sku,
                sku: product.sku || product.productCode,
                barcode: product.barcode,
                genericName: product.genericName,
                manufacturer: product.manufacturer,
                strength: product.strength,
                dosageForm: product.dosageForm,
                drugSchedule: product.drugSchedule,
                batchNumber: product.batchNumber,
                expiryDate: product.expiryDate,
                unitPrice: product.sellingPrice || product.unitPrice || product.price,
                costPrice: product.costPrice,
                mrp: product.mrp,
                quantity,
                maxQuantity: product.stockQuantity || product.quantity || 999,
                discount: 0,
                taxRate: product.taxRate || product.gstRate || 0,
                isPrescriptionRequired: product.isPrescriptionRequired,
                isNarcotic: product.isNarcotic,
                isRefrigerated: product.isRefrigerated,
              },
            ],
          });
        }
      },

      // Update item quantity
      updateItemQuantity: (index, quantity) => {
        const items = get().items;
        if (quantity <= 0) {
          set({ items: items.filter((_, i) => i !== index) });
        } else {
          const updated = [...items];
          updated[index].quantity = Math.min(
            quantity,
            updated[index].maxQuantity
          );
          set({ items: updated });
        }
      },

      // Update item discount
      updateItemDiscount: (index, discount) => {
        const items = get().items;
        const updated = [...items];
        updated[index].discount = Math.min(Math.max(0, discount), 100);
        set({ items: updated });
      },

      // Remove item from cart
      removeItem: (index) => {
        set({ items: get().items.filter((_, i) => i !== index) });
      },

      // Clear cart
      clearCart: () => {
        set({
          items: [],
          customer: null,
          discount: { type: "percentage", value: 0 },
        });
      },

      // Set customer
      setCustomer: (customer) => set({ customer }),

      // Clear customer
      clearCustomer: () => set({ customer: null }),

      // Set cart discount
      setDiscount: (discount) => set({ discount }),

      // Set payment info
      setPayment: (payment) =>
        set({ payment: { ...get().payment, ...payment } }),

      // Hold current sale
      holdSale: (name) => {
        const { items, customer, discount } = get();
        if (items.length === 0) return;

        const heldSale = {
          id: Date.now(),
          name: name || `Sale ${get().heldSales.length + 1}`,
          items,
          customer,
          discount,
          timestamp: new Date().toISOString(),
        };

        set({
          heldSales: [...get().heldSales, heldSale],
          items: [],
          customer: null,
          discount: { type: "percentage", value: 0 },
        });
      },

      // Recall held sale
      recallSale: (id) => {
        const held = get().heldSales.find((s) => s.id === id);
        if (held) {
          // If current cart has items, hold them first
          if (get().items.length > 0) {
            get().holdSale("Auto-saved");
          }

          set({
            items: held.items,
            customer: held.customer,
            discount: held.discount,
            heldSales: get().heldSales.filter((s) => s.id !== id),
          });
        }
      },

      // Remove held sale
      removeHeldSale: (id) => {
        set({ heldSales: get().heldSales.filter((s) => s.id !== id) });
      },

      // Calculate subtotal
      getSubtotal: () => {
        return get().items.reduce(
          (sum, item) => sum + item.unitPrice * item.quantity,
          0
        );
      },

      // Calculate item discount total
      getItemDiscountTotal: () => {
        return get().items.reduce((sum, item) => {
          const itemTotal = item.unitPrice * item.quantity;
          return sum + (itemTotal * item.discount) / 100;
        }, 0);
      },

      // Calculate cart discount
      getCartDiscount: () => {
        const { discount } = get();
        const afterItemDiscount =
          get().getSubtotal() - get().getItemDiscountTotal();

        if (discount.type === "percentage") {
          return (afterItemDiscount * discount.value) / 100;
        }
        return Math.min(discount.value, afterItemDiscount);
      },

      // Calculate tax total
      getTaxTotal: () => {
        return get().items.reduce((sum, item) => {
          const itemTotal = item.unitPrice * item.quantity;
          const afterDiscount = itemTotal - (itemTotal * item.discount) / 100;
          return sum + (afterDiscount * item.taxRate) / 100;
        }, 0);
      },

      // Calculate grand total
      getGrandTotal: () => {
        return (
          get().getSubtotal() -
          get().getItemDiscountTotal() -
          get().getCartDiscount() +
          get().getTaxTotal()
        );
      },

      // Get change due
      getChangeDue: () => {
        return Math.max(
          0,
          get().payment.amountTendered - get().getGrandTotal()
        );
      },
    }),
    {
      name: "pos-cart",
      partialize: (state) => ({
        items: state.items,
        customer: state.customer,
        discount: state.discount,
        heldSales: state.heldSales,
      }),
    }
  )
);

export default usePOSStore;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\suppliers\index.js"   & echo.. 
/**
 * Suppliers Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\suppliers\components\index.js"   & echo.. 
/**
 * Suppliers Components Barrel Export
 */

export { default as SupplierForm } from "./SupplierForm";
export { default as getSupplierColumns } from "./SupplierColumns";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\suppliers\hooks\index.js"   & echo.. 
/**
 * Suppliers Hooks Barrel Export
 */

export * from "./useSuppliers";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\suppliers\hooks\useSuppliers.js"   & echo.. 
/**
 * Supplier Hooks
 * React Query hooks for supplier data management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supplierService } from "@/services";
import { toast } from "sonner";

// Query keys factory
export const supplierKeys = {
  all: ["suppliers"],
  lists: () => [...supplierKeys.all, "list"],
  list: (filters) => [...supplierKeys.lists(), filters],
  details: () => [...supplierKeys.all, "detail"],
  detail: (id) => [...supplierKeys.details(), id],
  search: (query) => [...supplierKeys.all, "search", query],
  active: () => [...supplierKeys.all, "active"],
};

/**
 * Hook to fetch suppliers list
 */
export const useSuppliers = (params = {}, options = {}) => {
  return useQuery({
    queryKey: supplierKeys.list(params),
    queryFn: () => supplierService.getAll(params),
    select: (response) => response.data?.data, // Extract data from ApiResponse
    ...options,
  });
};

/**
 * Hook to fetch active suppliers
 */
export const useActiveSuppliers = (options = {}) => {
  return useQuery({
    queryKey: supplierKeys.active(),
    queryFn: () => supplierService.getAll({ isActive: true, size: 1000 }),
    select: (response) => response.data?.data?.content || [], // Extract content array from PageResponse
    staleTime: 5 * 60 * 1000,
    ...options,
  });
};

/**
 * Hook to fetch a single supplier
 */
export const useSupplier = (id, options = {}) => {
  return useQuery({
    queryKey: supplierKeys.detail(id),
    queryFn: () => supplierService.getById(id),
    select: (response) => response.data?.data, // Extract data from ApiResponse
    enabled: Boolean(id),
    ...options,
  });
};

/**
 * Hook to search suppliers
 */
export const useSupplierSearch = (query, options = {}) => {
  return useQuery({
    queryKey: supplierKeys.search(query),
    queryFn: () => supplierService.search(query),
    select: (response) => response.data?.data, // Extract data from ApiResponse
    enabled: Boolean(query) && query.length >= 2,
    ...options,
  });
};

/**
 * Hook to create supplier
 */
export const useCreateSupplier = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => supplierService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: supplierKeys.all });
      toast.success("Supplier created successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to create supplier");
    },
  });
};

/**
 * Hook to update supplier
 */
export const useUpdateSupplier = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => supplierService.update(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: supplierKeys.all });
      queryClient.invalidateQueries({ queryKey: supplierKeys.detail(id) });
      toast.success("Supplier updated successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to update supplier");
    },
  });
};

/**
 * Hook to delete supplier
 */
export const useDeleteSupplier = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => supplierService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: supplierKeys.all });
      toast.success("Supplier deleted successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to delete supplier");
    },
  });
};

/**
 * Hook to activate supplier
 */
export const useActivateSupplier = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => supplierService.activate(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: supplierKeys.all });
      toast.success("Supplier activated");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to activate supplier"
      );
    },
  });
};

/**
 * Hook to deactivate supplier
 */
export const useDeactivateSupplier = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => supplierService.deactivate(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: supplierKeys.all });
      toast.success("Supplier deactivated");
    },
    onError: (error) => {
      toast.error(
        error.response?.data?.message || "Failed to deactivate supplier"
      );
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\users\index.js"   & echo.. 
/**
 * Users Feature Barrel Export
 */

export * from "./hooks";
export * from "./components";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\users\components\index.js"   & echo.. 
/**
 * Users Components Barrel Export
 */

export { default as UserForm } from "./UserForm";
export { default as getUserColumns } from "./UserColumns";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\users\hooks\index.js"   & echo.. 
/**
 * Users Hooks Barrel Export
 */

export * from "./useUsers";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\features\users\hooks\useUsers.js"   & echo.. 
/**
 * User Hooks
 * React Query hooks for user management
 */

import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { userService } from "@/services";
import { toast } from "sonner";

// Query keys factory
export const userKeys = {
  all: ["users"],
  lists: () => [...userKeys.all, "list"],
  list: (filters) => [...userKeys.lists(), filters],
  details: () => [...userKeys.all, "detail"],
  detail: (id) => [...userKeys.details(), id],
  byRole: (role) => [...userKeys.all, "role", role],
  byBranch: (branchId) => [...userKeys.all, "branch", branchId],
};

/**
 * Hook to fetch users list
 */
export const useUsers = (params = {}, options = {}) => {
  return useQuery({
    queryKey: userKeys.list(params),
    queryFn: () => userService.getAll(params),
    select: (response) => response.data.data, // ApiResponse.data contains PageResponse
    ...options,
  });
};

/**
 * Hook to fetch a single user
 */
export const useUser = (id, options = {}) => {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => userService.getById(id),
    select: (response) => response.data.data, // ApiResponse.data contains UserResponse
    enabled: Boolean(id),
    ...options,
  });
};

/**
 * Hook to fetch users by role
 */
export const useUsersByRole = (role, options = {}) => {
  return useQuery({
    queryKey: userKeys.byRole(role),
    queryFn: () => userService.getByRole(role),
    select: (response) => response.data.data, // ApiResponse.data contains List<UserResponse>
    enabled: Boolean(role),
    ...options,
  });
};

/**
 * Hook to fetch users by branch
 */
export const useUsersByBranch = (branchId, options = {}) => {
  return useQuery({
    queryKey: userKeys.byBranch(branchId),
    queryFn: () => userService.getByBranch(branchId),
    select: (response) => response.data.data, // ApiResponse.data contains List<UserResponse>
    enabled: Boolean(branchId),
    ...options,
  });
};

/**
 * Hook to create user
 */
export const useCreateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data) => userService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      toast.success("User created successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to create user");
    },
  });
};

/**
 * Hook to update user
 */
export const useUpdateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => userService.update(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      queryClient.invalidateQueries({ queryKey: userKeys.detail(id) });
      toast.success("User updated successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to update user");
    },
  });
};

/**
 * Hook to delete user
 */
export const useDeleteUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => userService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      toast.success("User deleted successfully");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to delete user");
    },
  });
};

/**
 * Hook to activate user
 */
export const useActivateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => userService.activate(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      toast.success("User activated");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to activate user");
    },
  });
};

/**
 * Hook to deactivate user
 */
export const useDeactivateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id) => userService.deactivate(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      toast.success("User deactivated");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to deactivate user");
    },
  });
};

/**
 * Hook to reset user password
 */
export const useResetPassword = () => {
  return useMutation({
    mutationFn: (id) => userService.resetPassword(id),
    onSuccess: () => {
      toast.success("Password reset email sent");
    },
    onError: (error) => {
      toast.error(error.response?.data?.message || "Failed to reset password");
    },
  });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\index.js"   & echo.. 
/**
 * Hooks Barrel Export
 * Central export point for all custom hooks
 */

// Auth
export { useAuth } from "./useAuth";

// API & Data
export {
  useApiQuery,
  useApiMutation,
  useCreate,
  useUpdate,
  useDelete,
  usePaginatedQuery,
  useInfiniteApiQuery,
  usePrefetch,
} from "./useApi";

// Permissions
export { usePermissions } from "./usePermissions";

// Branch
export { useBranch } from "./useBranch";

// Debounce & Throttle
export {
  useDebounce,
  useDebouncedCallback,
  useDebouncedSearch,
  useThrottle,
} from "./useDebounce";

// Pagination & Sorting
export { usePagination, useSorting, useTableState } from "./usePagination";

// WebSocket
export { useWebSocket, useSubscription, WS_STATE } from "./useWebSocket";

// Mobile Detection
export { useIsMobile } from "./use-mobile";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\use-mobile.js"   & echo.. 
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange);
  }, [])

  return !!isMobile
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\useApi.js"   & echo.. 
/**
 * API Hooks
 * React Query hooks for API operations
 */

import {
  useQuery,
  useMutation,
  useQueryClient,
  useInfiniteQuery,
} from "@tanstack/react-query";
import { api } from "@/utils";
import { toast } from "sonner";

/**
 * Default query options
 */
const defaultOptions = {
  staleTime: 5 * 60 * 1000, // 5 minutes
  gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)
  retry: 1,
  refetchOnWindowFocus: false,
};

/**
 * Generic GET hook
 * @param {string|Array} queryKey - Query key for caching
 * @param {string} url - API endpoint
 * @param {Object} options - Additional options
 * @returns {Object} Query result
 */
export const useApiQuery = (queryKey, url, options = {}) => {
  const { params, enabled = true, ...queryOptions } = options;

  return useQuery({
    queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
    queryFn: async () => {
      const response = await api.get(url, { params });
      return response.data;
    },
    enabled,
    ...defaultOptions,
    ...queryOptions,
  });
};

/**
 * Generic POST/PUT/DELETE mutation hook
 * @param {string} mutationKey - Mutation key
 * @param {Function} mutationFn - Mutation function
 * @param {Object} options - Additional options
 * @returns {Object} Mutation result
 */
export const useApiMutation = (mutationKey, mutationFn, options = {}) => {
  const queryClient = useQueryClient();
  const {
    invalidateQueries = [],
    successMessage,
    errorMessage,
    onSuccess,
    onError,
    ...mutationOptions
  } = options;

  return useMutation({
    mutationKey: [mutationKey],
    mutationFn,
    onSuccess: (data, variables, context) => {
      // Invalidate related queries
      invalidateQueries.forEach((key) => {
        queryClient.invalidateQueries({
          queryKey: Array.isArray(key) ? key : [key],
        });
      });

      // Show success toast
      if (successMessage) {
        toast.success(successMessage);
      }

      // Call custom onSuccess
      onSuccess?.(data, variables, context);
    },
    onError: (error, variables, context) => {
      // Show error toast
      const message =
        errorMessage ||
        error.response?.data?.message ||
        error.message ||
        "An error occurred";
      toast.error(message);

      // Call custom onError
      onError?.(error, variables, context);
    },
    ...mutationOptions,
  });
};

/**
 * Create mutation hook factory
 * @param {string} endpoint - API endpoint
 * @returns {Function} useMutation hook
 */
export const useCreate = (endpoint, options = {}) => {
  return useApiMutation(
    `create-${endpoint}`,
    (data) => api.post(endpoint, data),
    {
      successMessage: "Created successfully",
      ...options,
    }
  );
};

/**
 * Update mutation hook factory
 * @param {string} endpoint - API endpoint (with :id placeholder)
 * @returns {Function} useMutation hook
 */
export const useUpdate = (endpoint, options = {}) => {
  return useApiMutation(
    `update-${endpoint}`,
    ({ id, data }) => api.put(endpoint.replace(":id", id), data),
    {
      successMessage: "Updated successfully",
      ...options,
    }
  );
};

/**
 * Delete mutation hook factory
 * @param {string} endpoint - API endpoint (with :id placeholder)
 * @returns {Function} useMutation hook
 */
export const useDelete = (endpoint, options = {}) => {
  return useApiMutation(
    `delete-${endpoint}`,
    (id) => api.delete(endpoint.replace(":id", id)),
    {
      successMessage: "Deleted successfully",
      ...options,
    }
  );
};

/**
 * Paginated query hook
 * @param {string} queryKey - Query key
 * @param {string} url - API endpoint
 * @param {Object} options - Query options including pagination params
 * @returns {Object} Query result with pagination helpers
 */
export const usePaginatedQuery = (queryKey, url, options = {}) => {
  const { page = 0, size = 10, sort, filters = {}, ...queryOptions } = options;

  const params = {
    page,
    size,
    ...(sort && { sort }),
    ...filters,
  };

  const query = useApiQuery([queryKey, page, size, sort, filters], url, {
    params,
    keepPreviousData: true,
    ...queryOptions,
  });

  return {
    ...query,
    // Pagination helpers
    pagination: query.data
      ? {
          page: query.data.number ?? page,
          size: query.data.size ?? size,
          totalElements: query.data.totalElements ?? 0,
          totalPages: query.data.totalPages ?? 0,
          isFirst: query.data.first ?? page === 0,
          isLast: query.data.last ?? true,
          hasNext: !query.data.last,
          hasPrevious: !query.data.first,
        }
      : null,
    items: query.data?.content ?? [],
  };
};

/**
 * Infinite scroll query hook
 * @param {string} queryKey - Query key
 * @param {string} url - API endpoint
 * @param {Object} options - Query options
 * @returns {Object} Infinite query result
 */
export const useInfiniteApiQuery = (queryKey, url, options = {}) => {
  const { size = 20, ...queryOptions } = options;

  return useInfiniteQuery({
    queryKey: [queryKey],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await api.get(url, {
        params: { page: pageParam, size },
      });
      return response.data;
    },
    getNextPageParam: (lastPage) => {
      if (lastPage.last) return undefined;
      return lastPage.number + 1;
    },
    initialPageParam: 0,
    ...defaultOptions,
    ...queryOptions,
  });
};

/**
 * Prefetch query helper
 */
export const usePrefetch = () => {
  const queryClient = useQueryClient();

  return (queryKey, url, options = {}) => {
    queryClient.prefetchQuery({
      queryKey: Array.isArray(queryKey) ? queryKey : [queryKey],
      queryFn: async () => {
        const response = await api.get(url, { params: options.params });
        return response.data;
      },
      ...defaultOptions,
    });
  };
};

export default {
  useApiQuery,
  useApiMutation,
  useCreate,
  useUpdate,
  useDelete,
  usePaginatedQuery,
  useInfiniteApiQuery,
  usePrefetch,
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\useAuth.js"   & echo.. 
/**
 * Auth Hook
 * Provides authentication utilities and user state
 */

import { useCallback } from "react";
import { useNavigate } from "react-router-dom";
import { useAuthStore } from "@/store";
import { ROUTES } from "@/config";
import { ROLES } from "@/constants";

/**
 * Hook for authentication operations
 * @returns {Object} Auth utilities and state
 */
export const useAuth = () => {
  const navigate = useNavigate();

  const {
    user,
    isAuthenticated,
    isLoading,
    setAuth,
    clearAuth,
    hasRole,
    hasAnyRole,
    hasMinimumRole,
    isSuperAdmin,
  } = useAuthStore();

  /**
   * Login handler - sets auth state and redirects
   * @param {Object} authData - { user, accessToken, refreshToken }
   */
  const login = useCallback(
    (authData) => {
      setAuth(authData);

      // Redirect based on role
      const role = authData.user?.role;
      if (role === ROLES.SUPER_ADMIN) {
        navigate(ROUTES.DASHBOARD);
      } else if (role === ROLES.BRANCH_ADMIN) {
        navigate(ROUTES.DASHBOARD);
      } else if (role === ROLES.PHARMACIST || role === ROLES.CASHIER) {
        navigate(ROUTES.POS.ROOT);
      } else {
        navigate(ROUTES.DASHBOARD);
      }
    },
    [setAuth, navigate]
  );

  /**
   * Logout handler - clears auth and redirects to login
   */
  const logout = useCallback(() => {
    clearAuth();
    navigate(ROUTES.AUTH.LOGIN);
  }, [clearAuth, navigate]);

  /**
   * Check if user can access a specific feature
   * @param {string} feature - Feature name
   * @returns {boolean}
   */
  const canAccess = useCallback(
    (feature) => {
      if (!user?.role) return false;

      const roleFeatures = {
        [ROLES.SUPER_ADMIN]: ["*"],
        [ROLES.OWNER]: ["*"],
        [ROLES.BRANCH_ADMIN]: [
          "dashboard",
          "pos",
          "inventory",
          "products",
          "categories",
          "suppliers",
          "customers",
          "employees",
          "reports",
          "settings",
        ],
        [ROLES.PHARMACIST]: [
          "pos",
          "inventory",
          "products",
          "customers",
          "prescriptions",
        ],
        [ROLES.CASHIER]: ["pos", "customers"],
        [ROLES.INVENTORY_MANAGER]: [
          "inventory",
          "products",
          "suppliers",
          "purchase-orders",
          "grn",
        ],
        [ROLES.ACCOUNTANT]: ["finance", "reports", "payroll"],
      };

      const features = roleFeatures[user.role] || [];
      return features.includes("*") || features.includes(feature);
    },
    [user?.role]
  );

  /**
   * Get user's display name
   * @returns {string}
   */
  const displayName = user
    ? `${user.firstName || ""} ${user.lastName || ""}`.trim() || user.username
    : "";

  /**
   * Get user's initials for avatar
   * @returns {string}
   */
  const initials = user
    ? `${user.firstName?.[0] || ""}${user.lastName?.[0] || ""}`.toUpperCase() ||
      user.username?.[0]?.toUpperCase()
    : "";

  return {
    // State
    user,
    isAuthenticated,
    isLoading,
    displayName,
    initials,

    // Role info
    role: user?.role,
    branchId: user?.branchId,

    // Actions
    login,
    logout,

    // Role checks
    hasRole,
    hasAnyRole,
    hasMinimumRole,
    isSuperAdmin,
    canAccess,
  };
};

export default useAuth;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\useBranch.js"   & echo.. 
/**
 * Branch Hook
 * Provides branch selection and management utilities
 */

import { useCallback, useMemo, useEffect } from "react";
import { useBranchStore, useAuthStore } from "@/store";
import { useApiQuery } from "./useApi";
import { API_ENDPOINTS } from "@/config";
import { ROLES } from "@/constants";

/**
 * Hook for branch operations
 * @returns {Object} Branch utilities and state
 */
export const useBranch = () => {
  const { user } = useAuthStore();
  const {
    selectedBranch,
    branches,
    isLoading,
    setSelectedBranch,
    setBranches,
    setLoading,
    getSelectedBranchId,
  } = useBranchStore();

  /**
   * Fetch branches from API
   */
  const branchesQuery = useApiQuery("branches", API_ENDPOINTS.BRANCHES.ALL, {
    enabled: !!user,
  });

  /**
   * Process fetched branches and auto-select if needed
   */
  useEffect(() => {
    if (branchesQuery.data) {
      const branchList = branchesQuery.data?.data?.content || branchesQuery.data?.data || branchesQuery.data?.content || branchesQuery.data || [];
      
      if (Array.isArray(branchList) && branchList.length > 0) {
        setBranches(branchList);

        // Auto-select first active branch if none is selected
        if (!selectedBranch) {
          const firstActiveBranch = branchList.find((b) => (b.isActive !== false && b.active !== false)) || branchList[0];
          setSelectedBranch(firstActiveBranch);
        }
      }
    }
  }, [branchesQuery.data, selectedBranch, setBranches, setSelectedBranch]);

  /**
   * Check if user can switch branches
   */
  const canSwitchBranch = useMemo(() => {
    if (!user?.role) return false;
    // Allow super admin, admin, owner, and branch managers to switch branches
    // Also allow if there are multiple branches available
    const privilegedRoles = [ROLES.SUPER_ADMIN, ROLES.ADMIN, ROLES.OWNER, ROLES.BRANCH_MANAGER];
    return privilegedRoles.includes(user.role) || branches.length > 1;
  }, [user?.role, branches.length]);

  /**
   * Get branches available to the user
   */
  const availableBranches = useMemo(() => {
    if (!user) return [];

    // Super admin and admin can see all branches
    if ([ROLES.SUPER_ADMIN, ROLES.ADMIN, ROLES.OWNER].includes(user.role)) {
      return branches;
    }

    // For other users, show all active branches
    // (Branch-specific filtering should be done at the backend level)
    return branches.filter((b) => (b.isActive !== false && b.active !== false));
  }, [user, branches]);

  /**
   * Handle branch change
   * @param {Object} branch - Branch to select
   */
  const changeBranch = useCallback(
    (branch) => {
      if (!branch) {
        console.warn("Invalid branch provided");
        return;
      }
      setSelectedBranch(branch);
    },
    [setSelectedBranch]
  );

  /**
   * Get current branch ID (for API requests)
   */
  const currentBranchId = useMemo(() => {
    return getSelectedBranchId();
  }, [selectedBranch, getSelectedBranchId]);

  /**
   * Check if branch is active
   * @param {string|number} branchId - Branch ID to check
   * @returns {boolean}
   */
  const isBranchActive = useCallback(
    (branchId) => {
      const branch = branches.find((b) => b.id === branchId);
      return branch?.isActive ?? branch?.active ?? false;
    },
    [branches]
  );

  /**
   * Get branch by ID
   * @param {string|number} branchId - Branch ID
   * @returns {Object|null}
   */
  const getBranchById = useCallback(
    (branchId) => {
      return branches.find((b) => b.id === branchId) || null;
    },
    [branches]
  );

  /**
   * Format branch for display
   * @param {Object} branch - Branch object
   * @returns {string}
   */
  const formatBranchName = useCallback((branch) => {
    if (!branch) return "";
    return branch.branchName || branch.name || `Branch ${branch.id}`;
  }, []);

  return {
    // State
    selectedBranch,
    branches: availableBranches,
    allBranches: branches,
    isLoading: isLoading || branchesQuery.isLoading,
    currentBranchId,

    // Actions
    changeBranch,
    refetch: branchesQuery.refetch,

    // Checks
    canSwitchBranch,
    isBranchActive,

    // Helpers
    getBranchById,
    formatBranchName,
  };
};

export default useBranch;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\useDebounce.js"   & echo.. 
/**
 * Debounce Hooks
 * Provides debouncing utilities for inputs and callbacks
 */

import { useState, useEffect, useCallback, useRef } from "react";

/**
 * Hook that debounces a value
 * @param {any} value - Value to debounce
 * @param {number} delay - Delay in milliseconds (default: 300ms)
 * @returns {any} Debounced value
 */
export const useDebounce = (value, delay = 300) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
};

/**
 * Hook that returns a debounced callback function
 * @param {Function} callback - Callback to debounce
 * @param {number} delay - Delay in milliseconds (default: 300ms)
 * @param {Array} dependencies - Dependencies for the callback
 * @returns {Function} Debounced callback
 */
export const useDebouncedCallback = (
  callback,
  delay = 300,
  dependencies = []
) => {
  const timeoutRef = useRef(null);

  const debouncedCallback = useCallback(
    (...args) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      timeoutRef.current = setTimeout(() => {
        callback(...args);
      }, delay);
    },
    [callback, delay, ...dependencies]
  );

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return debouncedCallback;
};

/**
 * Hook for debounced search input
 * @param {string} initialValue - Initial search value
 * @param {number} delay - Debounce delay (default: 300ms)
 * @returns {Object} Search state and handlers
 */
export const useDebouncedSearch = (initialValue = "", delay = 300) => {
  const [searchTerm, setSearchTerm] = useState(initialValue);
  const debouncedSearchTerm = useDebounce(searchTerm, delay);

  const handleSearch = useCallback((value) => {
    setSearchTerm(value);
  }, []);

  const clearSearch = useCallback(() => {
    setSearchTerm("");
  }, []);

  return {
    searchTerm,
    debouncedSearchTerm,
    setSearchTerm: handleSearch,
    clearSearch,
    isSearching: searchTerm !== debouncedSearchTerm,
  };
};

/**
 * Hook that throttles a value (fires at most once per interval)
 * @param {any} value - Value to throttle
 * @param {number} interval - Throttle interval in milliseconds
 * @returns {any} Throttled value
 */
export const useThrottle = (value, interval = 300) => {
  const [throttledValue, setThrottledValue] = useState(value);
  const lastExecuted = useRef(Date.now());

  useEffect(() => {
    const now = Date.now();
    const elapsed = now - lastExecuted.current;

    if (elapsed >= interval) {
      lastExecuted.current = now;
      setThrottledValue(value);
    } else {
      const timer = setTimeout(() => {
        lastExecuted.current = Date.now();
        setThrottledValue(value);
      }, interval - elapsed);

      return () => clearTimeout(timer);
    }
  }, [value, interval]);

  return throttledValue;
};

export default useDebounce;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\usePagination.js"   & echo.. 
/**
 * Pagination Hook
 * Provides pagination state and utilities
 */

import { useState, useCallback, useMemo } from "react";
import { APP_CONFIG } from "@/config";

/**
 * Hook for managing pagination state
 * @param {Object} options - Pagination options
 * @returns {Object} Pagination state and handlers
 */
export const usePagination = (options = {}) => {
  const {
    initialPage = 0,
    initialSize = APP_CONFIG.PAGINATION.DEFAULT_PAGE_SIZE,
    totalElements = 0,
    totalPages = 0,
  } = options;

  const [page, setPage] = useState(initialPage);
  const [size, setSize] = useState(initialSize);

  /**
   * Go to next page
   */
  const nextPage = useCallback(() => {
    setPage((prev) => Math.min(prev + 1, Math.max(0, totalPages - 1)));
  }, [totalPages]);

  /**
   * Go to previous page
   */
  const previousPage = useCallback(() => {
    setPage((prev) => Math.max(0, prev - 1));
  }, []);

  /**
   * Go to specific page
   * @param {number} pageNumber - Page number (0-indexed)
   */
  const goToPage = useCallback(
    (pageNumber) => {
      const validPage = Math.max(
        0,
        Math.min(pageNumber, Math.max(0, totalPages - 1))
      );
      setPage(validPage);
    },
    [totalPages]
  );

  /**
   * Go to first page
   */
  const firstPage = useCallback(() => {
    setPage(0);
  }, []);

  /**
   * Go to last page
   */
  const lastPage = useCallback(() => {
    setPage(Math.max(0, totalPages - 1));
  }, [totalPages]);

  /**
   * Change page size
   * @param {number} newSize - New page size
   */
  const changeSize = useCallback((newSize) => {
    setSize(newSize);
    setPage(0); // Reset to first page when size changes
  }, []);

  /**
   * Reset pagination to initial state
   */
  const reset = useCallback(() => {
    setPage(initialPage);
    setSize(initialSize);
  }, [initialPage, initialSize]);

  /**
   * Pagination state for API requests
   */
  const paginationParams = useMemo(
    () => ({
      page,
      size,
    }),
    [page, size]
  );

  /**
   * Display information
   */
  const displayInfo = useMemo(() => {
    const start = page * size + 1;
    const end = Math.min((page + 1) * size, totalElements);

    return {
      start: totalElements > 0 ? start : 0,
      end,
      total: totalElements,
      text:
        totalElements > 0
          ? `Showing ${start} to ${end} of ${totalElements} entries`
          : "No entries to show",
    };
  }, [page, size, totalElements]);

  /**
   * Flags for navigation
   */
  const flags = useMemo(
    () => ({
      canPreviousPage: page > 0,
      canNextPage: page < totalPages - 1,
      isFirstPage: page === 0,
      isLastPage: page >= totalPages - 1,
      hasPages: totalPages > 0,
      hasMultiplePages: totalPages > 1,
    }),
    [page, totalPages]
  );

  /**
   * Page numbers for pagination UI
   */
  const pageNumbers = useMemo(() => {
    const pages = [];
    const maxVisible = 5;
    const halfVisible = Math.floor(maxVisible / 2);

    let startPage = Math.max(0, page - halfVisible);
    let endPage = Math.min(totalPages - 1, page + halfVisible);

    // Adjust if at the beginning or end
    if (page < halfVisible) {
      endPage = Math.min(totalPages - 1, maxVisible - 1);
    }
    if (page > totalPages - halfVisible - 1) {
      startPage = Math.max(0, totalPages - maxVisible);
    }

    for (let i = startPage; i <= endPage; i++) {
      pages.push(i);
    }

    return pages;
  }, [page, totalPages]);

  return {
    // State
    page,
    size,
    totalElements,
    totalPages,

    // Navigation
    nextPage,
    previousPage,
    goToPage,
    firstPage,
    lastPage,

    // Size
    changeSize,
    pageSizeOptions: APP_CONFIG.PAGINATION.PAGE_SIZE_OPTIONS,

    // Reset
    reset,

    // API params
    paginationParams,

    // Display
    displayInfo,
    pageNumbers,

    // Flags
    ...flags,
  };
};

/**
 * Hook for managing sorting state
 * @param {Object} options - Sorting options
 * @returns {Object} Sorting state and handlers
 */
export const useSorting = (options = {}) => {
  const { initialSortField = "", initialSortDirection = "asc" } = options;

  const [sortField, setSortField] = useState(initialSortField);
  const [sortDirection, setSortDirection] = useState(initialSortDirection);

  /**
   * Handle sort change
   * @param {string} field - Field to sort by
   */
  const handleSort = useCallback(
    (field) => {
      if (sortField === field) {
        // Toggle direction if same field
        setSortDirection((prev) => (prev === "asc" ? "desc" : "asc"));
      } else {
        // New field, reset to ascending
        setSortField(field);
        setSortDirection("asc");
      }
    },
    [sortField]
  );

  /**
   * Set sort explicitly
   * @param {string} field - Field to sort by
   * @param {string} direction - Sort direction ('asc' or 'desc')
   */
  const setSort = useCallback((field, direction = "asc") => {
    setSortField(field);
    setSortDirection(direction);
  }, []);

  /**
   * Clear sorting
   */
  const clearSort = useCallback(() => {
    setSortField("");
    setSortDirection("asc");
  }, []);

  /**
   * Sort params for API requests
   */
  const sortParams = useMemo(() => {
    if (!sortField) return {};
    return {
      sort: `${sortField},${sortDirection}`,
    };
  }, [sortField, sortDirection]);

  /**
   * Get sort indicator for a field
   * @param {string} field - Field name
   * @returns {string|null} Sort indicator ('asc', 'desc', or null)
   */
  const getSortIndicator = useCallback(
    (field) => {
      if (sortField !== field) return null;
      return sortDirection;
    },
    [sortField, sortDirection]
  );

  return {
    sortField,
    sortDirection,
    handleSort,
    setSort,
    clearSort,
    sortParams,
    getSortIndicator,
    isSorted: !!sortField,
  };
};

/**
 * Combined hook for pagination and sorting
 * @param {Object} options - Options for both pagination and sorting
 * @returns {Object} Combined pagination and sorting state
 */
export const useTableState = (options = {}) => {
  const pagination = usePagination(options);
  const sorting = useSorting(options);

  /**
   * Combined params for API requests
   */
  const tableParams = useMemo(
    () => ({
      ...pagination.paginationParams,
      ...sorting.sortParams,
    }),
    [pagination.paginationParams, sorting.sortParams]
  );

  /**
   * Reset both pagination and sorting
   */
  const resetAll = useCallback(() => {
    pagination.reset();
    sorting.clearSort();
  }, [pagination.reset, sorting.clearSort]);

  return {
    ...pagination,
    ...sorting,
    tableParams,
    resetAll,
  };
};

export default usePagination;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\usePermissions.js"   & echo.. 
/**
 * Permissions Hook
 * Provides role-based permission checking utilities
 */

import { useMemo, useCallback } from "react";
import { useAuthStore } from "@/store";
import { ROLES, PERMISSIONS, ROLE_HIERARCHY } from "@/constants";

/**
 * Hook for permission-based access control
 * @returns {Object} Permission utilities
 */
export const usePermissions = () => {
  const { user } = useAuthStore();
  const role = user?.role;

  /**
   * Check if user has permission for a specific action on a feature
   * @param {string} feature - Feature name (e.g., 'products', 'inventory')
   * @param {string} action - Action name (e.g., 'view', 'create', 'edit', 'delete')
   * @returns {boolean}
   */
  const hasPermission = useCallback(
    (feature, action) => {
      if (!role) return false;

      // Super admin has all permissions
      if (role === ROLES.SUPER_ADMIN) return true;

      const rolePermissions = PERMISSIONS[role];
      if (!rolePermissions) return false;

      const featurePermissions = rolePermissions[feature];
      if (!featurePermissions) return false;

      // Check if action is allowed
      if (Array.isArray(featurePermissions)) {
        return featurePermissions.includes(action);
      }

      // If featurePermissions is true, all actions are allowed
      return featurePermissions === true;
    },
    [role]
  );

  /**
   * Check if user can view a feature
   */
  const canView = useCallback(
    (feature) => hasPermission(feature, "view"),
    [hasPermission]
  );

  /**
   * Check if user can create in a feature
   */
  const canCreate = useCallback(
    (feature) => hasPermission(feature, "create"),
    [hasPermission]
  );

  /**
   * Check if user can edit in a feature
   */
  const canEdit = useCallback(
    (feature) => hasPermission(feature, "edit"),
    [hasPermission]
  );

  /**
   * Check if user can delete in a feature
   */
  const canDelete = useCallback(
    (feature) => hasPermission(feature, "delete"),
    [hasPermission]
  );

  /**
   * Check if user has any of the specified roles
   * @param {Array<string>} roles - Array of role names
   * @returns {boolean}
   */
  const hasAnyRole = useCallback(
    (roles) => {
      if (!role) return false;
      return roles.includes(role);
    },
    [role]
  );

  /**
   * Check if user has minimum role level
   * @param {string} minimumRole - Minimum role required
   * @returns {boolean}
   */
  const hasMinimumRole = useCallback(
    (minimumRole) => {
      if (!role) return false;
      const userLevel = ROLE_HIERARCHY[role] ?? 0;
      const requiredLevel = ROLE_HIERARCHY[minimumRole] ?? 999;
      return userLevel >= requiredLevel;
    },
    [role]
  );

  /**
   * Check if user is super admin
   */
  const isSuperAdmin = useMemo(() => role === ROLES.SUPER_ADMIN, [role]);

  /**
   * Check if user is owner or above
   */
  const isOwnerOrAbove = useMemo(
    () => hasAnyRole([ROLES.SUPER_ADMIN, ROLES.ADMIN]),
    [hasAnyRole]
  );

  /**
   * Check if user is branch admin or above
   */
  const isBranchAdminOrAbove = useMemo(
    () => hasAnyRole([ROLES.SUPER_ADMIN, ROLES.ADMIN, ROLES.BRANCH_MANAGER]),
    [hasAnyRole]
  );

  /**
   * Check if user can access POS
   */
  const canAccessPOS = useMemo(
    () =>
      hasAnyRole([
        ROLES.SUPER_ADMIN,
        ROLES.ADMIN,
        ROLES.BRANCH_MANAGER,
        ROLES.PHARMACIST,
        ROLES.CASHIER,
      ]),
    [hasAnyRole]
  );

  /**
   * Check if user can access inventory management
   */
  const canAccessInventory = useMemo(
    () =>
      hasAnyRole([
        ROLES.SUPER_ADMIN,
        ROLES.ADMIN,
        ROLES.BRANCH_MANAGER,
        ROLES.PHARMACIST,
        ROLES.INVENTORY_MANAGER,
      ]),
    [hasAnyRole]
  );

  /**
   * Check if user can access finance
   */
  const canAccessFinance = useMemo(
    () => hasAnyRole([ROLES.SUPER_ADMIN, ROLES.ADMIN, ROLES.ACCOUNTANT]),
    [hasAnyRole]
  );

  /**
   * Check if user can access reports
   */
  const canAccessReports = useMemo(
    () =>
      hasAnyRole([
        ROLES.SUPER_ADMIN,
        ROLES.ADMIN,
        ROLES.BRANCH_MANAGER,
        ROLES.ACCOUNTANT,
      ]),
    [hasAnyRole]
  );

  /**
   * Check if user can manage employees
   */
  const canManageEmployees = useMemo(
    () => hasAnyRole([ROLES.SUPER_ADMIN, ROLES.ADMIN, ROLES.BRANCH_MANAGER]),
    [hasAnyRole]
  );

  /**
   * Check if user can handle prescriptions (controlled drugs)
   */
  const canHandlePrescriptions = useMemo(
    () =>
      hasAnyRole([
        ROLES.SUPER_ADMIN,
        ROLES.ADMIN,
        ROLES.BRANCH_MANAGER,
        ROLES.PHARMACIST,
      ]),
    [hasAnyRole]
  );

  /**
   * Get maximum discount percentage allowed for user
   * @returns {number}
   */
  const maxDiscount = useMemo(() => {
    const discountLimits = {
      [ROLES.SUPER_ADMIN]: 100,
      [ROLES.OWNER]: 100,
      [ROLES.BRANCH_ADMIN]: 25,
      [ROLES.PHARMACIST]: 10,
      [ROLES.CASHIER]: 5,
      [ROLES.INVENTORY_MANAGER]: 0,
      [ROLES.ACCOUNTANT]: 0,
    };
    return discountLimits[role] ?? 0;
  }, [role]);

  /**
   * Check if user can give credit to customers
   * @returns {boolean}
   */
  const canGiveCredit = useMemo(
    () => hasAnyRole([ROLES.SUPER_ADMIN, ROLES.OWNER, ROLES.BRANCH_ADMIN]),
    [hasAnyRole]
  );

  /**
   * Get list of features user can access
   * @returns {Array<string>}
   */
  const accessibleFeatures = useMemo(() => {
    if (!role) return [];
    if (role === ROLES.SUPER_ADMIN) return ["*"];

    const rolePermissions = PERMISSIONS[role];
    if (!rolePermissions) return [];

    return Object.keys(rolePermissions);
  }, [role]);

  return {
    // Role info
    role,

    // Permission checks
    hasPermission,
    canView,
    canCreate,
    canEdit,
    canDelete,

    // Role checks
    hasAnyRole,
    hasMinimumRole,

    // Convenience flags
    isSuperAdmin,
    isOwnerOrAbove,
    isBranchAdminOrAbove,

    // Feature access
    canAccessPOS,
    canAccessInventory,
    canAccessFinance,
    canAccessReports,
    canManageEmployees,
    canHandlePrescriptions,

    // Limits
    maxDiscount,
    canGiveCredit,

    // Features list
    accessibleFeatures,
  };
};

export default usePermissions;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\hooks\useWebSocket.js"   & echo.. 
/**
 * WebSocket Hook
 * Provides real-time communication utilities
 */

import { useState, useEffect, useCallback, useRef } from "react";
import { useAuthStore, useNotificationStore } from "@/store";
import { API_CONFIG } from "@/config";

/**
 * WebSocket connection states
 */
export const WS_STATE = {
  CONNECTING: "CONNECTING",
  CONNECTED: "CONNECTED",
  DISCONNECTED: "DISCONNECTED",
  ERROR: "ERROR",
};

/**
 * Hook for WebSocket connection management
 * @param {Object} options - WebSocket options
 * @returns {Object} WebSocket utilities and state
 */
export const useWebSocket = (options = {}) => {
  const {
    autoConnect = true,
    reconnectInterval = 5000,
    maxReconnectAttempts = 5,
    onMessage,
    onConnect,
    onDisconnect,
    onError,
  } = options;

  const wsRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);
  const reconnectAttemptsRef = useRef(0);

  const [state, setState] = useState(WS_STATE.DISCONNECTED);
  const [lastMessage, setLastMessage] = useState(null);

  const { isAuthenticated, accessToken } = useAuthStore();
  const { addNotification } = useNotificationStore();

  /**
   * Get WebSocket URL
   */
  const getWsUrl = useCallback(() => {
    const wsUrl =
      API_CONFIG.WS_URL || API_CONFIG.BASE_URL.replace(/^http/, "ws");
    return `${wsUrl}?token=${accessToken}`;
  }, [accessToken]);

  /**
   * Connect to WebSocket
   */
  const connect = useCallback(() => {
    if (!isAuthenticated || wsRef.current?.readyState === WebSocket.OPEN) {
      return;
    }

    try {
      setState(WS_STATE.CONNECTING);
      wsRef.current = new WebSocket(getWsUrl());

      wsRef.current.onopen = () => {
        setState(WS_STATE.CONNECTED);
        reconnectAttemptsRef.current = 0;
        onConnect?.();
      };

      wsRef.current.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          setLastMessage(data);

          // Handle different message types
          if (data.type === "NOTIFICATION") {
            addNotification(data.payload);
          }

          onMessage?.(data);
        } catch (error) {
          console.error("Failed to parse WebSocket message:", error);
        }
      };

      wsRef.current.onclose = (event) => {
        setState(WS_STATE.DISCONNECTED);
        onDisconnect?.(event);

        // Attempt reconnection if not intentionally closed
        if (
          !event.wasClean &&
          reconnectAttemptsRef.current < maxReconnectAttempts
        ) {
          reconnectTimeoutRef.current = setTimeout(() => {
            reconnectAttemptsRef.current++;
            connect();
          }, reconnectInterval);
        }
      };

      wsRef.current.onerror = (error) => {
        setState(WS_STATE.ERROR);
        onError?.(error);
      };
    } catch (error) {
      setState(WS_STATE.ERROR);
      onError?.(error);
    }
  }, [
    isAuthenticated,
    getWsUrl,
    onConnect,
    onMessage,
    onDisconnect,
    onError,
    addNotification,
    maxReconnectAttempts,
    reconnectInterval,
  ]);

  /**
   * Disconnect from WebSocket
   */
  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }

    if (wsRef.current) {
      wsRef.current.close(1000, "Client disconnecting");
      wsRef.current = null;
    }

    setState(WS_STATE.DISCONNECTED);
  }, []);

  /**
   * Send message through WebSocket
   * @param {Object} data - Data to send
   */
  const send = useCallback((data) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(data));
      return true;
    }
    console.warn("WebSocket is not connected");
    return false;
  }, []);

  /**
   * Subscribe to a topic
   * @param {string} topic - Topic to subscribe to
   */
  const subscribe = useCallback(
    (topic) => {
      return send({ type: "SUBSCRIBE", topic });
    },
    [send]
  );

  /**
   * Unsubscribe from a topic
   * @param {string} topic - Topic to unsubscribe from
   */
  const unsubscribe = useCallback(
    (topic) => {
      return send({ type: "UNSUBSCRIBE", topic });
    },
    [send]
  );

  // Auto-connect on mount if authenticated
  useEffect(() => {
    if (autoConnect && isAuthenticated) {
      connect();
    }

    return () => {
      disconnect();
    };
  }, [autoConnect, isAuthenticated]);

  // Reconnect on token change
  useEffect(() => {
    if (isAuthenticated && state === WS_STATE.DISCONNECTED) {
      connect();
    } else if (!isAuthenticated && state !== WS_STATE.DISCONNECTED) {
      disconnect();
    }
  }, [isAuthenticated, accessToken]);

  return {
    // State
    state,
    isConnected: state === WS_STATE.CONNECTED,
    isConnecting: state === WS_STATE.CONNECTING,
    lastMessage,

    // Actions
    connect,
    disconnect,
    send,
    subscribe,
    unsubscribe,
  };
};

/**
 * Hook for subscribing to specific WebSocket topics
 * @param {string} topic - Topic to subscribe to
 * @param {Function} onMessage - Message handler
 * @returns {Object} Subscription state
 */
export const useSubscription = (topic, onMessage) => {
  const [messages, setMessages] = useState([]);

  const handleMessage = useCallback(
    (data) => {
      if (data.topic === topic) {
        setMessages((prev) => [...prev.slice(-99), data.payload]);
        onMessage?.(data.payload);
      }
    },
    [topic, onMessage]
  );

  const ws = useWebSocket({
    onMessage: handleMessage,
  });

  useEffect(() => {
    if (ws.isConnected) {
      ws.subscribe(topic);
    }

    return () => {
      if (ws.isConnected) {
        ws.unsubscribe(topic);
      }
    };
  }, [ws.isConnected, topic]);

  return {
    ...ws,
    messages,
    clearMessages: () => setMessages([]),
  };
};

export default useWebSocket;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\lib\utils.js"   & echo.. 
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\branches\index.js"   & echo.. 
/**
 * Branches Pages Barrel Export
 */

export { default as BranchesPage } from "./BranchesPage";
export { default as BranchFormPage } from "./BranchFormPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\categories\index.js"   & echo.. 
/**
 * Categories Pages Barrel Export
 */

export { default as CategoriesPage } from "./CategoriesPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\customers\index.js"   & echo.. 
/**
 * Customers Pages Barrel Export
 */

export { default as CustomersPage } from "./CustomersPage";
export { default as CustomerFormPage } from "./CustomerFormPage";
export { default as CreditAccountsPage } from "./CreditAccountsPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\employees\index.js"   & echo.. 
/**
 * Employees Pages Barrel Export
 */

/**
 * Employees Pages Barrel Export
 */

export { default as EmployeesPage } from "./EmployeesPage";
export { default as EmployeeFormPage } from "./EmployeeFormPage";
export { default as EmployeeViewPage } from "./EmployeeViewPage";
export { default as EmployeeAttendancePage } from "./EmployeeAttendancePage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\finance\index.js"   & echo.. 
/**
 * Finance Pages Barrel Export
 */

export { default as FinancePage } from "./FinancePage";
export { default as TransactionsPage } from "./TransactionsPage";
export { default as InvoicesPage } from "./InvoicesPage";
export { default as ChequesPage } from "./ChequesPage";
export { default as BanksPage } from "./BanksPage";
export { default as CashRegisterPage } from "./CashRegisterPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\grn\index.js"   & echo.. 
/**
 * GRN Pages Barrel Export
 */

export { default as GRNListPage } from "./GRNListPage";
export { default as GRNFormPage } from "./GRNFormPage";
export { default as DirectGRNFormPage } from "./DirectGRNFormPage";
export { default as GRNViewPage } from "./GRNViewPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\inventory\index.js"   & echo.. 
/**
 * Inventory Pages Barrel Export
 */

export { default as InventoryPage } from "./InventoryPage";
export { default as LowStockPage } from "./LowStockPage";
export { default as ExpiringPage } from "./ExpiringPage";
export { default as StockTransfersPage } from "./StockTransfersPage";
export { default as StockTransferFormPage } from "./StockTransferFormPage";
export { default as StockMovementsPage } from "./StockMovementsPage";
export { default as StockAdjustmentsPage } from "./StockAdjustmentsPage";
export { default as StockAdjustmentFormPage } from "./StockAdjustmentFormPage";
export { default as BatchTrackingPage } from "./BatchTrackingPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\payroll\index.js"   & echo.. 
/**
 * Payroll Pages Barrel Export
 */

export { default as PayrollPage } from "./PayrollPage";
export { default as SalariesPage } from "./SalariesPage";
export { default as AttendancePage } from "./AttendancePage";
export { default as AdvancesPage } from "./AdvancesPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\pos\index.js"   & echo.. 
/**
 * POS Pages Barrel Export
 */

export { default as POSPage } from "./POSPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\products\index.js"   & echo.. 
/**
 * Products Pages Barrel Export
 */

export { default as ProductsPage } from "./ProductsPage";
export { default as ProductFormPage } from "./ProductFormPage";
export { default as ProductViewPage } from "./ProductViewPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\purchase-orders\index.js"   & echo.. 
/**
 * Purchase Orders Pages Barrel Export
 */

export { default as PurchaseOrdersPage } from "./PurchaseOrdersPage";
export { default as PurchaseOrderFormPage } from "./PurchaseOrderFormPage";
export { default as PurchaseOrderViewPage } from "./PurchaseOrderViewPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\reports\index.js"   & echo.. 
/**
 * Reports Pages Barrel Export
 */

export { default as ReportsPage } from "./ReportsPage";
export { default as SalesReportPage } from "./SalesReportPage";
export { default as InventoryReportPage } from "./InventoryReportPage";
export { default as FinancialReportPage } from "./FinancialReportPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\sales\index.js"   & echo.. 
/**
 * Sales Pages Barrel Export
 */

export { default as POSPage } from "../pos/POSPage";
export { default as SalesHistoryPage } from "./SalesHistoryPage";
export { default as SaleViewPage } from "./SaleViewPage";
export { default as SaleReturnsPage } from "./SaleReturnsPage";
export { default as SaleReturnFormPage } from "./SaleReturnFormPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\settings\index.js"   & echo.. 
/**
 * Settings Pages Barrel Export
 */

export { default as SettingsPage } from "./SettingsPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\suppliers\index.js"   & echo.. 
/**
 * Suppliers Pages Barrel Export
 */

export { default as SuppliersPage } from "./SuppliersPage";
export { default as SupplierFormPage } from "./SupplierFormPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\pages\users\index.js"   & echo.. 
/**
 * Users Pages Barrel Export
 */

export { default as UsersPage } from "./UsersPage";
export { default as UserFormPage } from "./UserFormPage";
export { default as UserViewPage } from "./UserViewPage";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\routes\guards\index.js"   & echo.. 
/**
 * Route Guards Barrel Export
 */

export { default as AuthGuard } from "./AuthGuard";
export { default as RoleGuard } from "./RoleGuard";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\authService.js"   & echo.. 
/**
 * Auth Service
 * Handles authentication related API calls
 */

import { apiClient } from "@/utils/api";

const AUTH_BASE_URL = "/auth";

/**
 * Auth Service API methods
 */
export const authService = {
  /**
   * Login user
   * @param {Object} credentials - { username, password }
   * @returns {Promise} Login response with tokens
   */
  login: async (credentials) => {
    const response = await apiClient.post(
      `${AUTH_BASE_URL}/login`,
      credentials
    );
    return response.data;
  },

  /**
   * Logout current user
   * @returns {Promise}
   */
  logout: async () => {
    const response = await apiClient.post(`${AUTH_BASE_URL}/logout`);
    return response.data;
  },

  /**
   * Get current authenticated user
   * @returns {Promise} Current user details
   */
  getCurrentUser: async () => {
    const response = await apiClient.get(`${AUTH_BASE_URL}/me`);
    return response.data;
  },

  /**
   * Change password
   * @param {Object} data - { currentPassword, newPassword, confirmPassword }
   * @returns {Promise}
   */
  changePassword: async (data) => {
    const response = await apiClient.post(
      `${AUTH_BASE_URL}/change-password`,
      data
    );
    return response.data;
  },

  /**
   * Refresh access token
   * @param {string} refreshToken - Refresh token
   * @returns {Promise} New tokens
   */
  refreshToken: async (refreshToken) => {
    const response = await apiClient.post(`${AUTH_BASE_URL}/refresh`, null, {
      params: { refreshToken },
    });
    return response.data;
  },

  /**
   * Register new user (admin only)
   * @param {Object} userData - User registration data
   * @returns {Promise} Created user
   */
  register: async (userData) => {
    const response = await apiClient.post(
      `${AUTH_BASE_URL}/register`,
      userData
    );
    return response.data;
  },
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\branchService.js"   & echo.. 
/**
 * Branch Service
 * API calls for branch management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const branchService = {
  /**
   * Get all branches (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "branchName,asc" } = params;
    return api.get(API_ENDPOINTS.BRANCHES.BASE, {
      params: { page, size, sort },
    });
  },

  /**
   * Get all branches (list - no pagination)
   */
  getAllList: () => {
    return api.get(API_ENDPOINTS.BRANCHES.ALL);
  },

  /**
   * Get branch by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.BRANCHES.BY_ID(id));
  },

  /**
   * Get branch by code
   */
  getByCode: (code) => {
    return api.get(API_ENDPOINTS.BRANCHES.BY_CODE(code));
  },

  /**
   * Get active branches
   */
  getActive: () => {
    return api.get(API_ENDPOINTS.BRANCHES.ACTIVE);
  },

  /**
   * Create new branch
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.BRANCHES.BASE, data);
  },

  /**
   * Update branch
   */
  update: (id, data) => {
    return api.put(API_ENDPOINTS.BRANCHES.BY_ID(id), data);
  },

  /**
   * Delete branch (soft delete)
   */
  delete: (id) => {
    return api.delete(API_ENDPOINTS.BRANCHES.BY_ID(id));
  },

  /**
   * Activate branch
   */
  activate: (id) => {
    return api.post(API_ENDPOINTS.BRANCHES.ACTIVATE(id));
  },

  /**
   * Deactivate branch
   */
  deactivate: (id) => {
    return api.post(API_ENDPOINTS.BRANCHES.DEACTIVATE(id));
  },
};

export default branchService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\categoryService.js"   & echo.. 
/**
 * Category Service
 * API calls for category management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const categoryService = {
  /**
   * Get all categories
   */
  getAll: () => {
    return api.get(API_ENDPOINTS.CATEGORIES.BASE);
  },

  /**
   * Get active categories
   */
  getActive: () => {
    return api.get(API_ENDPOINTS.CATEGORIES.ACTIVE);
  },

  /**
   * Get category by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.CATEGORIES.BY_ID(id));
  },

  /**
   * Create new category
   * Backend expects query params: categoryName, categoryCode, description
   */
  create: (data) => {
    const params = new URLSearchParams();
    params.append("categoryName", data.name || data.categoryName);
    if (data.code || data.categoryCode) {
      params.append("categoryCode", data.code || data.categoryCode);
    }
    if (data.description) {
      params.append("description", data.description);
    }
    // Send empty body - backend expects @RequestParam not @RequestBody
    return api.post(
      `${API_ENDPOINTS.CATEGORIES.BASE}?${params.toString()}`,
      {}
    );
  },

  /**
   * Update category
   * Backend expects query params: categoryName, description
   */
  update: (id, data) => {
    const params = new URLSearchParams();
    params.append("categoryName", data.name || data.categoryName);
    if (data.description) {
      params.append("description", data.description);
    }
    // Send empty body - backend expects @RequestParam not @RequestBody
    return api.put(
      `${API_ENDPOINTS.CATEGORIES.BY_ID(id)}?${params.toString()}`,
      {}
    );
  },

  /**
   * Delete category
   */
  delete: (id) => {
    return api.delete(API_ENDPOINTS.CATEGORIES.BY_ID(id));
  },
};

export default categoryService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\customerService.js"   & echo.. 
/**
 * Customer Service
 * API calls for customer management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const customerService = {
  /**
   * Get all customers (paginated)
   */
  getAll: async (params = {}) => {
    const {
      page = 0,
      size = 10,
      sortBy = "customerName",
      sortDir = "asc",
      ...filters
    } = params;
    const response = await api.get(API_ENDPOINTS.CUSTOMERS.BASE, {
      params: { page, size, sortBy, sortDir, ...filters },
    });
    return response.data.data;
  },

  /**
   * Get customer by ID
   */
  getById: async (id) => {
    const response = await api.get(API_ENDPOINTS.CUSTOMERS.BY_ID(id));
    return response.data.data;
  },

  /**
   * Get customer by code
   */
  getByCode: async (code) => {
    const response = await api.get(API_ENDPOINTS.CUSTOMERS.BY_CODE(code));
    return response.data.data;
  },

  /**
   * Search customers
   */
  search: async (query, params = {}) => {
    const response = await api.get(API_ENDPOINTS.CUSTOMERS.SEARCH, {
      params: { query, ...params },
    });
    return response.data.data;
  },

  /**
   * Get active customers
   */
  getActive: async () => {
    const response = await api.get(API_ENDPOINTS.CUSTOMERS.ACTIVE);
    return response.data.data;
  },

  /**
   * Create new customer
   */
  create: async (data) => {
    const response = await api.post(API_ENDPOINTS.CUSTOMERS.BASE, data);
    return response.data.data;
  },

  /**
   * Update customer
   */
  update: async (id, data) => {
    const response = await api.put(API_ENDPOINTS.CUSTOMERS.BY_ID(id), data);
    return response.data.data;
  },

  /**
   * Delete customer (soft delete)
   */
  delete: async (id) => {
    const response = await api.delete(API_ENDPOINTS.CUSTOMERS.BY_ID(id));
    return response.data.data;
  },

  /**
   * Activate customer
   */
  activate: async (id) => {
    const response = await api.patch(API_ENDPOINTS.CUSTOMERS.ACTIVATE(id));
    return response.data.data;
  },

  /**
   * Deactivate customer
   */
  deactivate: async (id) => {
    const response = await api.patch(API_ENDPOINTS.CUSTOMERS.DEACTIVATE(id));
    return response.data.data;
  },
};

export default customerService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\dashboardService.js"   & echo.. 
/**
 * Dashboard Service
 * API calls for dashboard data
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const dashboardService = {
  /**
   * Get dashboard summary
   */
  getSummary: (branchId) => {
    return api.get(API_ENDPOINTS.DASHBOARD.SUMMARY, {
      params: { branchId },
    });
  },

  /**
   * Get sales chart data
   */
  getSalesChart: (branchId, period = "week") => {
    return api.get(API_ENDPOINTS.DASHBOARD.SALES_CHART, {
      params: { branchId, period },
    });
  },
};

export default dashboardService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\grnService.js"   & echo.. 
/**
 * GRN Service
 * API calls for Goods Receipt Note management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const grnService = {
  /**
   * Get all GRNs (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "createdAt,desc", ...filters } = params;
    return api.get(API_ENDPOINTS.GRN.BASE, {
      params: { page, size, sort, ...filters },
    });
  },

  /**
   * Get GRN by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.GRN.BY_ID(id));
  },

  /**
   * Get GRN by number
   */
  getByNumber: (grnNumber) => {
    return api.get(API_ENDPOINTS.GRN.BY_NUMBER(grnNumber));
  },

  /**
   * Get GRNs by branch
   */
  getByBranch: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.GRN.BY_BRANCH(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get GRNs by supplier
   */
  getBySupplier: (supplierId, params = {}) => {
    return api.get(API_ENDPOINTS.GRN.BY_SUPPLIER(supplierId), {
      params: { ...params },
    });
  },

  /**
   * Get GRNs by status
   */
  getByStatus: (status, params = {}) => {
    return api.get(API_ENDPOINTS.GRN.BY_STATUS(status), {
      params: { ...params },
    });
  },

  /**
   * Create new GRN
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.GRN.BASE, data);
  },

  /**
   * Update existing GRN (only for PENDING/DRAFT status)
   */
  update: (id, data) => {
    return api.put(API_ENDPOINTS.GRN.BY_ID(id), data);
  },

  /**
   * Approve GRN
   */
  approve: (id) => {
    return api.post(API_ENDPOINTS.GRN.APPROVE(id));
  },

  /**
   * Reject GRN
   */
  reject: (id, reason) => {
    return api.post(API_ENDPOINTS.GRN.REJECT(id), { reason });
  },

  /**
   * Cancel GRN
   */
  cancel: (id, reason) => {
    return api.post(API_ENDPOINTS.GRN.CANCEL(id), { reason });
  },

  /**
   * Verify GRN (moves DRAFT to VERIFIED status)
   */
  verify: (id) => {
    return api.post(API_ENDPOINTS.GRN.APPROVE(id));
  },

  /**
   * Complete GRN (creates inventory batches and updates stock)
   */
  complete: (id) => {
    return api.post(API_ENDPOINTS.GRN.APPROVE(id));
  },
};

/**
 * RGRN (Return GRN) Service
 */
export const rgrnService = {
  /**
   * Get all RGRNs (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "createdAt,desc" } = params;
    return api.get(API_ENDPOINTS.RGRN.BASE, {
      params: { page, size, sort },
    });
  },

  /**
   * Get RGRN by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.RGRN.BY_ID(id));
  },

  /**
   * Get RGRNs by supplier
   */
  getBySupplier: (supplierId, params = {}) => {
    return api.get(API_ENDPOINTS.RGRN.BY_SUPPLIER(supplierId), {
      params: { ...params },
    });
  },

  /**
   * Get RGRNs by original GRN
   */
  getByGrn: (grnId, params = {}) => {
    return api.get(API_ENDPOINTS.RGRN.BY_GRN(grnId), {
      params: { ...params },
    });
  },

  /**
   * Create RGRN
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.RGRN.BASE, data);
  },

  /**
   * Update refund status
   */
  updateRefundStatus: (id, status) => {
    return api.put(API_ENDPOINTS.RGRN.UPDATE_REFUND_STATUS(id), { status });
  },

  /**
   * Delete RGRN (admin only)
   */
  delete: (id) => {
    return api.delete(API_ENDPOINTS.RGRN.BY_ID(id));
  },
};

export default grnService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\index.js"   & echo.. 
/**
 * Services Barrel Export
 * Central API service layer for all features
 */
export * from "./authService";
export * from "./productService";
export * from "./categoryService";
export * from "./inventoryService";
export * from "./saleService";
export * from "./customerService";
export * from "./supplierService";
export * from "./purchaseOrderService";
export * from "./grnService";
export * from "./userService";
export * from "./branchService";
export * from "./reportService";
export * from "./dashboardService";
export * from "./systemConfigService";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\inventoryService.js"   & echo.. 
/**
 * Inventory Service
 * API calls for inventory management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const inventoryService = {
  /**
   * Get inventory by branch (paginated)
   */
  getByBranch: (branchId, params = {}) => {
    const { page = 0, size = 10, sort = "product.productName,asc" } = params;
    return api.get(API_ENDPOINTS.INVENTORY.BY_BRANCH(branchId), {
      params: { page, size, sort },
    });
  },

  /**
   * Get inventory by product and branch
   */
  getByProductAndBranch: (productId, branchId) => {
    return api.get(
      API_ENDPOINTS.INVENTORY.BY_PRODUCT_AND_BRANCH(productId, branchId)
    );
  },

  /**
   * Get low stock items
   */
  getLowStock: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.INVENTORY.LOW_STOCK(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get out of stock items
   */
  getOutOfStock: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.INVENTORY.OUT_OF_STOCK(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get expiring batches
   */
  getExpiring: (branchId, days = 30, params = {}) => {
    return api.get(API_ENDPOINTS.INVENTORY.EXPIRING(branchId), {
      params: { days, ...params },
    });
  },

  /**
   * Get expired batches
   */
  getExpired: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.INVENTORY.EXPIRED(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get inventory batches for a product
   */
  getBatches: (productId, branchId) => {
    return api.get(API_ENDPOINTS.INVENTORY.BATCHES(productId, branchId));
  },

  /**
   * Get available quantity
   */
  getAvailableQuantity: (productId, branchId) => {
    return api.get(
      API_ENDPOINTS.INVENTORY.AVAILABLE_QUANTITY(productId, branchId)
    );
  },

  /**
   * Get all low stock products (across all branches)
   */
  getLowStockProducts: (params = {}) => {
    const { page = 0, size = 20, sort = "quantityAvailable,asc" } = params;
    return api.get(API_ENDPOINTS.INVENTORY.ALL_LOW_STOCK, {
      params: { page, size, sort },
    });
  },

  /**
   * Get all expiring products (across all branches)
   */
  getExpiringProducts: (params = {}) => {
    const { days = 30, page = 0, size = 20, sort = "expiryDate,asc" } = params;
    return api.get(API_ENDPOINTS.INVENTORY.ALL_EXPIRING, {
      params: { days, page, size, sort },
    });
  },

  /**
   * Get all expired products (across all branches)
   */
  getExpiredProducts: (params = {}) => {
    const { page = 0, size = 20, sort = "expiryDate,desc" } = params;
    return api.get(API_ENDPOINTS.INVENTORY.ALL_EXPIRED, {
      params: { page, size, sort },
    });
  },
};

/**
 * Stock Transfer Service
 */
export const stockTransferService = {
  /**
   * Get all transfers (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "createdAt,desc" } = params;
    return api.get(API_ENDPOINTS.STOCK_TRANSFERS.BASE, {
      params: { page, size, sort },
    });
  },

  /**
   * Get transfer by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.STOCK_TRANSFERS.BY_ID(id));
  },

  /**
   * Get transfers by source branch
   */
  getBySourceBranch: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.STOCK_TRANSFERS.BY_SOURCE(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get transfers by destination branch
   */
  getByDestinationBranch: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.STOCK_TRANSFERS.BY_DESTINATION(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get transfers by status
   */
  getByStatus: (status, params = {}) => {
    return api.get(API_ENDPOINTS.STOCK_TRANSFERS.BY_STATUS(status), {
      params: { ...params },
    });
  },

  /**
   * Create new transfer
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.STOCK_TRANSFERS.BASE, data);
  },

  /**
   * Approve transfer
   */
  approve: (id) => {
    return api.post(API_ENDPOINTS.STOCK_TRANSFERS.APPROVE(id));
  },

  /**
   * Receive transfer
   */
  receive: (id) => {
    return api.post(API_ENDPOINTS.STOCK_TRANSFERS.RECEIVE(id));
  },

  /**
   * Reject transfer
   */
  reject: (id, reason) => {
    return api.post(API_ENDPOINTS.STOCK_TRANSFERS.REJECT(id), { reason });
  },

  /**
   * Cancel transfer
   */
  cancel: (id, reason) => {
    return api.post(API_ENDPOINTS.STOCK_TRANSFERS.CANCEL(id), { reason });
  },
};

export default inventoryService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\productService.js"   & echo.. 
/**
 * Product Service
 * API calls for product management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const productService = {
  /**
   * Get all products with pagination
   */
  getAll: (params = {}) => {
    const {
      page = 0,
      size = 10,
      sort = "productName,asc",
      ...filters
    } = params;
    return api.get(API_ENDPOINTS.PRODUCTS.BASE, {
      params: { page, size, sort, ...filters },
    });
  },

  /**
   * Get product by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.PRODUCTS.BY_ID(id));
  },

  /**
   * Get product by code
   */
  getByCode: (code) => {
    return api.get(API_ENDPOINTS.PRODUCTS.BY_CODE(code));
  },

  /**
   * Search products
   */
  search: (query, params = {}) => {
    return api.get(API_ENDPOINTS.PRODUCTS.SEARCH, {
      params: { query, ...params },
    });
  },

  /**
   * Get low stock products
   */
  getLowStock: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.PRODUCTS.LOW_STOCK, {
      params: { branchId, ...params },
    });
  },

  /**
   * Create new product
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.PRODUCTS.BASE, data);
  },

  /**
   * Update product
   */
  update: (id, data) => {
    return api.put(API_ENDPOINTS.PRODUCTS.BY_ID(id), data);
  },

  /**
   * Delete product (soft delete)
   */
  delete: (id) => {
    return api.delete(API_ENDPOINTS.PRODUCTS.BY_ID(id));
  },

  /**
   * Discontinue product
   */
  discontinue: (id) => {
    return api.patch(API_ENDPOINTS.PRODUCTS.DISCONTINUE(id));
  },

  /**
   * Export products to CSV
   */
  export: (params = {}) => {
    return api.get(API_ENDPOINTS.PRODUCTS.EXPORT, {
      params,
      responseType: "blob", // Important for file download
    });
  },

  /**
   * Import products from CSV file
   */
  import: (file) => {
    const formData = new FormData();
    formData.append("file", file);
    return api.post(API_ENDPOINTS.PRODUCTS.IMPORT, formData, {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    });
  },

  /**
   * Download import template
   */
  downloadTemplate: () => {
    return api.get(API_ENDPOINTS.PRODUCTS.TEMPLATE, {
      responseType: "blob",
    });
  },
};

export default productService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\purchaseOrderService.js"   & echo.. 
/**
 * Purchase Order Service
 * API calls for purchase order management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const purchaseOrderService = {
  /**
   * Get all purchase orders (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "createdAt,desc", ...filters } = params;
    return api.get(API_ENDPOINTS.PURCHASE_ORDERS.BASE, {
      params: { page, size, sort, ...filters },
    });
  },

  /**
   * Get PO by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.PURCHASE_ORDERS.BY_ID(id));
  },

  /**
   * Get PO by number
   */
  getByNumber: (poNumber) => {
    return api.get(API_ENDPOINTS.PURCHASE_ORDERS.BY_NUMBER(poNumber));
  },

  /**
   * Get POs by supplier
   */
  getBySupplier: (supplierId, params = {}) => {
    return api.get(API_ENDPOINTS.PURCHASE_ORDERS.BY_SUPPLIER(supplierId), {
      params: { ...params },
    });
  },

  /**
   * Get POs by branch
   */
  getByBranch: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.PURCHASE_ORDERS.BY_BRANCH(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get POs by status
   */
  getByStatus: (status, params = {}) => {
    return api.get(API_ENDPOINTS.PURCHASE_ORDERS.BY_STATUS(status), {
      params: { ...params },
    });
  },

  /**
   * Get pending/approved POs for GRN (multiple statuses)
   */
  getPending: () => {
    // Get all POs and filter on frontend for now
    // Ideally backend should support multiple status filtering
    return api.get(API_ENDPOINTS.PURCHASE_ORDERS.BASE, {
      params: { size: 1000, sort: 'createdAt,desc' },
    });
  },

  /**
   * Create new PO
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.PURCHASE_ORDERS.BASE, data);
  },

  /**
   * Update PO status
   */
  updateStatus: (id, status) => {
    return api.put(API_ENDPOINTS.PURCHASE_ORDERS.UPDATE_STATUS(id), null, {
      params: { status }
    });
  },

  /**
   * Submit PO for approval
   */
  submit: (id) => {
    return api.put(API_ENDPOINTS.PURCHASE_ORDERS.UPDATE_STATUS(id), null, {
      params: { status: 'PENDING_APPROVAL' }
    });
  },

  /**
   * Approve PO
   */
  approve: (id) => {
    return api.post(API_ENDPOINTS.PURCHASE_ORDERS.APPROVE(id));
  },

  /**
   * Reject PO
   */
  reject: (id, reason) => {
    return api.post(API_ENDPOINTS.PURCHASE_ORDERS.REJECT(id), { reason });
  },

  /**
   * Delete PO (admin only)
   */
  delete: (id) => {
    return api.delete(API_ENDPOINTS.PURCHASE_ORDERS.BY_ID(id));
  },
};

export default purchaseOrderService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\reportService.js"   & echo.. 
/**
 * Report Service
 * API calls for reports and analytics
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const reportService = {
  // ===================
  // SALES REPORTS
  // ===================

  /**
   * Get total sales amount
   */
  getSalesTotal: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.SALES.TOTAL, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get sales count
   */
  getSalesCount: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.SALES.COUNT, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get detailed sales report
   */
  getSalesDetails: (branchId, startDate, endDate, params = {}) => {
    return api.get(API_ENDPOINTS.REPORTS.SALES.DETAILS, {
      params: { branchId, startDate, endDate, ...params },
    });
  },

  /**
   * Get daily sales breakdown
   */
  getDailySales: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.SALES.DAILY, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get top selling products
   */
  getTopProducts: (branchId, startDate, endDate, limit = 10) => {
    return api.get(API_ENDPOINTS.REPORTS.SALES.TOP_PRODUCTS, {
      params: { branchId, startDate, endDate, limit },
    });
  },

  /**
   * Get sales by payment method
   */
  getSalesByPaymentMethod: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.SALES.BY_PAYMENT_METHOD, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get period comparison
   */
  getSalesComparison: (
    branchId,
    currentStart,
    currentEnd,
    previousStart,
    previousEnd
  ) => {
    return api.get(API_ENDPOINTS.REPORTS.SALES.COMPARISON, {
      params: {
        branchId,
        currentStart,
        currentEnd,
        previousStart,
        previousEnd,
      },
    });
  },

  // ===================
  // INVENTORY REPORTS
  // ===================

  /**
   * Get total stock value
   */
  getStockValue: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.INVENTORY.STOCK_VALUE, {
      params: { branchId },
    });
  },

  /**
   * Get stock value by category
   */
  getStockValueByCategory: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.INVENTORY.VALUE_BY_CATEGORY, {
      params: { branchId },
    });
  },

  /**
   * Get low stock report
   */
  getLowStockReport: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.REPORTS.INVENTORY.LOW_STOCK, {
      params: { branchId, ...params },
    });
  },

  /**
   * Get expiring stock report
   */
  getExpiringStockReport: (branchId, days = 30, params = {}) => {
    return api.get(API_ENDPOINTS.REPORTS.INVENTORY.EXPIRING, {
      params: { branchId, days, ...params },
    });
  },

  /**
   * Get expired stock report
   */
  getExpiredStockReport: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.REPORTS.INVENTORY.EXPIRED, {
      params: { branchId, ...params },
    });
  },

  /**
   * Get inventory summary
   */
  getInventorySummary: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.INVENTORY.SUMMARY, {
      params: { branchId },
    });
  },

  /**
   * Get dead stock report
   */
  getDeadStock: (branchId, days = 90, params = {}) => {
    return api.get(API_ENDPOINTS.REPORTS.INVENTORY.DEAD_STOCK, {
      params: { branchId, days, ...params },
    });
  },

  // ===================
  // FINANCIAL REPORTS
  // ===================

  /**
   * Get total revenue
   */
  getRevenue: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.FINANCIAL.REVENUE, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get daily revenue breakdown
   */
  getDailyRevenue: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.FINANCIAL.DAILY_REVENUE, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get profit/loss report
   */
  getProfitLoss: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.FINANCIAL.PROFIT_LOSS, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get cash flow report
   */
  getCashFlow: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.FINANCIAL.CASH_FLOW, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get total receivables
   */
  getReceivables: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.FINANCIAL.RECEIVABLES, {
      params: { branchId },
    });
  },

  /**
   * Get ageing analysis
   */
  getAgeingReport: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.FINANCIAL.AGEING, {
      params: { branchId },
    });
  },

  /**
   * Get tax summary
   */
  getTaxSummary: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.REPORTS.FINANCIAL.TAX, {
      params: { branchId, startDate, endDate },
    });
  },

  // ===================
  // ALERTS
  // ===================

  /**
   * Get all alerts
   */
  getAlerts: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.REPORTS.ALERTS.ALL, {
      params: { branchId, ...params },
    });
  },

  /**
   * Get alert count
   */
  getAlertCount: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.ALERTS.COUNT, {
      params: { branchId },
    });
  },

  /**
   * Get low stock alerts
   */
  getLowStockAlerts: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.ALERTS.LOW_STOCK, {
      params: { branchId },
    });
  },

  /**
   * Get expiry alerts
   */
  getExpiryAlerts: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.ALERTS.EXPIRY, {
      params: { branchId },
    });
  },

  /**
   * Get overdue invoice alerts
   */
  getOverdueAlerts: (branchId) => {
    return api.get(API_ENDPOINTS.REPORTS.ALERTS.OVERDUE, {
      params: { branchId },
    });
  },

  /**
   * Acknowledge alert
   */
  acknowledgeAlert: (alertId) => {
    return api.post(API_ENDPOINTS.REPORTS.ALERTS.ACKNOWLEDGE(alertId));
  },
};

export default reportService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\saleService.js"   & echo.. 
/**
 * Sale Service
 * API calls for sales and POS management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const saleService = {
  /**
   * Get all sales (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "createdAt,desc", ...filters } = params;
    return api.get(API_ENDPOINTS.SALES.BASE, {
      params: { page, size, sort, ...filters },
    });
  },

  /**
   * Get sale by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.SALES.BY_ID(id));
  },

  /**
   * Get sale by sale number
   */
  getBySaleNumber: (saleNumber) => {
    return api.get(API_ENDPOINTS.SALES.BY_NUMBER(saleNumber));
  },

  /**
   * Get sales by branch
   */
  getByBranch: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.SALES.BY_BRANCH(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get sales by customer
   */
  getByCustomer: (customerId, params = {}) => {
    return api.get(API_ENDPOINTS.SALES.BY_CUSTOMER(customerId), {
      params: { ...params },
    });
  },

  /**
   * Get sales by date range
   */
  getByDateRange: (startDate, endDate, params = {}) => {
    return api.get(API_ENDPOINTS.SALES.BY_DATE_RANGE, {
      params: { startDate, endDate, ...params },
    });
  },

  /**
   * Create new sale
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.SALES.BASE, data);
  },

  /**
   * Cancel sale
   */
  cancel: (id, reason) => {
    return api.post(API_ENDPOINTS.SALES.CANCEL(id), { reason });
  },

  /**
   * Void sale (admin only)
   */
  void: (id, reason) => {
    return api.post(API_ENDPOINTS.SALES.VOID(id), { reason });
  },

  /**
   * Get total sales amount
   */
  getTotalAmount: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.SALES.TOTAL_AMOUNT, {
      params: { branchId, startDate, endDate },
    });
  },

  /**
   * Get sales count
   */
  getCount: (branchId, startDate, endDate) => {
    return api.get(API_ENDPOINTS.SALES.COUNT, {
      params: { branchId, startDate, endDate },
    });
  },
};

/**
 * Sale Returns Service
 */
export const saleReturnService = {
  /**
   * Get all returns (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "createdAt,desc" } = params;
    return api.get(API_ENDPOINTS.SALE_RETURNS.BASE, {
      params: { page, size, sort },
    });
  },

  /**
   * Get return by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.SALE_RETURNS.BY_ID(id));
  },

  /**
   * Get returns by customer
   */
  getByCustomer: (customerId, params = {}) => {
    return api.get(API_ENDPOINTS.SALE_RETURNS.BY_CUSTOMER(customerId), {
      params: { ...params },
    });
  },

  /**
   * Get returns by branch
   */
  getByBranch: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.SALE_RETURNS.BY_BRANCH(branchId), {
      params: { ...params },
    });
  },

  /**
   * Create return
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.SALE_RETURNS.BASE, data);
  },

  /**
   * Delete return (admin only)
   */
  delete: (id) => {
    return api.delete(API_ENDPOINTS.SALE_RETURNS.BY_ID(id));
  },
};

/**
 * Invoice Service
 */
export const invoiceService = {
  /**
   * Get all invoices (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "createdAt,desc" } = params;
    return api.get(API_ENDPOINTS.INVOICES.BASE, {
      params: { page, size, sort },
    });
  },

  /**
   * Get invoice by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.INVOICES.BY_ID(id));
  },

  /**
   * Get invoices by customer
   */
  getByCustomer: (customerId, params = {}) => {
    return api.get(API_ENDPOINTS.INVOICES.BY_CUSTOMER(customerId), {
      params: { ...params },
    });
  },

  /**
   * Get invoices by status
   */
  getByStatus: (status, params = {}) => {
    return api.get(API_ENDPOINTS.INVOICES.BY_STATUS(status), {
      params: { ...params },
    });
  },

  /**
   * Get overdue invoices
   */
  getOverdue: (params = {}) => {
    return api.get(API_ENDPOINTS.INVOICES.OVERDUE, {
      params: { ...params },
    });
  },

  /**
   * Record payment
   */
  recordPayment: (id, data) => {
    return api.post(API_ENDPOINTS.INVOICES.RECORD_PAYMENT(id), data);
  },

  /**
   * Get outstanding by customer
   */
  getOutstandingByCustomer: (customerId) => {
    return api.get(API_ENDPOINTS.INVOICES.OUTSTANDING_BY_CUSTOMER(customerId));
  },
};

export default saleService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\supplierService.js"   & echo.. 
/**
 * Supplier Service
 * API calls for supplier management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const supplierService = {
  /**
   * Get all suppliers (paginated)
   */
  getAll: (params = {}) => {
    const {
      page = 0,
      size = 10,
      sort = "supplierName,asc",
      ...filters
    } = params;
    return api.get(API_ENDPOINTS.SUPPLIERS.BASE, {
      params: { page, size, sort, ...filters },
    });
  },

  /**
   * Get supplier by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.SUPPLIERS.BY_ID(id));
  },

  /**
   * Get supplier by code
   */
  getByCode: (code) => {
    return api.get(API_ENDPOINTS.SUPPLIERS.BY_CODE(code));
  },

  /**
   * Search suppliers
   */
  search: (query, params = {}) => {
    return api.get(API_ENDPOINTS.SUPPLIERS.SEARCH, {
      params: { query, ...params },
    });
  },

  /**
   * Get active suppliers
   */
  getActive: () => {
    return api.get(API_ENDPOINTS.SUPPLIERS.ACTIVE);
  },

  /**
   * Create new supplier
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.SUPPLIERS.BASE, data);
  },

  /**
   * Update supplier
   */
  update: (id, data) => {
    return api.put(API_ENDPOINTS.SUPPLIERS.BY_ID(id), data);
  },

  /**
   * Delete supplier (soft delete)
   */
  delete: (id) => {
    return api.delete(API_ENDPOINTS.SUPPLIERS.BY_ID(id));
  },

  /**
   * Activate supplier
   */
  activate: (id) => {
    return api.patch(API_ENDPOINTS.SUPPLIERS.ACTIVATE(id));
  },

  /**
   * Deactivate supplier
   */
  deactivate: (id) => {
    return api.patch(API_ENDPOINTS.SUPPLIERS.DEACTIVATE(id));
  },
};

export default supplierService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\systemConfigService.js"   & echo.. 
/**
 * System Config Service
 * API calls for system configuration management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const systemConfigService = {
  /**
   * Get all system configurations
   */
  getAll: () => {
    return api.get(API_ENDPOINTS.SYSTEM_CONFIG.BASE);
  },

  /**
   * Get configuration by key
   */
  getByKey: (key) => {
    return api.get(API_ENDPOINTS.SYSTEM_CONFIG.BY_KEY(key));
  },

  /**
   * Get configurations by category
   */
  getByCategory: (category) => {
    return api.get(API_ENDPOINTS.SYSTEM_CONFIG.BASE, {
      params: { category },
    });
  },

  /**
   * Update configuration value
   */
  update: (key, value) => {
    return api.put(API_ENDPOINTS.SYSTEM_CONFIG.BY_KEY(key), { value });
  },

  /**
   * Batch update configurations
   */
  batchUpdate: (configs) => {
    return api.put(API_ENDPOINTS.SYSTEM_CONFIG.BASE, configs);
  },
};

export default systemConfigService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\services\userService.js"   & echo.. 
/**
 * User Service
 * API calls for user management
 */

import api from "@/utils/api";
import { API_ENDPOINTS } from "@/config";

export const userService = {
  /**
   * Get all users (paginated)
   */
  getAll: (params = {}) => {
    const { page = 0, size = 10, sort = "username,asc", ...filters } = params;
    return api.get(API_ENDPOINTS.USERS.BASE, {
      params: { page, size, sort, ...filters },
    });
  },

  /**
   * Get user by ID
   */
  getById: (id) => {
    return api.get(API_ENDPOINTS.USERS.BY_ID(id));
  },

  /**
   * Get user by username
   */
  getByUsername: (username) => {
    return api.get(API_ENDPOINTS.USERS.BY_USERNAME(username));
  },

  /**
   * Get users by role
   */
  getByRole: (role, params = {}) => {
    return api.get(API_ENDPOINTS.USERS.BY_ROLE(role), {
      params: { ...params },
    });
  },

  /**
   * Get users by branch
   */
  getByBranch: (branchId, params = {}) => {
    return api.get(API_ENDPOINTS.USERS.BY_BRANCH(branchId), {
      params: { ...params },
    });
  },

  /**
   * Get active users
   */
  getActive: () => {
    return api.get(API_ENDPOINTS.USERS.ACTIVE);
  },

  /**
   * Create new user
   */
  create: (data) => {
    return api.post(API_ENDPOINTS.USERS.BASE, data);
  },

  /**
   * Update user
   */
  update: (id, data) => {
    return api.put(API_ENDPOINTS.USERS.BY_ID(id), data);
  },

  /**
   * Delete user (soft delete)
   */
  delete: (id) => {
    return api.delete(API_ENDPOINTS.USERS.BY_ID(id));
  },

  /**
   * Activate user
   */
  activate: (id) => {
    return api.patch(API_ENDPOINTS.USERS.ACTIVATE(id));
  },

  /**
   * Deactivate user
   */
  deactivate: (id) => {
    return api.patch(API_ENDPOINTS.USERS.DEACTIVATE(id));
  },

  /**
   * Reset password
   */
  resetPassword: (id, newPassword) => {
    return api.patch(API_ENDPOINTS.USERS.RESET_PASSWORD(id), { newPassword });
  },
};

export default userService;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\store\authStore.js"   & echo.. 
/**
 * Auth Store - Zustand store for authentication state
 */
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { API_CONFIG } from "@/config/api.config";

const initialState = {
  user: null,
  accessToken: null,
  refreshToken: null,
  isAuthenticated: false,
  isLoading: true,
  error: null,
};

export const useAuthStore = create(
  persist(
    (set, get) => ({
      ...initialState,
      isLoading: false, // Set to false by default - will be updated after hydration

      // Set user after login - accepts object { user, accessToken, refreshToken }
      setAuth: ({ user, accessToken, refreshToken }) => {
        // Store tokens in localStorage for API client
        localStorage.setItem(API_CONFIG.TOKEN.ACCESS_KEY, accessToken);
        localStorage.setItem(API_CONFIG.TOKEN.REFRESH_KEY, refreshToken);
        localStorage.setItem(API_CONFIG.TOKEN.USER_KEY, JSON.stringify(user));

        set({
          user,
          accessToken,
          refreshToken,
          isAuthenticated: true,
          isLoading: false,
          error: null,
        });
      },

      // Update user data
      setUser: (user) => {
        set({ user });
      },

      // Update tokens
      setTokens: (accessToken, refreshToken) => {
        set({ accessToken, refreshToken });
      },

      // Set loading state
      setLoading: (isLoading) => {
        set({ isLoading });
      },

      // Set error
      setError: (error) => {
        set({ error, isLoading: false });
      },

      // Clear auth state (logout)
      clearAuth: () => {
        // Clear localStorage tokens
        localStorage.removeItem(API_CONFIG.TOKEN.ACCESS_KEY);
        localStorage.removeItem(API_CONFIG.TOKEN.REFRESH_KEY);
        localStorage.removeItem(API_CONFIG.TOKEN.USER_KEY);

        set({
          ...initialState,
          isLoading: false,
        });
      },

      // Check if user has a specific role
      hasRole: (role) => {
        const { user } = get();
        return user?.role === role;
      },

      // Check if user has any of the specified roles
      hasAnyRole: (roles) => {
        const { user } = get();
        return roles.includes(user?.role);
      },

      // Get user's role
      getRole: () => {
        const { user } = get();
        return user?.role;
      },

      // Get user's branch ID
      getBranchId: () => {
        const { user } = get();
        return user?.branchId;
      },

      // Initialize auth from storage
      initializeAuth: () => {
        const token = localStorage.getItem(API_CONFIG.TOKEN.ACCESS_KEY);
        const userStr = localStorage.getItem(API_CONFIG.TOKEN.USER_KEY);

        if (token && userStr) {
          try {
            const user = JSON.parse(userStr);
            set({
              user,
              accessToken: token,
              refreshToken: localStorage.getItem(API_CONFIG.TOKEN.REFRESH_KEY),
              isAuthenticated: true,
              isLoading: false,
            });
          } catch {
            set({ ...initialState, isLoading: false });
          }
        } else {
          set({ ...initialState, isLoading: false });
        }
      },
    }),
    {
      name: "auth-storage",
      partialize: (state) => ({
        user: state.user,
        accessToken: state.accessToken,
        refreshToken: state.refreshToken,
        isAuthenticated: state.isAuthenticated,
      }),
      onRehydrateStorage: () => (state, error) => {
        // When hydration completes, set isLoading to false
        if (error) {
          console.error("Failed to rehydrate auth store:", error);
        }

        // Always set isLoading to false after hydration, whether state exists or not
        if (state) {
          state.isLoading = false;
          // Also sync tokens to localStorage for the API client
          if (state.accessToken) {
            localStorage.setItem(
              API_CONFIG.TOKEN.ACCESS_KEY,
              state.accessToken
            );
          }
          if (state.refreshToken) {
            localStorage.setItem(
              API_CONFIG.TOKEN.REFRESH_KEY,
              state.refreshToken
            );
          }
          if (state.user) {
            localStorage.setItem(
              API_CONFIG.TOKEN.USER_KEY,
              JSON.stringify(state.user)
            );
          }
        }
      },
    }
  )
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\store\branchStore.js"   & echo.. 
/**
 * Branch Store - Zustand store for selected branch state
 */
import { create } from "zustand";
import { persist } from "zustand/middleware";

const initialState = {
  selectedBranch: null,
  branches: [],
  isLoading: false,
  error: null,
};

export const useBranchStore = create(
  persist(
    (set, get) => ({
      ...initialState,

      // Set selected branch
      setSelectedBranch: (branch) => {
        set({ selectedBranch: branch });
      },

      // Set branches list
      setBranches: (branches) => {
        set({ branches });
      },

      // Set loading state
      setLoading: (isLoading) => {
        set({ isLoading });
      },

      // Set error
      setError: (error) => {
        set({ error, isLoading: false });
      },

      // Get selected branch ID
      getSelectedBranchId: () => {
        const { selectedBranch } = get();
        return selectedBranch?.id;
      },

      // Get selected branch name
      getSelectedBranchName: () => {
        const { selectedBranch } = get();
        return selectedBranch?.name || "Select Branch";
      },

      // Clear selection
      clearSelection: () => {
        set({ selectedBranch: null });
      },

      // Reset store
      reset: () => {
        set(initialState);
      },

      // Check if branch is selected
      hasBranch: () => {
        const { selectedBranch } = get();
        return selectedBranch !== null;
      },
    }),
    {
      name: "branch-storage",
      partialize: (state) => ({
        selectedBranch: state.selectedBranch,
      }),
    }
  )
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\store\cartStore.js"   & echo.. 
/**
 * Cart Store - Zustand store for POS cart state
 */
import { create } from "zustand";
import { persist } from "zustand/middleware";

const initialState = {
  items: [],
  customer: null,
  paymentMethod: "CASH",
  discount: 0,
  discountType: "percentage", // 'percentage' | 'fixed'
  notes: "",
  holdId: null,
};

export const useCartStore = create(
  persist(
    (set, get) => ({
      ...initialState,

      // Add item to cart
      addItem: (item) => {
        const { items } = get();
        const existingIndex = items.findIndex(
          (i) => i.productId === item.productId && i.batchId === item.batchId
        );

        if (existingIndex >= 0) {
          // Update quantity if item exists
          const updatedItems = [...items];
          updatedItems[existingIndex] = {
            ...updatedItems[existingIndex],
            quantity: updatedItems[existingIndex].quantity + item.quantity,
          };
          set({ items: updatedItems });
        } else {
          // Add new item
          set({ items: [...items, { ...item, id: Date.now() }] });
        }
      },

      // Remove item from cart
      removeItem: (itemId) => {
        const { items } = get();
        set({ items: items.filter((i) => i.id !== itemId) });
      },

      // Update item quantity
      updateItemQuantity: (itemId, quantity) => {
        const { items } = get();
        if (quantity <= 0) {
          set({ items: items.filter((i) => i.id !== itemId) });
        } else {
          set({
            items: items.map((i) => (i.id === itemId ? { ...i, quantity } : i)),
          });
        }
      },

      // Update item discount
      updateItemDiscount: (itemId, discount) => {
        const { items } = get();
        set({
          items: items.map((i) => (i.id === itemId ? { ...i, discount } : i)),
        });
      },

      // Set customer
      setCustomer: (customer) => {
        set({ customer });
      },

      // Set payment method
      setPaymentMethod: (paymentMethod) => {
        set({ paymentMethod });
      },

      // Set overall discount
      setDiscount: (discount, discountType = "percentage") => {
        set({ discount, discountType });
      },

      // Set notes
      setNotes: (notes) => {
        set({ notes });
      },

      // Calculate subtotal (before discount)
      getSubtotal: () => {
        const { items } = get();
        return items.reduce((total, item) => {
          const itemTotal = item.unitPrice * item.quantity;
          const itemDiscount = item.discount || 0;
          return total + (itemTotal - itemDiscount);
        }, 0);
      },

      // Calculate total discount amount
      getDiscountAmount: () => {
        const { discount, discountType } = get();
        const subtotal = get().getSubtotal();

        if (discountType === "percentage") {
          return (subtotal * discount) / 100;
        }
        return discount;
      },

      // Calculate total
      getTotal: () => {
        const subtotal = get().getSubtotal();
        const discountAmount = get().getDiscountAmount();
        return Math.max(0, subtotal - discountAmount);
      },

      // Get item count
      getItemCount: () => {
        const { items } = get();
        return items.reduce((count, item) => count + item.quantity, 0);
      },

      // Clear cart
      clearCart: () => {
        set(initialState);
      },

      // Hold current sale
      holdSale: (holdId) => {
        const state = get();
        const heldSales = JSON.parse(localStorage.getItem("heldSales") || "[]");
        heldSales.push({
          id: holdId || Date.now(),
          ...state,
          heldAt: new Date().toISOString(),
        });
        localStorage.setItem("heldSales", JSON.stringify(heldSales));
        set(initialState);
      },

      // Get held sales
      getHeldSales: () => {
        return JSON.parse(localStorage.getItem("heldSales") || "[]");
      },

      // Recall held sale
      recallSale: (holdId) => {
        const heldSales = get().getHeldSales();
        const sale = heldSales.find((s) => s.id === holdId);
        if (sale) {
          const { id, heldAt, ...saleData } = sale;
          set({ ...saleData, holdId: id });
          // Remove from held sales
          const updatedHeldSales = heldSales.filter((s) => s.id !== holdId);
          localStorage.setItem("heldSales", JSON.stringify(updatedHeldSales));
        }
      },

      // Delete held sale
      deleteHeldSale: (holdId) => {
        const heldSales = get().getHeldSales();
        const updatedHeldSales = heldSales.filter((s) => s.id !== holdId);
        localStorage.setItem("heldSales", JSON.stringify(updatedHeldSales));
      },
    }),
    {
      name: "cart-storage",
      partialize: (state) => ({
        items: state.items,
        customer: state.customer,
        paymentMethod: state.paymentMethod,
        discount: state.discount,
        discountType: state.discountType,
        notes: state.notes,
      }),
    }
  )
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\store\index.js"   & echo.. 
/**
 * Store barrel export
 */
export { useAuthStore } from "./authStore";
export { useBranchStore } from "./branchStore";
export { useCartStore } from "./cartStore";
export { useUiStore } from "./uiStore";
export { useNotificationStore } from "./notificationStore";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\store\notificationStore.js"   & echo.. 
/**
 * Notification Store - Zustand store for notifications
 */
import { create } from "zustand";

const initialState = {
  notifications: [],
  unreadCount: 0,
  isLoading: false,
  error: null,
};

export const useNotificationStore = create((set, get) => ({
  ...initialState,

  // Set notifications
  setNotifications: (notifications) => {
    const unreadCount = notifications.filter((n) => !n.read).length;
    set({ notifications, unreadCount });
  },

  // Add notification
  addNotification: (notification) => {
    const { notifications } = get();
    set({
      notifications: [notification, ...notifications],
      unreadCount: get().unreadCount + (notification.read ? 0 : 1),
    });
  },

  // Mark notification as read
  markAsRead: (notificationId) => {
    const { notifications } = get();
    const notification = notifications.find((n) => n.id === notificationId);
    if (notification && !notification.read) {
      set({
        notifications: notifications.map((n) =>
          n.id === notificationId ? { ...n, read: true } : n
        ),
        unreadCount: Math.max(0, get().unreadCount - 1),
      });
    }
  },

  // Mark all as read
  markAllAsRead: () => {
    const { notifications } = get();
    set({
      notifications: notifications.map((n) => ({ ...n, read: true })),
      unreadCount: 0,
    });
  },

  // Remove notification
  removeNotification: (notificationId) => {
    const { notifications } = get();
    const notification = notifications.find((n) => n.id === notificationId);
    set({
      notifications: notifications.filter((n) => n.id !== notificationId),
      unreadCount:
        notification && !notification.read
          ? Math.max(0, get().unreadCount - 1)
          : get().unreadCount,
    });
  },

  // Clear all notifications
  clearNotifications: () => {
    set({ notifications: [], unreadCount: 0 });
  },

  // Set loading state
  setLoading: (isLoading) => {
    set({ isLoading });
  },

  // Set error
  setError: (error) => {
    set({ error, isLoading: false });
  },

  // Get unread notifications
  getUnreadNotifications: () => {
    const { notifications } = get();
    return notifications.filter((n) => !n.read);
  },

  // Reset store
  reset: () => {
    set(initialState);
  },
}));
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\store\uiStore.js"   & echo.. 
/**
 * UI Store - Zustand store for UI state
 */
import { create } from "zustand";
import { persist } from "zustand/middleware";

const initialState = {
  sidebarCollapsed: false,
  sidebarMobileOpen: false,
  theme: "system",
  preferences: {
    themeMode: "system",
    colorTheme: "blue",
    dateFormat: "DD/MM/YYYY",
    currency: "LKR",
    highContrast: false,
    reduceMotion: false,
    largeText: false,
    screenReader: false,
    keyboardNav: "standard",
    tablePageSize: "10",
    compactTables: false,
  },
  confirmDialog: {
    open: false,
    title: "",
    message: "",
    onConfirm: null,
    onCancel: null,
    confirmText: "Confirm",
    cancelText: "Cancel",
    variant: "default",
  },
};

export const useUiStore = create(
  persist(
    (set, get) => ({
      ...initialState,

      // Toggle sidebar collapsed state
      toggleSidebar: () => {
        set((state) => ({ sidebarCollapsed: !state.sidebarCollapsed }));
      },

      // Set sidebar collapsed state
      setSidebarCollapsed: (collapsed) => {
        set({ sidebarCollapsed: collapsed });
      },

      // Toggle mobile sidebar
      toggleMobileSidebar: () => {
        set((state) => ({ sidebarMobileOpen: !state.sidebarMobileOpen }));
      },

      // Set mobile sidebar open state
      setMobileSidebarOpen: (open) => {
        set({ sidebarMobileOpen: open });
      },

      // Set theme
      setTheme: (theme) => {
        set({ theme });
        // Also update preferences.themeMode
        set((state) => ({
          preferences: { ...state.preferences, themeMode: theme }
        }));
        // Apply theme to document
        const root = document.documentElement;
        root.classList.remove("light", "dark");
        
        if (theme === "system") {
          const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
          root.classList.add(systemTheme);
        } else if (theme === "dark") {
          root.classList.add("dark");
        } else {
          root.classList.add("light");
        }
      },

      // Update preference
      updatePreference: (key, value) => {
        set((state) => ({
          preferences: { ...state.preferences, [key]: value }
        }));
        
        // If updating themeMode, also update theme
        if (key === "themeMode") {
          const { setTheme } = get();
          setTheme(value);
          return; // setTheme already handles application
        }
        
        // Apply other preferences immediately
        const root = document.documentElement;
        
        // Apply color theme
        if (key === "colorTheme") {
          root.setAttribute("data-theme", value);
        }
        
        // Apply accessibility settings
        if (key === "highContrast") root.classList.toggle("high-contrast", value);
        if (key === "reduceMotion") root.classList.toggle("reduce-motion", value);
        if (key === "largeText") root.classList.toggle("large-text", value);
        if (key === "screenReader") root.classList.toggle("screen-reader", value);
        if (key === "keyboardNav") root.setAttribute("data-keyboard-nav", value);
        if (key === "compactTables") root.classList.toggle("compact-tables", value);
      },

      // Toggle theme
      toggleTheme: () => {
        const { theme } = get();
        const newTheme = theme === "light" ? "dark" : "light";
        get().setTheme(newTheme);
      },

      // Show confirm dialog
      showConfirmDialog: ({
        title,
        message,
        onConfirm,
        onCancel,
        confirmText = "Confirm",
        cancelText = "Cancel",
        variant = "default",
      }) => {
        set({
          confirmDialog: {
            open: true,
            title,
            message,
            onConfirm,
            onCancel,
            confirmText,
            cancelText,
            variant,
          },
        });
      },

      // Hide confirm dialog
      hideConfirmDialog: () => {
        set({
          confirmDialog: {
            ...initialState.confirmDialog,
            open: false,
          },
        });
      },

      // Handle confirm dialog confirm action
      handleConfirmDialogConfirm: () => {
        const { confirmDialog } = get();
        if (confirmDialog.onConfirm) {
          confirmDialog.onConfirm();
        }
        get().hideConfirmDialog();
      },

      // Handle confirm dialog cancel action
      handleConfirmDialogCancel: () => {
        const { confirmDialog } = get();
        if (confirmDialog.onCancel) {
          confirmDialog.onCancel();
        }
        get().hideConfirmDialog();
      },
    }),
    {
      name: "ui-storage",
      partialize: (state) => ({
        sidebarCollapsed: state.sidebarCollapsed,
        theme: state.theme,
      }),
    }
  )
);
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\utils\api.js"   & echo.. 
/**
 * Axios API Client Configuration
 * Handles authentication, interceptors, and error handling
 */
import axios from "axios";
import { API_CONFIG } from "@/config/api.config";

// Create axios instance
const apiClient = axios.create({
  baseURL: API_CONFIG.BASE_URL,
  timeout: API_CONFIG.TIMEOUT,
  headers: {
    "Content-Type": API_CONFIG.HEADERS.CONTENT_TYPE,
    Accept: API_CONFIG.HEADERS.ACCEPT,
    // Skip ngrok browser warning for free tier tunnels
    "ngrok-skip-browser-warning": "true",
  },
});

// Create auth client for auth endpoints (different base URL)
export const authClient = axios.create({
  baseURL: API_CONFIG.AUTH_URL,
  timeout: API_CONFIG.TIMEOUT,
  headers: {
    "Content-Type": API_CONFIG.HEADERS.CONTENT_TYPE,
    Accept: API_CONFIG.HEADERS.ACCEPT,
    // Skip ngrok browser warning for free tier tunnels
    "ngrok-skip-browser-warning": "true",
  },
});

// Token management
const getAccessToken = () => localStorage.getItem(API_CONFIG.TOKEN.ACCESS_KEY);
const getRefreshToken = () =>
  localStorage.getItem(API_CONFIG.TOKEN.REFRESH_KEY);

// Request interceptor - Add auth token
const addAuthToken = (config) => {
  const token = getAccessToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
};

apiClient.interceptors.request.use(addAuthToken, (error) =>
  Promise.reject(error)
);
authClient.interceptors.request.use(addAuthToken, (error) =>
  Promise.reject(error)
);

// Flag to prevent multiple refresh attempts
let isRefreshing = false;
let failedQueue = [];

const processQueue = (error, token = null) => {
  failedQueue.forEach((prom) => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

// Response interceptor - Handle token refresh
const responseInterceptor = (response) => response;

const errorInterceptor = async (error) => {
  const originalRequest = error.config;

  // If error is 401 and we haven't retried yet
  if (error.response?.status === 401 && !originalRequest._retry) {
    if (isRefreshing) {
      // Queue the request while refreshing
      return new Promise((resolve, reject) => {
        failedQueue.push({ resolve, reject });
      })
        .then((token) => {
          originalRequest.headers.Authorization = `Bearer ${token}`;
          return apiClient(originalRequest);
        })
        .catch((err) => Promise.reject(err));
    }

    originalRequest._retry = true;
    isRefreshing = true;

    const refreshToken = getRefreshToken();

    if (!refreshToken) {
      // No refresh token, redirect to login
      isRefreshing = false;
      window.location.href = "/login";
      return Promise.reject(error);
    }

    try {
      const response = await authClient.post("/auth/refresh", {
        refreshToken,
      });

      const { accessToken, refreshToken: newRefreshToken } = response.data.data;

      localStorage.setItem(API_CONFIG.TOKEN.ACCESS_KEY, accessToken);
      if (newRefreshToken) {
        localStorage.setItem(API_CONFIG.TOKEN.REFRESH_KEY, newRefreshToken);
      }

      processQueue(null, accessToken);

      originalRequest.headers.Authorization = `Bearer ${accessToken}`;
      return apiClient(originalRequest);
    } catch (refreshError) {
      processQueue(refreshError, null);
      // Clear tokens and redirect to login
      localStorage.removeItem(API_CONFIG.TOKEN.ACCESS_KEY);
      localStorage.removeItem(API_CONFIG.TOKEN.REFRESH_KEY);
      localStorage.removeItem(API_CONFIG.TOKEN.USER_KEY);
      window.location.href = "/login";
      return Promise.reject(refreshError);
    } finally {
      isRefreshing = false;
    }
  }

  // Handle other errors
  if (error.response?.status === 403) {
    // Check if it's an authentication issue (expired/invalid token)
    const errorMessage = error.response?.data?.message || "";
    const isAuthError = 
      errorMessage.includes("Access Denied") || 
      errorMessage.includes("token") ||
      errorMessage.includes("authentication");
    
    if (isAuthError && getAccessToken()) {
      // Clear tokens and redirect to login
      console.error("Authentication expired. Redirecting to login...");
      localStorage.removeItem(API_CONFIG.TOKEN.ACCESS_KEY);
      localStorage.removeItem(API_CONFIG.TOKEN.REFRESH_KEY);
      localStorage.removeItem(API_CONFIG.TOKEN.USER_KEY);
      window.location.href = "/login";
      return Promise.reject(error);
    }
    
    // Other forbidden errors - let component handle
    console.error("Forbidden (403):", error.response?.data);
  }

  // Handle 500 errors - log but don't redirect
  if (error.response?.status === 500) {
    console.error("Server Error (500):", error.response?.data);
  }

  return Promise.reject(error);
};

apiClient.interceptors.response.use(responseInterceptor, errorInterceptor);
authClient.interceptors.response.use(responseInterceptor, errorInterceptor);

// API helper methods
export const api = {
  get: (url, config) => apiClient.get(url, config),
  post: (url, data, config) => apiClient.post(url, data, config),
  put: (url, data, config) => apiClient.put(url, data, config),
  patch: (url, data, config) => apiClient.patch(url, data, config),
  delete: (url, config) => apiClient.delete(url, config),
};

// Extract data from API response
export const extractData = (response) => response.data?.data || response.data;

// Extract error message from API error
export const extractErrorMessage = (error) => {
  if (error.response?.data?.message) {
    return error.response.data.message;
  }
  if (error.response?.data?.error) {
    return error.response.data.error;
  }
  if (error.message) {
    return error.message;
  }
  return "An unexpected error occurred";
};

export { apiClient };
export default apiClient;
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\utils\auth.js"   & echo.. 
/**
 * Authentication Utilities
 * Token management and auth state helpers
 */
import { API_CONFIG } from "@/config/api.config";

/**
 * Get access token from storage
 */
export const getAccessToken = () => {
  return localStorage.getItem(API_CONFIG.TOKEN.ACCESS_KEY);
};

/**
 * Get refresh token from storage
 */
export const getRefreshToken = () => {
  return localStorage.getItem(API_CONFIG.TOKEN.REFRESH_KEY);
};

/**
 * Get stored user data
 */
export const getStoredUser = () => {
  const userStr = localStorage.getItem(API_CONFIG.TOKEN.USER_KEY);
  if (userStr) {
    try {
      return JSON.parse(userStr);
    } catch {
      return null;
    }
  }
  return null;
};

/**
 * Set auth tokens in storage
 */
export const setTokens = (accessToken, refreshToken) => {
  if (accessToken) {
    localStorage.setItem(API_CONFIG.TOKEN.ACCESS_KEY, accessToken);
  }
  if (refreshToken) {
    localStorage.setItem(API_CONFIG.TOKEN.REFRESH_KEY, refreshToken);
  }
};

/**
 * Set user data in storage
 */
export const setStoredUser = (user) => {
  if (user) {
    localStorage.setItem(API_CONFIG.TOKEN.USER_KEY, JSON.stringify(user));
  }
};

/**
 * Clear all auth data from storage
 */
export const clearAuth = () => {
  localStorage.removeItem(API_CONFIG.TOKEN.ACCESS_KEY);
  localStorage.removeItem(API_CONFIG.TOKEN.REFRESH_KEY);
  localStorage.removeItem(API_CONFIG.TOKEN.USER_KEY);
};

/**
 * Check if user is authenticated
 */
export const isAuthenticated = () => {
  const token = getAccessToken();
  if (!token) return false;

  // Check if token is expired
  try {
    const payload = JSON.parse(atob(token.split(".")[1]));
    const exp = payload.exp * 1000; // Convert to milliseconds
    return Date.now() < exp;
  } catch {
    return false;
  }
};

/**
 * Get token expiration time
 */
export const getTokenExpiration = () => {
  const token = getAccessToken();
  if (!token) return null;

  try {
    const payload = JSON.parse(atob(token.split(".")[1]));
    return payload.exp * 1000; // Convert to milliseconds
  } catch {
    return null;
  }
};

/**
 * Check if token needs refresh
 * Returns true if token expires within threshold
 */
export const shouldRefreshToken = (thresholdMs = 5 * 60 * 1000) => {
  const expiration = getTokenExpiration();
  if (!expiration) return false;

  return expiration - Date.now() < thresholdMs;
};

/**
 * Parse JWT token payload
 */
export const parseToken = (token) => {
  if (!token) return null;

  try {
    const payload = JSON.parse(atob(token.split(".")[1]));
    return payload;
  } catch {
    return null;
  }
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\utils\exportImport.js"   & echo.. 
/**
 * Export/Import Utilities
 * Helper functions for exporting data to CSV/Excel and importing data
 */

/**
 * Convert JSON array to CSV string
 */
export const jsonToCSV = (data, headers = null) => {
  if (!data || data.length === 0) {
    return "";
  }

  // Extract headers from first object if not provided
  const csvHeaders = headers || Object.keys(data[0]);

  // Create header row
  const headerRow = csvHeaders.join(",");

  // Create data rows
  const dataRows = data.map((row) => {
    return csvHeaders
      .map((header) => {
        let value = row[header];

        // Handle nested objects (e.g., category.categoryName)
        if (header.includes(".")) {
          const keys = header.split(".");
          value = keys.reduce((obj, key) => obj?.[key], row);
        }

        // Handle null/undefined
        if (value === null || value === undefined) {
          return "";
        }

        // Handle objects/arrays
        if (typeof value === "object") {
          value = JSON.stringify(value);
        }

        // Escape quotes and wrap in quotes if contains comma, newline, or quote
        value = String(value).replace(/"/g, '""');
        if (
          value.includes(",") ||
          value.includes("\n") ||
          value.includes('"')
        ) {
          return `"${value}"`;
        }

        return value;
      })
      .join(",");
  });

  return [headerRow, ...dataRows].join("\n");
};

/**
 * Download data as CSV file
 */
export const downloadCSV = (data, filename = "export.csv", headers = null) => {
  const csv = jsonToCSV(data, headers);
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  downloadBlob(blob, filename);
};

/**
 * Download data as JSON file
 */
export const downloadJSON = (data, filename = "export.json") => {
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: "application/json;charset=utf-8;" });
  downloadBlob(blob, filename);
};

/**
 * Download blob as file
 */
const downloadBlob = (blob, filename) => {
  const link = document.createElement("a");
  const url = URL.createObjectURL(blob);
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

/**
 * Parse CSV string to JSON array
 */
export const csvToJSON = (csv) => {
  const lines = csv.split("\n").filter((line) => line.trim());

  if (lines.length === 0) {
    return [];
  }

  // Parse header
  const headers = parseCSVLine(lines[0]);

  // Parse data rows
  const data = [];
  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i]);
    if (values.length === headers.length) {
      const row = {};
      headers.forEach((header, index) => {
        row[header] = values[index];
      });
      data.push(row);
    }
  }

  return data;
};

/**
 * Parse a single CSV line handling quoted values
 */
const parseCSVLine = (line) => {
  const result = [];
  let current = "";
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    const nextChar = line[i + 1];

    if (char === '"') {
      if (inQuotes && nextChar === '"') {
        // Escaped quote
        current += '"';
        i++; // Skip next quote
      } else {
        // Toggle quote state
        inQuotes = !inQuotes;
      }
    } else if (char === "," && !inQuotes) {
      // End of field
      result.push(current);
      current = "";
    } else {
      current += char;
    }
  }

  // Add last field
  result.push(current);

  return result;
};

/**
 * Read file as text
 */
export const readFileAsText = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target.result);
    reader.onerror = (e) => reject(e);
    reader.readAsText(file);
  });
};

/**
 * Validate CSV file structure
 */
export const validateCSV = (data, requiredFields = []) => {
  if (!data || data.length === 0) {
    return { valid: false, error: "File is empty" };
  }

  const headers = Object.keys(data[0]);

  // Check for required fields
  const missingFields = requiredFields.filter(
    (field) => !headers.includes(field)
  );

  if (missingFields.length > 0) {
    return {
      valid: false,
      error: `Missing required fields: ${missingFields.join(", ")}`,
    };
  }

  return { valid: true };
};

/**
 * Download data from API response
 * Handles both direct data and blob responses
 */
export const downloadFromResponse = (response, filename) => {
  // If response is a blob
  if (response.data instanceof Blob) {
    downloadBlob(response.data, filename);
    return;
  }

  // If response contains file data
  if (response.headers["content-type"]?.includes("text/csv")) {
    const blob = new Blob([response.data], { type: "text/csv;charset=utf-8;" });
    downloadBlob(blob, filename);
    return;
  }

  // Default to JSON download
  downloadJSON(response.data, filename);
};

/**
 * Create FormData for file upload
 */
export const createFileFormData = (file, fieldName = "file", additionalData = {}) => {
  const formData = new FormData();
  formData.append(fieldName, file);

  // Add additional data
  Object.keys(additionalData).forEach((key) => {
    const value = additionalData[key];
    if (value !== null && value !== undefined) {
      formData.append(key, typeof value === "object" ? JSON.stringify(value) : value);
    }
  });

  return formData;
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\utils\formatters.js"   & echo.. 
/**
 * Formatters
 * Date, currency, number, and text formatting utilities
 */
import {
  format,
  formatDistance,
  formatRelative,
  isValid,
  parseISO,
} from "date-fns";
import { APP_CONFIG } from "@/config/app.config";

// ============================================
// DATE FORMATTERS
// ============================================

/**
 * Format date to display format
 * @param {string|Date} date - Date to format
 * @param {string} formatStr - Format string (default from config)
 * @returns {string} Formatted date
 */
export const formatDate = (date, formatStr = APP_CONFIG.LOCALE.DATE_FORMAT) => {
  if (!date) return "-";
  const dateObj = typeof date === "string" ? parseISO(date) : date;
  if (!isValid(dateObj)) return "-";
  return format(dateObj, formatStr);
};

/**
 * Format date and time
 * @param {string|Date} date - Date to format
 * @returns {string} Formatted date and time
 */
export const formatDateTime = (date) => {
  return formatDate(date, APP_CONFIG.LOCALE.DATETIME_FORMAT);
};

/**
 * Format time only
 * @param {string|Date} date - Date to format
 * @returns {string} Formatted time
 */
export const formatTime = (date) => {
  return formatDate(date, APP_CONFIG.LOCALE.TIME_FORMAT);
};

/**
 * Format date as relative time (e.g., "2 hours ago")
 * @param {string|Date} date - Date to format
 * @returns {string} Relative time string
 */
export const formatRelativeTime = (date) => {
  if (!date) return "-";
  const dateObj = typeof date === "string" ? parseISO(date) : date;
  if (!isValid(dateObj)) return "-";
  return formatDistance(dateObj, new Date(), { addSuffix: true });
};

/**
 * Format date for API (ISO format)
 * @param {Date} date - Date to format
 * @returns {string} ISO date string
 */
export const formatDateForApi = (date) => {
  if (!date || !isValid(date)) return null;
  return format(date, "yyyy-MM-dd");
};

/**
 * Format datetime for API (ISO format)
 * @param {Date} date - Date to format
 * @returns {string} ISO datetime string
 */
export const formatDateTimeForApi = (date) => {
  if (!date || !isValid(date)) return null;
  return date.toISOString();
};

// ============================================
// CURRENCY FORMATTERS
// ============================================

/**
 * Format number as currency
 * @param {number} amount - Amount to format
 * @param {string} currency - Currency code (default from config)
 * @returns {string} Formatted currency string
 */
export const formatCurrency = (
  amount,
  currency = APP_CONFIG.LOCALE.CURRENCY
) => {
  if (amount === null || amount === undefined) return "-";

  const formatter = new Intl.NumberFormat("en-LK", {
    style: "currency",
    currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });

  return formatter.format(amount);
};

/**
 * Format currency without symbol
 * @param {number} amount - Amount to format
 * @returns {string} Formatted number string
 */
export const formatAmount = (amount) => {
  if (amount === null || amount === undefined) return "-";

  return new Intl.NumberFormat("en-LK", {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
};

// ============================================
// NUMBER FORMATTERS
// ============================================

/**
 * Format number with thousand separators
 * @param {number} num - Number to format
 * @param {number} decimals - Decimal places
 * @returns {string} Formatted number
 */
export const formatNumber = (num, decimals = 0) => {
  if (num === null || num === undefined) return "-";

  return new Intl.NumberFormat("en-LK", {
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals,
  }).format(num);
};

/**
 * Format percentage
 * @param {number} value - Value to format (0.15 = 15%)
 * @param {number} decimals - Decimal places
 * @returns {string} Formatted percentage
 */
export const formatPercent = (value, decimals = 1) => {
  if (value === null || value === undefined) return "-";

  return new Intl.NumberFormat("en-LK", {
    style: "percent",
    minimumFractionDigits: decimals,
    maximumFractionDigits: decimals,
  }).format(value);
};

/**
 * Format as compact number (e.g., 1K, 1M)
 * @param {number} num - Number to format
 * @returns {string} Compact number
 */
export const formatCompact = (num) => {
  if (num === null || num === undefined) return "-";

  return new Intl.NumberFormat("en", {
    notation: "compact",
    maximumFractionDigits: 1,
  }).format(num);
};

// ============================================
// TEXT FORMATTERS
// ============================================

/**
 * Capitalize first letter
 * @param {string} str - String to capitalize
 * @returns {string} Capitalized string
 */
export const capitalize = (str) => {
  if (!str) return "";
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
};

/**
 * Convert to title case
 * @param {string} str - String to convert
 * @returns {string} Title case string
 */
export const toTitleCase = (str) => {
  if (!str) return "";
  return str
    .toLowerCase()
    .split(" ")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(" ");
};

/**
 * Truncate text with ellipsis
 * @param {string} str - String to truncate
 * @param {number} maxLength - Maximum length
 * @returns {string} Truncated string
 */
export const truncate = (str, maxLength = 50) => {
  if (!str) return "";
  if (str.length <= maxLength) return str;
  return str.slice(0, maxLength) + "...";
};

/**
 * Format phone number
 * @param {string} phone - Phone number
 * @returns {string} Formatted phone number
 */
export const formatPhone = (phone) => {
  if (!phone) return "-";
  // Remove all non-digits
  const cleaned = phone.replace(/\D/g, "");
  // Format based on length (Sri Lankan format)
  if (cleaned.length === 10) {
    return `${cleaned.slice(0, 3)} ${cleaned.slice(3, 6)} ${cleaned.slice(6)}`;
  }
  return phone;
};

/**
 * Mask email address
 * @param {string} email - Email to mask
 * @returns {string} Masked email
 */
export const maskEmail = (email) => {
  if (!email) return "-";
  const [localPart, domain] = email.split("@");
  if (!domain) return email;
  const maskedLocal = localPart.slice(0, 2) + "***";
  return `${maskedLocal}@${domain}`;
};

// ============================================
// INVENTORY FORMATTERS
// ============================================

/**
 * Format batch number
 * @param {string} batchNumber - Batch number
 * @returns {string} Formatted batch number
 */
export const formatBatchNumber = (batchNumber) => {
  return batchNumber || "-";
};

/**
 * Format quantity with unit
 * @param {number} quantity - Quantity
 * @param {string} unit - Unit of measure
 * @returns {string} Formatted quantity with unit
 */
export const formatQuantity = (quantity, unit = "") => {
  if (quantity === null || quantity === undefined) return "-";
  return `${formatNumber(quantity)} ${unit}`.trim();
};

/**
 * Format expiry date with status color class
 * @param {string|Date} expiryDate - Expiry date
 * @returns {object} { formatted, status, colorClass }
 */
export const formatExpiryDate = (expiryDate) => {
  if (!expiryDate) return { formatted: "-", status: "unknown", colorClass: "" };

  const date =
    typeof expiryDate === "string" ? parseISO(expiryDate) : expiryDate;
  if (!isValid(date))
    return { formatted: "-", status: "unknown", colorClass: "" };

  const now = new Date();
  const daysUntilExpiry = Math.ceil(
    (date.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
  );

  let status = "valid";
  let colorClass = "text-green-600";

  if (daysUntilExpiry < 0) {
    status = "expired";
    colorClass = "text-red-600 font-semibold";
  } else if (daysUntilExpiry <= APP_CONFIG.INVENTORY.EXPIRY_CRITICAL_DAYS) {
    status = "critical";
    colorClass = "text-orange-600 font-semibold";
  } else if (daysUntilExpiry <= APP_CONFIG.INVENTORY.EXPIRY_WARNING_DAYS) {
    status = "warning";
    colorClass = "text-yellow-600";
  }

  return {
    formatted: formatDate(date),
    status,
    colorClass,
    daysUntilExpiry,
  };
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\utils\index.js"   & echo.. 
/**
 * Utilities barrel export
 */

export * from "./api";
export * from "./auth";
export * from "./storage";
export * from "./formatters";
export * from "./validators";
export * from "./permissions";
export * from "./exportImport";
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\utils\permissions.js"   & echo.. 
/**
 * Permission Utilities
 * Helper functions for role-based access control
 */
import {
  PERMISSIONS,
  hasPermission as checkPermission,
} from "@/constants/permissions";
import { ROLES, ROLE_HIERARCHY } from "@/constants/roles";

/**
 * Check if user has permission for a feature action
 * @param {object} user - User object with role
 * @param {string} feature - Feature name
 * @param {string} action - Action name
 * @returns {boolean}
 */
export const hasPermission = (user, feature, action) => {
  if (!user?.role) return false;
  return checkPermission(user.role, feature, action);
};

/**
 * Check if user has any of the specified roles
 * @param {object} user - User object with role
 * @param {string[]} roles - Array of role names
 * @returns {boolean}
 */
export const hasAnyRole = (user, roles) => {
  if (!user?.role) return false;
  return roles.includes(user.role);
};

/**
 * Check if user has all of the specified roles
 * @param {object} user - User object with role
 * @param {string[]} roles - Array of role names
 * @returns {boolean}
 */
export const hasAllRoles = (user, roles) => {
  if (!user?.role) return false;
  // Single role per user, so this checks if user's role is in all required roles
  return roles.every((role) => role === user.role);
};

/**
 * Check if user's role is at least as high as the specified role
 * @param {object} user - User object with role
 * @param {string} minimumRole - Minimum required role
 * @returns {boolean}
 */
export const hasMinimumRole = (user, minimumRole) => {
  if (!user?.role) return false;
  const userLevel = ROLE_HIERARCHY[user.role] || 0;
  const requiredLevel = ROLE_HIERARCHY[minimumRole] || 0;
  return userLevel >= requiredLevel;
};

/**
 * Check if user is super admin
 * @param {object} user - User object with role
 * @returns {boolean}
 */
export const isSuperAdmin = (user) => {
  return user?.role === ROLES.SUPER_ADMIN;
};

/**
 * Check if user is admin or super admin
 * @param {object} user - User object with role
 * @returns {boolean}
 */
export const isAdmin = (user) => {
  return hasAnyRole(user, [ROLES.SUPER_ADMIN, ROLES.ADMIN]);
};

/**
 * Check if user can access POS
 * @param {object} user - User object with role
 * @returns {boolean}
 */
export const canAccessPOS = (user) => {
  return hasAnyRole(user, [
    ROLES.PHARMACIST,
    ROLES.CASHIER,
    ROLES.BRANCH_MANAGER,
    ROLES.ADMIN,
    ROLES.SUPER_ADMIN,
  ]);
};

/**
 * Check if user can manage inventory
 * @param {object} user - User object with role
 * @returns {boolean}
 */
export const canManageInventory = (user) => {
  return hasPermission(user, "inventory", "adjust");
};

/**
 * Check if user can approve orders
 * @param {object} user - User object with role
 * @returns {boolean}
 */
export const canApproveOrders = (user) => {
  return hasPermission(user, "purchaseOrders", "approve");
};

/**
 * Get maximum discount percentage for user
 * @param {object} user - User object with role
 * @returns {number}
 */
export const getMaxDiscount = (user) => {
  if (!user?.role) return 0;
  return PERMISSIONS[user.role]?.sales?.discount || 0;
};

/**
 * Check if user can give credit
 * @param {object} user - User object with role
 * @returns {boolean}
 */
export const canGiveCredit = (user) => {
  if (!user?.role) return false;
  return PERMISSIONS[user.role]?.sales?.credit || false;
};

/**
 * Get credit limit for user
 * @param {object} user - User object with role
 * @returns {number}
 */
export const getCreditLimit = (user) => {
  if (!user?.role) return 0;
  return PERMISSIONS[user.role]?.sales?.creditLimit || 0;
};

/**
 * Get all permissions for a role
 * @param {string} role - Role name
 * @returns {object} Permission object
 */
export const getRolePermissions = (role) => {
  return PERMISSIONS[role] || {};
};

/**
 * Get accessible features for a role
 * @param {string} role - Role name
 * @returns {string[]} Array of feature names user can view
 */
export const getAccessibleFeatures = (role) => {
  const permissions = PERMISSIONS[role];
  if (!permissions) return [];

  return Object.entries(permissions)
    .filter(([_, perms]) => perms.view)
    .map(([feature]) => feature);
};

/**
 * Filter navigation items based on user permissions
 * @param {object[]} navItems - Navigation items with roles array
 * @param {object} user - User object with role
 * @returns {object[]} Filtered navigation items
 */
export const filterNavByPermissions = (navItems, user) => {
  if (!user?.role) return [];

  return navItems
    .filter((item) => {
      if (item.roles && !item.roles.includes(user.role)) {
        return false;
      }
      if (item.feature && item.action) {
        return hasPermission(user, item.feature, item.action);
      }
      return true;
    })
    .map((item) => {
      if (item.children) {
        return {
          ...item,
          children: filterNavByPermissions(item.children, user),
        };
      }
      return item;
    });
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\utils\storage.js"   & echo.. 
/**
 * Local Storage Utilities
 * Typed storage helpers with JSON serialization
 */

/**
 * Get item from localStorage with JSON parsing
 * @param {string} key - Storage key
 * @param {*} defaultValue - Default value if key doesn't exist
 * @returns {*} Parsed value or default
 */
export const getItem = (key, defaultValue = null) => {
  try {
    const item = localStorage.getItem(key);
    if (item === null) return defaultValue;
    return JSON.parse(item);
  } catch {
    return defaultValue;
  }
};

/**
 * Set item in localStorage with JSON serialization
 * @param {string} key - Storage key
 * @param {*} value - Value to store
 */
export const setItem = (key, value) => {
  try {
    localStorage.setItem(key, JSON.stringify(value));
  } catch (error) {
    console.error("Error saving to localStorage:", error);
  }
};

/**
 * Remove item from localStorage
 * @param {string} key - Storage key
 */
export const removeItem = (key) => {
  try {
    localStorage.removeItem(key);
  } catch (error) {
    console.error("Error removing from localStorage:", error);
  }
};

/**
 * Clear all localStorage
 */
export const clearAll = () => {
  try {
    localStorage.clear();
  } catch (error) {
    console.error("Error clearing localStorage:", error);
  }
};

/**
 * Get item from sessionStorage with JSON parsing
 * @param {string} key - Storage key
 * @param {*} defaultValue - Default value if key doesn't exist
 * @returns {*} Parsed value or default
 */
export const getSessionItem = (key, defaultValue = null) => {
  try {
    const item = sessionStorage.getItem(key);
    if (item === null) return defaultValue;
    return JSON.parse(item);
  } catch {
    return defaultValue;
  }
};

/**
 * Set item in sessionStorage with JSON serialization
 * @param {string} key - Storage key
 * @param {*} value - Value to store
 */
export const setSessionItem = (key, value) => {
  try {
    sessionStorage.setItem(key, JSON.stringify(value));
  } catch (error) {
    console.error("Error saving to sessionStorage:", error);
  }
};

/**
 * Remove item from sessionStorage
 * @param {string} key - Storage key
 */
export const removeSessionItem = (key) => {
  try {
    sessionStorage.removeItem(key);
  } catch (error) {
    console.error("Error removing from sessionStorage:", error);
  }
};

// Storage keys constants
export const STORAGE_KEYS = {
  THEME: "theme",
  SIDEBAR_COLLAPSED: "sidebarCollapsed",
  SELECTED_BRANCH: "selectedBranch",
  CART: "cart",
  HELD_SALES: "heldSales",
  TABLE_PAGE_SIZE: "tablePageSize",
  RECENT_SEARCHES: "recentSearches",
};
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\frontend\src\utils\validators.js"   & echo.. 
/**
 * Form Validation Schemas
 * Zod schemas for form validation
 */
import { z } from "zod";

// ============================================
// COMMON VALIDATION PATTERNS
// ============================================

export const emailSchema = z
  .string()
  .min(1, "Email is required")
  .email("Invalid email address");

export const passwordSchema = z
  .string()
  .min(8, "Password must be at least 8 characters")
  .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
  .regex(/[a-z]/, "Password must contain at least one lowercase letter")
  .regex(/[0-9]/, "Password must contain at least one number");

export const phoneSchema = z
  .string()
  .min(10, "Phone number must be at least 10 digits")
  .regex(/^[0-9+\-\s()]+$/, "Invalid phone number format");

export const nicSchema = z
  .string()
  .regex(/^([0-9]{9}[vVxX]|[0-9]{12})$/, "Invalid NIC format");

export const requiredString = (fieldName = "This field") =>
  z.string().min(1, `${fieldName} is required`);

export const optionalString = z.string().optional().or(z.literal(""));

export const positiveNumber = (fieldName = "Value") =>
  z.number().positive(`${fieldName} must be positive`);

export const nonNegativeNumber = (fieldName = "Value") =>
  z.number().min(0, `${fieldName} cannot be negative`);

// ============================================
// AUTH SCHEMAS
// ============================================

export const loginSchema = z.object({
  username: requiredString("Username"),
  password: requiredString("Password"),
});

export const changePasswordSchema = z
  .object({
    currentPassword: requiredString("Current password"),
    newPassword: passwordSchema,
    confirmPassword: z.string(),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export const forgotPasswordSchema = z.object({
  email: emailSchema,
});

// ============================================
// USER SCHEMAS
// ============================================

export const userSchema = z.object({
  username: requiredString("Username").min(
    3,
    "Username must be at least 3 characters"
  ),
  email: emailSchema,
  firstName: requiredString("First name"),
  lastName: requiredString("Last name"),
  phone: phoneSchema.optional().or(z.literal("")),
  role: requiredString("Role"),
  branchId: z.number().optional(),
  isActive: z.boolean().default(true),
});

export const createUserSchema = userSchema.extend({
  password: passwordSchema,
});

// ============================================
// BRANCH SCHEMAS
// ============================================

export const branchSchema = z.object({
  name: requiredString("Branch name"),
  code: requiredString("Branch code").max(
    10,
    "Code must be 10 characters or less"
  ),
  address: optionalString,
  city: optionalString,
  phone: phoneSchema.optional().or(z.literal("")),
  email: emailSchema.optional().or(z.literal("")),
  isActive: z.boolean().default(true),
});

// ============================================
// PRODUCT SCHEMAS
// ============================================

export const productSchema = z.object({
  productName: requiredString("Product name"),
  genericName: optionalString,
  categoryId: optionalString,
  dosageForm: optionalString,
  strength: optionalString,
  drugSchedule: optionalString,
  manufacturer: optionalString,
  barcode: optionalString,
  description: optionalString,
  costPrice: optionalString,
  sellingPrice: optionalString,
  mrp: optionalString,
  gstRate: optionalString,
  reorderLevel: optionalString,
  minimumStock: optionalString,
  maximumStock: optionalString,
  isPrescriptionRequired: z.boolean().default(false),
  isNarcotic: z.boolean().default(false),
  isRefrigerated: z.boolean().default(false),
});

// ============================================
// CATEGORY SCHEMAS
// ============================================

export const categorySchema = z.object({
  name: requiredString("Category name"),
  code: requiredString("Category code").max(
    10,
    "Code must be 10 characters or less"
  ),
  description: optionalString,
  isActive: z.boolean().default(true),
});

export const subCategorySchema = z.object({
  name: requiredString("Sub-category name"),
  code: requiredString("Sub-category code").max(
    10,
    "Code must be 10 characters or less"
  ),
  categoryId: z.number({ required_error: "Parent category is required" }),
  description: optionalString,
  isActive: z.boolean().default(true),
});

// ============================================
// SUPPLIER SCHEMAS
// ============================================

export const supplierSchema = z.object({
  name: requiredString("Supplier name"),
  code: requiredString("Supplier code"),
  contactPerson: optionalString,
  phone: phoneSchema.optional().or(z.literal("")),
  email: emailSchema.optional().or(z.literal("")),
  address: optionalString,
  city: optionalString,
  taxNumber: optionalString,
  paymentTerms: z.number().default(30),
  creditLimit: nonNegativeNumber("Credit limit").default(0),
  isActive: z.boolean().default(true),
});

// ============================================
// CUSTOMER SCHEMAS
// ============================================

export const customerSchema = z.object({
  name: requiredString("Customer name"),
  code: optionalString,
  phone: phoneSchema.optional().or(z.literal("")),
  email: emailSchema.optional().or(z.literal("")),
  address: optionalString,
  city: optionalString,
  nic: nicSchema.optional().or(z.literal("")),
  creditLimit: nonNegativeNumber("Credit limit").default(0),
  isActive: z.boolean().default(true),
});

// ============================================
// PURCHASE ORDER SCHEMAS
// ============================================

export const purchaseOrderItemSchema = z.object({
  productId: z.number({ required_error: "Product is required" }),
  quantity: positiveNumber("Quantity"),
  unitPrice: positiveNumber("Unit price"),
  discount: nonNegativeNumber("Discount").default(0),
});

export const purchaseOrderSchema = z.object({
  supplierId: z.number({ required_error: "Supplier is required" }),
  branchId: z.number({ required_error: "Branch is required" }),
  expectedDate: z.date().optional(),
  notes: optionalString,
  items: z
    .array(purchaseOrderItemSchema)
    .min(1, "At least one item is required"),
});

// ============================================
// GRN SCHEMAS
// ============================================

export const grnItemSchema = z.object({
  productId: z.number({ required_error: "Product is required" }),
  quantity: positiveNumber("Quantity"),
  batchNumber: requiredString("Batch number"),
  expiryDate: z.date({ required_error: "Expiry date is required" }),
  manufacturingDate: z.date().optional(),
  costPrice: positiveNumber("Cost price"),
  sellingPrice: positiveNumber("Selling price"),
  mrp: positiveNumber("MRP"),
});

export const grnSchema = z.object({
  purchaseOrderId: z.number().optional(),
  supplierId: z.number({ required_error: "Supplier is required" }),
  branchId: z.number({ required_error: "Branch is required" }),
  invoiceNumber: optionalString,
  invoiceDate: z.date().optional(),
  notes: optionalString,
  items: z.array(grnItemSchema).min(1, "At least one item is required"),
});

// ============================================
// STOCK TRANSFER SCHEMAS
// ============================================

export const stockTransferItemSchema = z.object({
  productId: z.number({ required_error: "Product is required" }),
  batchId: z.number({ required_error: "Batch is required" }),
  quantity: positiveNumber("Quantity"),
});

export const stockTransferSchema = z
  .object({
    fromBranchId: z.number({ required_error: "Source branch is required" }),
    toBranchId: z.number({ required_error: "Destination branch is required" }),
    notes: optionalString,
    items: z
      .array(stockTransferItemSchema)
      .min(1, "At least one item is required"),
  })
  .refine((data) => data.fromBranchId !== data.toBranchId, {
    message: "Source and destination branches must be different",
    path: ["toBranchId"],
  });

// ============================================
// SALE SCHEMAS
// ============================================

export const saleItemSchema = z.object({
  productId: z.number({ required_error: "Product is required" }),
  batchId: z.number({ required_error: "Batch is required" }),
  quantity: positiveNumber("Quantity"),
  unitPrice: positiveNumber("Unit price"),
  discount: nonNegativeNumber("Discount").default(0),
});

export const saleSchema = z.object({
  customerId: z.number().optional(),
  branchId: z.number({ required_error: "Branch is required" }),
  paymentMethod: requiredString("Payment method"),
  notes: optionalString,
  items: z.array(saleItemSchema).min(1, "At least one item is required"),
});

// ============================================
// VALIDATION HELPERS
// ============================================

/**
 * Validate data against a schema
 * @param {z.ZodSchema} schema - Zod schema
 * @param {object} data - Data to validate
 * @returns {object} { success, data, errors }
 */
export const validate = (schema, data) => {
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data, errors: null };
  }

  const errors = {};
  result.error.errors.forEach((err) => {
    const path = err.path.join(".");
    errors[path] = err.message;
  });

  return { success: false, data: null, errors };
};
.
