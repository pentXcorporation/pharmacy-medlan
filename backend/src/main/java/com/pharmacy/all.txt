
D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\MedlanApplication.java"   & echo.
package com.pharmacy.medlan;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MedlanApplication {

	public static void main(String[] args) {
		SpringApplication.run(MedlanApplication.class, args);
	}

}


D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\aspect\AuditAspect.java"   & echo.. 
package com.pharmacy.medlan.aspect;

public class AuditAspect {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\aspect\LoggingAspect.java"   & echo.. 
package com.pharmacy.medlan.aspect;

public class LoggingAspect {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\aspect\PerformanceAspect.java"   & echo.. 
package com.pharmacy.medlan.aspect;

public class PerformanceAspect {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\aspect\RateLimitAspect.java"   & echo.. 
package com.pharmacy.medlan.aspect;

import com.pharmacy.medlan.config.RateLimitConfig;
import com.pharmacy.medlan.exception.BusinessRuleViolationException;
import com.pharmacy.medlan.validation.annotation.RateLimit;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.ConsumptionProbe;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.lang.reflect.Method;

/**
 * Aspect for enforcing rate limits on API endpoints.
 * 
 * Uses the @RateLimit annotation to determine limits and scope.
 */
@Aspect
@Component
@RequiredArgsConstructor
@Slf4j
public class RateLimitAspect {

    private final RateLimitConfig rateLimitConfig;

    @Around("@annotation(com.pharmacy.medlan.validation.annotation.RateLimit)")
    public Object enforceRateLimit(ProceedingJoinPoint joinPoint) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        RateLimit rateLimit = method.getAnnotation(RateLimit.class);

        String bucketKey = getBucketKey(rateLimit, method);
        Bucket bucket = getBucket(bucketKey, rateLimit);

        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

        if (!probe.isConsumed()) {
            long waitTimeSeconds = probe.getNanosToWaitForRefill() / 1_000_000_000;
            log.warn("Rate limit exceeded for bucket: {}. Retry after {} seconds", bucketKey, waitTimeSeconds);
            throw new BusinessRuleViolationException(
                    String.format("Rate limit exceeded. Please try again in %d seconds.", waitTimeSeconds)
            );
        }

        log.debug("Rate limit check passed for bucket: {}. Remaining: {}", bucketKey, probe.getRemainingTokens());
        return joinPoint.proceed();
    }

    private String getBucketKey(RateLimit rateLimit, Method method) {
        // Use custom bucket name if specified
        if (!rateLimit.bucket().isEmpty()) {
            return rateLimit.bucket();
        }

        String baseKey = method.getDeclaringClass().getSimpleName() + "_" + method.getName();

        return switch (rateLimit.scope()) {
            case IP -> "ip_" + getClientIp() + "_" + baseKey;
            case USER -> "user_" + getCurrentUserId() + "_" + baseKey;
            case GLOBAL -> "global_" + baseKey;
        };
    }

    private Bucket getBucket(String key, RateLimit rateLimit) {
        // For simplicity, using IP-based bucket from config
        // In production, create dynamic buckets based on annotation parameters
        return switch (rateLimit.scope()) {
            case IP -> rateLimitConfig.getIpBucket(key);
            case USER -> rateLimitConfig.getUserBucket(key);
            case GLOBAL -> rateLimitConfig.defaultRateLimitBucket();
        };
    }

    private String getClientIp() {
        try {
            ServletRequestAttributes attrs = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (attrs != null) {
                HttpServletRequest request = attrs.getRequest();
                
                // Check for proxy headers
                String xForwardedFor = request.getHeader("X-Forwarded-For");
                if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
                    return xForwardedFor.split(",")[0].trim();
                }
                
                String xRealIp = request.getHeader("X-Real-IP");
                if (xRealIp != null && !xRealIp.isEmpty()) {
                    return xRealIp;
                }
                
                return request.getRemoteAddr();
            }
        } catch (Exception e) {
            log.error("Failed to get client IP", e);
        }
        return "unknown";
    }

    private String getCurrentUserId() {
        try {
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (auth != null && auth.isAuthenticated()) {
                return auth.getName();
            }
        } catch (Exception e) {
            log.error("Failed to get current user ID", e);
        }
        return "anonymous";
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\AsyncConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

public class AsyncConfig {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\AuditConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.domain.AuditorAware;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.Optional;

@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
@Slf4j
public class AuditConfig {

    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            try {
                Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
                if (authentication == null || !authentication.isAuthenticated()
                        || "anonymousUser".equals(authentication.getPrincipal())) {
                    log.debug("No authenticated user found, using SYSTEM as auditor");
                    return Optional.of("SYSTEM");
                }
                String username = authentication.getName();
                log.debug("Auditor resolved to: {}", username);
                return Optional.of(username != null ? username : "SYSTEM");
            } catch (Exception e) {
                log.warn("Error resolving auditor, defaulting to SYSTEM: {}", e.getMessage());
                return Optional.of("SYSTEM");
            }
        };
    }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\CacheConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.util.Arrays;
import java.util.concurrent.TimeUnit;

/**
 * Cache configuration using Caffeine for high-performance caching.
 * 
 * Cache Strategies:
 * - Short-lived: Session data, real-time inventory
 * - Medium-lived: Product catalogs, categories
 * - Long-lived: System configuration, static data
 */
@Configuration
@EnableCaching
public class CacheConfig {

    /**
     * Default cache manager with moderate expiration
     */
    @Bean
    @Primary
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(30, TimeUnit.MINUTES)
                .recordStats());
        
        // Register all cache names
        cacheManager.setCacheNames(Arrays.asList(
                // Product caches
                "products",
                "productsByCode",
                "productsByBarcode",
                "productQRCodes",
                
                // Inventory caches
                "inventoryBatches",
                "batchQRCodes",
                "lowStockAlerts",
                "expiryAlerts",
                
                // Organization caches
                "branches",
                "categories",
                "subCategories",
                "units",
                "suppliers",
                
                // User caches
                "users",
                "userRoles",
                
                // Finance caches
                "invoiceQRCodes",
                "dailySummaries",
                
                // System caches
                "systemConfig",
                "taxCategories"
        ));
        
        return cacheManager;
    }

    /**
     * Short-lived cache for real-time data (5 minutes)
     */
    @Bean
    public CacheManager shortLivedCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager(
                "realtimeInventory",
                "activeSessions",
                "pendingTransactions"
        );
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(500)
                .expireAfterWrite(5, TimeUnit.MINUTES)
                .recordStats());
        return cacheManager;
    }

    /**
     * Long-lived cache for static/rarely changing data (2 hours)
     */
    @Bean
    public CacheManager longLivedCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager(
                "staticConfig",
                "drugSchedules",
                "dosageForms",
                "taxRates"
        );
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(200)
                .expireAfterWrite(2, TimeUnit.HOURS)
                .recordStats());
        return cacheManager;
    }

    /**
     * Barcode/QR code cache (1 hour)
     */
    @Bean
    public CacheManager barcodeCacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager(
                "barcodeImages",
                "qrCodeImages",
                "shelfLabels"
        );
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(500)
                .expireAfterWrite(1, TimeUnit.HOURS)
                .recordStats());
        return cacheManager;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\CorsConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

public class CorsConfig {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\DatabaseConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

public class DatabaseConfig {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\DataInitializer.java"   & echo.. 
package com.pharmacy.medlan.config;

import com.pharmacy.medlan.enums.Role;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.user.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

/**
 * Data Initializer - Seeds default users for development/testing
 * Creates default admin user if no users exist in database
 */
@Configuration
@RequiredArgsConstructor
@Slf4j
public class DataInitializer {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    @Bean
    public ApplicationRunner initializeData() {
        return args -> {
            // Only seed data if no users exist
            if (userRepository.count() == 0) {
                log.info("No users found. Creating default users...");
                createDefaultUsers();
            } else {
                log.info("Users already exist. Resetting superadmin password for development...");
                resetSuperAdminPassword();
            }
        };
    }

    private void resetSuperAdminPassword() {
        userRepository.findByUsername("superadmin").ifPresent(user -> {
            user.setPassword(passwordEncoder.encode("admin123"));
            userRepository.save(user);
            log.info("Reset superadmin password to: admin123");
        });
    }

    private void createDefaultUsers() {
        // Create Super Admin
        User superAdmin = User.builder()
                .username("superadmin")
                .password(passwordEncoder.encode("admin123"))
                .fullName("Super Administrator")
                .email("admin@medlan.com")
                .phoneNumber("0771234567")
                .role(Role.SUPER_ADMIN)
                .employeeCode("EMP001")
                .isActive(true)
                .build();
        userRepository.save(superAdmin);
        log.info("Created Super Admin user: superadmin / admin123");

        // Create Admin
        User admin = User.builder()
                .username("admin")
                .password(passwordEncoder.encode("admin123"))
                .fullName("Administrator")
                .email("administrator@medlan.com")
                .phoneNumber("0772345678")
                .role(Role.ADMIN)
                .employeeCode("EMP002")
                .isActive(true)
                .build();
        userRepository.save(admin);
        log.info("Created Admin user: admin / admin123");

        // Create Branch Manager
        User branchManager = User.builder()
                .username("branchmanager")
                .password(passwordEncoder.encode("branch123"))
                .fullName("Branch Manager")
                .email("branch@medlan.com")
                .phoneNumber("0773456789")
                .role(Role.BRANCH_MANAGER)
                .employeeCode("EMP003")
                .isActive(true)
                .build();
        userRepository.save(branchManager);
        log.info("Created Branch Manager user: branchmanager / branch123");

        // Create Pharmacist
        User pharmacist = User.builder()
                .username("pharmacist")
                .password(passwordEncoder.encode("pharm123"))
                .fullName("Pharmacist User")
                .email("pharmacist@medlan.com")
                .phoneNumber("0774567890")
                .role(Role.PHARMACIST)
                .employeeCode("EMP004")
                .isActive(true)
                .build();
        userRepository.save(pharmacist);
        log.info("Created Pharmacist user: pharmacist / pharm123");

        // Create Cashier
        User cashier = User.builder()
                .username("cashier")
                .password(passwordEncoder.encode("cash123"))
                .fullName("Cashier User")
                .email("cashier@medlan.com")
                .phoneNumber("0775678901")
                .role(Role.CASHIER)
                .employeeCode("EMP005")
                .isActive(true)
                .build();
        userRepository.save(cashier);
        log.info("Created Cashier user: cashier / cash123");

        // Create Inventory Manager
        User inventoryManager = User.builder()
                .username("inventory")
                .password(passwordEncoder.encode("inv123"))
                .fullName("Inventory Manager")
                .email("inventory@medlan.com")
                .phoneNumber("0776789012")
                .role(Role.INVENTORY_MANAGER)
                .employeeCode("EMP006")
                .isActive(true)
                .build();
        userRepository.save(inventoryManager);
        log.info("Created Inventory Manager user: inventory / inv123");

        // Create Accountant
        User accountant = User.builder()
                .username("accountant")
                .password(passwordEncoder.encode("acc123"))
                .fullName("Accountant User")
                .email("accountant@medlan.com")
                .phoneNumber("0777890123")
                .role(Role.ACCOUNTANT)
                .employeeCode("EMP007")
                .isActive(true)
                .build();
        userRepository.save(accountant);
        log.info("Created Accountant user: accountant / acc123");

        log.info("===========================================");
        log.info("Default users created successfully!");
        log.info("===========================================");
        log.info("Login Credentials:");
        log.info("  Super Admin:     superadmin / admin123");
        log.info("  Admin:           admin / admin123");
        log.info("  Branch Manager:  branchmanager / branch123");
        log.info("  Pharmacist:      pharmacist / pharm123");
        log.info("  Cashier:         cashier / cash123");
        log.info("  Inventory:       inventory / inv123");
        log.info("  Accountant:      accountant / acc123");
        log.info("===========================================");
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\JwtConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "jwt")
@Getter
@Setter
public class JwtConfig {

    private String secret;
    private Long expiration;
    private Long refreshExpiration;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\RateLimitConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.Refill;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Rate limiting configuration using Bucket4j.
 * Protects APIs from abuse and ensures fair usage.
 */
@Configuration
public class RateLimitConfig {

    /**
     * Storage for per-user rate limit buckets
     */
    private final Map<String, Bucket> userBuckets = new ConcurrentHashMap<>();
    
    /**
     * Storage for per-IP rate limit buckets
     */
    private final Map<String, Bucket> ipBuckets = new ConcurrentHashMap<>();

    /**
     * Default rate limit: 100 requests per minute
     */
    @Bean
    public Bucket defaultRateLimitBucket() {
        return Bucket.builder()
                .addLimit(Bandwidth.classic(100, Refill.greedy(100, Duration.ofMinutes(1))))
                .build();
    }

    /**
     * Strict rate limit for login attempts: 5 per minute
     */
    @Bean
    public Bucket loginRateLimitBucket() {
        return Bucket.builder()
                .addLimit(Bandwidth.classic(5, Refill.greedy(5, Duration.ofMinutes(1))))
                .addLimit(Bandwidth.classic(20, Refill.greedy(20, Duration.ofHours(1))))
                .build();
    }

    /**
     * Rate limit for report generation: 10 per minute
     */
    @Bean
    public Bucket reportRateLimitBucket() {
        return Bucket.builder()
                .addLimit(Bandwidth.classic(10, Refill.greedy(10, Duration.ofMinutes(1))))
                .build();
    }

    /**
     * Rate limit for barcode generation: 50 per minute
     */
    @Bean
    public Bucket barcodeRateLimitBucket() {
        return Bucket.builder()
                .addLimit(Bandwidth.classic(50, Refill.greedy(50, Duration.ofMinutes(1))))
                .build();
    }

    /**
     * Rate limit for bulk operations: 5 per minute
     */
    @Bean
    public Bucket bulkOperationRateLimitBucket() {
        return Bucket.builder()
                .addLimit(Bandwidth.classic(5, Refill.greedy(5, Duration.ofMinutes(1))))
                .build();
    }

    /**
     * Get or create a rate limit bucket for a specific user
     */
    public Bucket getUserBucket(String userId) {
        return userBuckets.computeIfAbsent(userId, key -> 
                Bucket.builder()
                        .addLimit(Bandwidth.classic(200, Refill.greedy(200, Duration.ofMinutes(1))))
                        .build()
        );
    }

    /**
     * Get or create a rate limit bucket for a specific IP
     */
    public Bucket getIpBucket(String ipAddress) {
        return ipBuckets.computeIfAbsent(ipAddress, key -> 
                Bucket.builder()
                        .addLimit(Bandwidth.classic(100, Refill.greedy(100, Duration.ofMinutes(1))))
                        .addLimit(Bandwidth.classic(1000, Refill.greedy(1000, Duration.ofHours(1))))
                        .build()
        );
    }

    /**
     * Get rate limit bucket for login attempts by IP
     */
    public Bucket getLoginBucket(String ipAddress) {
        return ipBuckets.computeIfAbsent("login_" + ipAddress, key -> 
                Bucket.builder()
                        .addLimit(Bandwidth.classic(5, Refill.greedy(5, Duration.ofMinutes(1))))
                        .addLimit(Bandwidth.classic(20, Refill.greedy(20, Duration.ofHours(1))))
                        .build()
        );
    }

    /**
     * Clean up expired buckets (call periodically)
     */
    public void cleanupBuckets() {
        // In a production system, implement bucket expiration logic
        // For now, keep all buckets
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\SecurityConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

import com.pharmacy.medlan.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler;
import org.springframework.security.access.expression.method.MethodSecurityExpressionHandler;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final UserDetailsService userDetailsService;

    private static final String[] PUBLIC_ENDPOINTS = {
            "/api/auth/**",
            "/api/public/**",
            "/swagger-ui/**",
            "/swagger-ui.html",
            "/v3/api-docs/**",
            "/api-docs/**",
            "/actuator/**",
            "/error"
    };

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(PUBLIC_ENDPOINTS).permitAll()
                        .anyRequest().authenticated()
                )
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * Role Hierarchy Configuration
     * SUPER_ADMIN has all permissions of all other roles
     * This ensures SUPER_ADMIN can access everything in the system
     */
    @Bean
    public RoleHierarchy roleHierarchy() {
        String hierarchy = """
            ROLE_SUPER_ADMIN > ROLE_ADMIN
            ROLE_SUPER_ADMIN > ROLE_OWNER
            ROLE_ADMIN > ROLE_BRANCH_MANAGER
            ROLE_OWNER > ROLE_BRANCH_MANAGER
            ROLE_BRANCH_MANAGER > ROLE_MANAGER
            ROLE_MANAGER > ROLE_PHARMACIST
            ROLE_MANAGER > ROLE_INVENTORY_MANAGER
            ROLE_MANAGER > ROLE_ACCOUNTANT
            ROLE_PHARMACIST > ROLE_CASHIER
            """;
        return RoleHierarchyImpl.fromHierarchy(hierarchy);
    }

    /**
     * Method Security Expression Handler with Role Hierarchy
     * This enables the role hierarchy for @PreAuthorize annotations
     */
    @Bean
    public MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) {
        DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler();
        handler.setRoleHierarchy(roleHierarchy);
        return handler;
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOriginPatterns(List.of("*"));
        config.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"));
        config.setAllowedHeaders(List.of("*"));
        config.setExposedHeaders(List.of("*"));
        config.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\SwaggerConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Medlan Pharmacy API")
                        .version("1.0.0")
                        .description("Advanced Pharmacy Management System - POS + Inventory + ERP")
                        .contact(new Contact()
                                .name("Medlan Support")
                                .email("support@medlan.com"))
                        .license(new License()
                                .name("Proprietary")
                                .url("https://medlan.com")))
                .addSecurityItem(new SecurityRequirement().addList("Bearer Authentication"))
                .components(new Components()
                        .addSecuritySchemes("Bearer Authentication",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")
                                        .description("Enter JWT token")));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\config\WebSocketConfig.java"   & echo.. 
package com.pharmacy.medlan.config;

public class WebSocketConfig {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\AuthController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.auth.ChangePasswordRequest;
import com.pharmacy.medlan.dto.request.auth.LoginRequest;
import com.pharmacy.medlan.dto.request.auth.RegisterRequest;
import com.pharmacy.medlan.dto.response.auth.LoginResponse;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.user.UserResponse;
import com.pharmacy.medlan.service.user.AuthService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Tag(name = "Authentication", description = "Authentication management APIs")
public class AuthController {

    private final AuthService authService;

    @PostMapping("/login")
    @Operation(summary = "Login user", description = "Authenticate user and return JWT tokens")
    public ResponseEntity<ApiResponse<LoginResponse>> login(@Valid @RequestBody LoginRequest request) {
        LoginResponse response = authService.login(request);
        return ResponseEntity.ok(ApiResponse.success("Login successful", response));
    }

    @PostMapping("/register")
    @Operation(summary = "Register user", description = "Register a new user")
    @PreAuthorize("hasRole('ADMIN') or hasRole('OWNER')")
    public ResponseEntity<ApiResponse<UserResponse>> register(@Valid @RequestBody RegisterRequest request) {
        UserResponse response = authService.register(request);
        return ResponseEntity.ok(ApiResponse.success("User registered successfully", response));
    }

    @PostMapping("/register/initial")
    @Operation(summary = "Initial user registration", description = "Register the first admin user (only works if no users exist)")
    public ResponseEntity<ApiResponse<UserResponse>> registerInitial(@Valid @RequestBody RegisterRequest request) {
        UserResponse response = authService.register(request);
        return ResponseEntity.ok(ApiResponse.success("Initial user registered successfully", response));
    }

    @PostMapping("/refresh")
    @Operation(summary = "Refresh token", description = "Get new access token using refresh token")
    public ResponseEntity<ApiResponse<LoginResponse>> refreshToken(@RequestParam String refreshToken) {
        LoginResponse response = authService.refreshToken(refreshToken);
        return ResponseEntity.ok(ApiResponse.success("Token refreshed successfully", response));
    }

    @PostMapping("/change-password")
    @Operation(summary = "Change password", description = "Change current user's password")
    public ResponseEntity<ApiResponse<Void>> changePassword(
            Authentication authentication,
            @Valid @RequestBody ChangePasswordRequest request) {
        authService.changePassword(authentication.getName(), request);
        return ResponseEntity.ok(ApiResponse.success("Password changed successfully"));
    }

    @PostMapping("/logout")
    @Operation(summary = "Logout", description = "Logout current user")
    public ResponseEntity<ApiResponse<Void>> logout(Authentication authentication) {
        authService.logout(authentication.getName());
        return ResponseEntity.ok(ApiResponse.success("Logout successful"));
    }

    @GetMapping("/me")
    @Operation(summary = "Get current user", description = "Get current authenticated user details")
    public ResponseEntity<ApiResponse<UserResponse>> getCurrentUser(Authentication authentication) {
        UserResponse response = authService.getCurrentUser(authentication.getName());
        return ResponseEntity.ok(ApiResponse.success(response));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\BankController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class BankController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\BarcodeController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.barcode.BarcodeGenerateRequest;
import com.pharmacy.medlan.dto.request.barcode.BulkBarcodeRequest;
import com.pharmacy.medlan.dto.request.barcode.DecodeRequest;
import com.pharmacy.medlan.dto.response.barcode.BarcodeResponse;
import com.pharmacy.medlan.dto.response.barcode.QRCodeResponse;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.enums.BarcodeFormat;
import com.pharmacy.medlan.service.barcode.BarcodeService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/barcodes")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Barcode & QR Code Management", description = "APIs for generating and reading barcodes and QR codes")
public class BarcodeController {

    private final BarcodeService barcodeService;

    // ==================== Barcode Generation ====================

    @PostMapping("/generate")
    @Operation(summary = "Generate barcode", description = "Generate a barcode for given content")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<BarcodeResponse>> generateBarcode(
            @Valid @RequestBody BarcodeGenerateRequest request) {
        log.info("Generating barcode for content: {}", request.getContent());
        BarcodeResponse response = barcodeService.generateBarcode(
                request.getContent(),
                request.getFormat() != null ? request.getFormat() : BarcodeFormat.CODE_128,
                request.getWidth(),
                request.getHeight()
        );
        return ResponseEntity.ok(ApiResponse.success("Barcode generated successfully", response));
    }

    @GetMapping("/product/{productId}")
    @Operation(summary = "Generate product barcode", description = "Generate a barcode for a product")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'CASHIER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<BarcodeResponse>> generateProductBarcode(
            @PathVariable Long productId,
            @RequestParam(defaultValue = "CODE_128") BarcodeFormat format) {
        log.info("Generating barcode for product ID: {}", productId);
        BarcodeResponse response = barcodeService.generateShelfLabel(productId, format);
        return ResponseEntity.ok(ApiResponse.success("Product barcode generated", response));
    }

    @PostMapping("/bulk")
    @Operation(summary = "Generate bulk barcodes", description = "Generate barcodes for multiple products")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<Map<Long, BarcodeResponse>>> generateBulkBarcodes(
            @Valid @RequestBody BulkBarcodeRequest request) {
        log.info("Generating bulk barcodes for {} products", request.getProductIds().size());
        Map<Long, BarcodeResponse> responses = barcodeService.generateBulkBarcodes(
                request.getProductIds(),
                request.getFormat() != null ? request.getFormat() : BarcodeFormat.CODE_128
        );
        return ResponseEntity.ok(ApiResponse.success("Bulk barcodes generated", responses));
    }

    @GetMapping("/shelf-label/{productId}")
    @Operation(summary = "Generate shelf label", description = "Generate a shelf label with barcode for a product")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<BarcodeResponse>> generateShelfLabel(
            @PathVariable Long productId,
            @RequestParam(defaultValue = "EAN_13") BarcodeFormat format) {
        log.info("Generating shelf label for product ID: {}", productId);
        BarcodeResponse response = barcodeService.generateShelfLabel(productId, format);
        return ResponseEntity.ok(ApiResponse.success("Shelf label generated", response));
    }

    // ==================== QR Code Generation ====================

    @PostMapping("/qr/generate")
    @Operation(summary = "Generate QR code", description = "Generate a QR code for given data")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<QRCodeResponse>> generateQRCode(
            @RequestParam String data,
            @RequestParam(defaultValue = "250") int size) {
        log.info("Generating QR code for data length: {}", data.length());
        QRCodeResponse response = barcodeService.generateQRCode(data, size);
        return ResponseEntity.ok(ApiResponse.success("QR code generated", response));
    }

    @GetMapping("/qr/product/{productId}")
    @Operation(summary = "Generate product QR code", description = "Generate a QR code with product details")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'CASHIER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<QRCodeResponse>> generateProductQRCode(
            @PathVariable Long productId,
            @Parameter(description = "Include batch information in QR") @RequestParam(defaultValue = "false") boolean includeBatchInfo,
            @RequestParam(defaultValue = "250") int size) {
        log.info("Generating product QR code for product ID: {}", productId);
        QRCodeResponse response = barcodeService.generateProductQRCode(productId, includeBatchInfo, size);
        return ResponseEntity.ok(ApiResponse.success("Product QR code generated", response));
    }

    @GetMapping("/qr/batch/{batchId}")
    @Operation(summary = "Generate batch QR code", description = "Generate a QR code with batch traceability info")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<QRCodeResponse>> generateBatchQRCode(
            @PathVariable Long batchId,
            @RequestParam(defaultValue = "250") int size) {
        log.info("Generating batch QR code for batch ID: {}", batchId);
        QRCodeResponse response = barcodeService.generateBatchQRCode(batchId, size);
        return ResponseEntity.ok(ApiResponse.success("Batch QR code generated", response));
    }

    @GetMapping("/qr/invoice/{invoiceId}")
    @Operation(summary = "Generate invoice QR code", description = "Generate a QR code for invoice (GST compliance)")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'CASHIER', 'ACCOUNTANT')")
    public ResponseEntity<ApiResponse<QRCodeResponse>> generateInvoiceQRCode(@PathVariable Long invoiceId) {
        log.info("Generating invoice QR code for invoice ID: {}", invoiceId);
        QRCodeResponse response = barcodeService.generateInvoiceQRCode(invoiceId);
        return ResponseEntity.ok(ApiResponse.success("Invoice QR code generated", response));
    }

    @GetMapping("/qr/prescription/{prescriptionId}")
    @Operation(summary = "Generate prescription QR code", description = "Generate a QR code for prescription")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST')")
    public ResponseEntity<ApiResponse<QRCodeResponse>> generatePrescriptionQRCode(@PathVariable Long prescriptionId) {
        log.info("Generating prescription QR code for prescription ID: {}", prescriptionId);
        QRCodeResponse response = barcodeService.generatePrescriptionQRCode(prescriptionId);
        return ResponseEntity.ok(ApiResponse.success("Prescription QR code generated", response));
    }

    // ==================== Barcode/QR Code Reading ====================

    @PostMapping("/decode/barcode")
    @Operation(summary = "Decode barcode", description = "Read and decode a barcode from image")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'CASHIER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<String>> decodeBarcode(@Valid @RequestBody DecodeRequest request) {
        log.info("Decoding barcode from image");
        String content = barcodeService.readBarcode(request.getBase64Image());
        return ResponseEntity.ok(ApiResponse.success("Barcode decoded successfully", content));
    }

    @PostMapping("/decode/qr")
    @Operation(summary = "Decode QR code", description = "Read and decode a QR code from image")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'CASHIER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<String>> decodeQRCode(@Valid @RequestBody DecodeRequest request) {
        log.info("Decoding QR code from image");
        String content = barcodeService.readQRCode(request.getBase64Image());
        return ResponseEntity.ok(ApiResponse.success("QR code decoded successfully", content));
    }

    // ==================== Utility Endpoints ====================

    @GetMapping("/validate")
    @Operation(summary = "Validate barcode format", description = "Validate if a barcode matches expected format")
    public ResponseEntity<ApiResponse<Boolean>> validateBarcode(
            @RequestParam String barcode,
            @RequestParam BarcodeFormat format) {
        log.info("Validating barcode: {} for format: {}", barcode, format);
        boolean isValid = barcodeService.validateBarcodeFormat(barcode, format);
        return ResponseEntity.ok(ApiResponse.success(isValid ? "Barcode is valid" : "Barcode is invalid", isValid));
    }

    @GetMapping("/generate-unique")
    @Operation(summary = "Generate unique barcode", description = "Generate a unique barcode for new products")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<String>> generateUniqueBarcode(
            @RequestParam(required = false, defaultValue = "MED") String prefix) {
        log.info("Generating unique barcode with prefix: {}", prefix);
        String barcode = barcodeService.generateUniqueBarcode(prefix);
        return ResponseEntity.ok(ApiResponse.success("Unique barcode generated", barcode));
    }

    @GetMapping("/generate-ean13")
    @Operation(summary = "Generate EAN-13 barcode", description = "Generate EAN-13 barcode with check digit")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<String>> generateEAN13(
            @Parameter(description = "12-digit base number") @RequestParam String baseNumber) {
        log.info("Generating EAN-13 barcode for base: {}", baseNumber);
        String ean13 = barcodeService.generateEAN13(baseNumber);
        return ResponseEntity.ok(ApiResponse.success("EAN-13 barcode generated", ean13));
    }

    @GetMapping("/formats")
    @Operation(summary = "Get supported formats", description = "Get list of all supported barcode formats")
    public ResponseEntity<ApiResponse<BarcodeFormat[]>> getSupportedFormats() {
        return ResponseEntity.ok(ApiResponse.success("Supported barcode formats", BarcodeFormat.values()));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\BranchController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.branch.CreateBranchRequest;
import com.pharmacy.medlan.dto.response.branch.BranchResponse;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.mapper.BranchMapper;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.service.branch.BranchService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/branches")
@RequiredArgsConstructor
@Tag(name = "Branches", description = "Branch Management APIs")
public class BranchController {

    private final BranchService branchService;
    private final BranchMapper branchMapper;

    @PostMapping
    @Operation(summary = "Create a new branch")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<BranchResponse>> createBranch(
            @Valid @RequestBody CreateBranchRequest request) {
        Branch branch = branchMapper.toEntity(request);
        Branch createdBranch = branchService.createBranch(branch);
        return ResponseEntity.ok(ApiResponse.success("Branch created successfully", 
                branchMapper.toResponse(createdBranch)));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get branch by ID")
    public ResponseEntity<ApiResponse<BranchResponse>> getBranchById(@PathVariable Long id) {
        return branchService.getBranchById(id)
                .map(branch -> ResponseEntity.ok(ApiResponse.success(branchMapper.toResponse(branch))))
                .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/code/{branchCode}")
    @Operation(summary = "Get branch by code")
    public ResponseEntity<ApiResponse<BranchResponse>> getBranchByCode(@PathVariable String branchCode) {
        Branch branch = branchService.getBranchByCode(branchCode);
        return ResponseEntity.ok(ApiResponse.success(branchMapper.toResponse(branch)));
    }

    @GetMapping
    @Operation(summary = "Get all branches with pagination")
    public ResponseEntity<ApiResponse<Page<BranchResponse>>> getAllBranches(Pageable pageable) {
        Page<BranchResponse> branches = branchService.getAllBranches(pageable)
                .map(branchMapper::toResponse);
        return ResponseEntity.ok(ApiResponse.success(branches));
    }

    @GetMapping("/all")
    @Operation(summary = "Get all branches as list")
    public ResponseEntity<ApiResponse<List<BranchResponse>>> getAllBranchesList() {
        List<BranchResponse> branches = branchMapper.toResponseList(branchService.getAllBranches());
        return ResponseEntity.ok(ApiResponse.success(branches));
    }

    @GetMapping("/active")
    @Operation(summary = "Get all active branches")
    public ResponseEntity<ApiResponse<List<BranchResponse>>> getActiveBranches() {
        List<BranchResponse> branches = branchMapper.toResponseList(branchService.getActiveBranches());
        return ResponseEntity.ok(ApiResponse.success(branches));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update a branch")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<BranchResponse>> updateBranch(
            @PathVariable Long id,
            @Valid @RequestBody CreateBranchRequest request) {
        Branch branch = branchMapper.toEntity(request);
        Branch updatedBranch = branchService.updateBranch(id, branch);
        return ResponseEntity.ok(ApiResponse.success("Branch updated successfully", 
                branchMapper.toResponse(updatedBranch)));
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete a branch")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> deleteBranch(@PathVariable Long id) {
        branchService.softDeleteBranch(id);
        return ResponseEntity.ok(ApiResponse.success("Branch deleted successfully", null));
    }

    @PostMapping("/{id}/activate")
    @Operation(summary = "Activate a branch")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> activateBranch(@PathVariable Long id) {
        branchService.activateBranch(id);
        return ResponseEntity.ok(ApiResponse.success("Branch activated", null));
    }

    @PostMapping("/{id}/deactivate")
    @Operation(summary = "Deactivate a branch")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<Void>> deactivateBranch(@PathVariable Long id) {
        branchService.deactivateBranch(id);
        return ResponseEntity.ok(ApiResponse.success("Branch deactivated", null));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\BranchStaffController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class BranchStaffController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\CashBookController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class CashBookController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\CategoryController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.product.CategoryResponse;
import com.pharmacy.medlan.service.product.CategoryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.constraints.NotBlank;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/categories")
@RequiredArgsConstructor
@Tag(name = "Category Management", description = "APIs for managing product categories")
public class CategoryController {

    private final CategoryService categoryService;

    @PostMapping
    @Operation(summary = "Create category", description = "Create a new product category")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<CategoryResponse>> createCategory(
            @RequestParam @NotBlank String categoryName,
            @RequestParam(required = false) String categoryCode,
            @RequestParam(required = false) String description) {
        CategoryResponse response = categoryService.createCategory(categoryName, categoryCode, description);
        return ResponseEntity.ok(ApiResponse.success("Category created successfully", response));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update category", description = "Update an existing category")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<CategoryResponse>> updateCategory(
            @PathVariable Long id,
            @RequestParam @NotBlank String categoryName,
            @RequestParam(required = false) String description) {
        CategoryResponse response = categoryService.updateCategory(id, categoryName, description);
        return ResponseEntity.ok(ApiResponse.success("Category updated successfully", response));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get category by ID", description = "Get category details by ID")
    public ResponseEntity<ApiResponse<CategoryResponse>> getCategoryById(@PathVariable Long id) {
        CategoryResponse response = categoryService.getCategoryById(id);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping
    @Operation(summary = "Get all categories", description = "Get all categories")
    public ResponseEntity<ApiResponse<List<CategoryResponse>>> getAllCategories() {
        List<CategoryResponse> response = categoryService.getAllCategories();
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/active")
    @Operation(summary = "Get active categories", description = "Get all active categories")
    public ResponseEntity<ApiResponse<List<CategoryResponse>>> getActiveCategories() {
        List<CategoryResponse> response = categoryService.getActiveCategories();
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete category", description = "Soft delete a category")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER')")
    public ResponseEntity<ApiResponse<Void>> deleteCategory(@PathVariable Long id) {
        categoryService.deleteCategory(id);
        return ResponseEntity.ok(ApiResponse.success("Category deleted successfully"));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\ChequeController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class ChequeController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\CustomerController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.pos.CreateCustomerRequest;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.common.PageResponse;
import com.pharmacy.medlan.dto.response.pos.CustomerResponse;
import com.pharmacy.medlan.service.pos.CustomerService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/customers")
@RequiredArgsConstructor
@Tag(name = "Customer Management", description = "APIs for managing customers")
public class CustomerController {

    private final CustomerService customerService;

    @PostMapping
    @Operation(summary = "Create customer", description = "Create a new customer")
    public ResponseEntity<ApiResponse<CustomerResponse>> createCustomer(
            @Valid @RequestBody CreateCustomerRequest request) {
        CustomerResponse response = customerService.createCustomer(request);
        return ResponseEntity.ok(ApiResponse.success("Customer created successfully", response));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update customer", description = "Update an existing customer")
    public ResponseEntity<ApiResponse<CustomerResponse>> updateCustomer(
            @PathVariable Long id,
            @Valid @RequestBody CreateCustomerRequest request) {
        CustomerResponse response = customerService.updateCustomer(id, request);
        return ResponseEntity.ok(ApiResponse.success("Customer updated successfully", response));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get customer by ID", description = "Get customer details by ID")
    public ResponseEntity<ApiResponse<CustomerResponse>> getCustomerById(@PathVariable Long id) {
        CustomerResponse response = customerService.getCustomerById(id);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/code/{customerCode}")
    @Operation(summary = "Get customer by code", description = "Get customer details by customer code")
    public ResponseEntity<ApiResponse<CustomerResponse>> getCustomerByCode(@PathVariable String customerCode) {
        CustomerResponse response = customerService.getCustomerByCode(customerCode);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping
    @Operation(summary = "Get all customers", description = "Get all customers with pagination")
    public ResponseEntity<ApiResponse<PageResponse<CustomerResponse>>> getAllCustomers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "customerName") String sortBy,
            @RequestParam(defaultValue = "asc") String sortDir) {
        Sort sort = sortDir.equalsIgnoreCase("desc") ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
        Pageable pageable = PageRequest.of(page, size, sort);
        Page<CustomerResponse> customersPage = customerService.getAllCustomers(pageable);
        return ResponseEntity.ok(ApiResponse.success(PageResponse.of(customersPage)));
    }

    @GetMapping("/search")
    @Operation(summary = "Search customers", description = "Search customers by name, phone, or email")
    public ResponseEntity<ApiResponse<List<CustomerResponse>>> searchCustomers(@RequestParam String query) {
        List<CustomerResponse> response = customerService.searchCustomers(query);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/active")
    @Operation(summary = "Get active customers", description = "Get all active customers")
    public ResponseEntity<ApiResponse<List<CustomerResponse>>> getActiveCustomers() {
        List<CustomerResponse> response = customerService.getActiveCustomers();
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete customer", description = "Soft delete a customer")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<Void>> deleteCustomer(@PathVariable Long id) {
        customerService.deleteCustomer(id);
        return ResponseEntity.ok(ApiResponse.success("Customer deleted successfully"));
    }

    @PatchMapping("/{id}/activate")
    @Operation(summary = "Activate customer", description = "Activate a customer")
    public ResponseEntity<ApiResponse<Void>> activateCustomer(@PathVariable Long id) {
        customerService.activateCustomer(id);
        return ResponseEntity.ok(ApiResponse.success("Customer activated successfully"));
    }

    @PatchMapping("/{id}/deactivate")
    @Operation(summary = "Deactivate customer", description = "Deactivate a customer")
    public ResponseEntity<ApiResponse<Void>> deactivateCustomer(@PathVariable Long id) {
        customerService.deactivateCustomer(id);
        return ResponseEntity.ok(ApiResponse.success("Customer deactivated successfully"));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\CustomerPrescriptionController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class CustomerPrescriptionController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\DashboardController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.dashboard.DashboardSummaryResponse;
import com.pharmacy.medlan.repository.inventory.GRNRepository;
import com.pharmacy.medlan.repository.pos.CustomerRepository;
import com.pharmacy.medlan.repository.pos.SaleRepository;
import com.pharmacy.medlan.repository.product.BranchInventoryRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.List;

@RestController
@RequestMapping("/api/dashboard")
@RequiredArgsConstructor
@Tag(name = "Dashboard", description = "Dashboard APIs")
public class DashboardController {

    private final SaleRepository saleRepository;
    private final GRNRepository grnRepository;
    private final CustomerRepository customerRepository;
    private final BranchInventoryRepository branchInventoryRepository;
    private final InventoryBatchRepository inventoryBatchRepository;

    @GetMapping("/summary")
    @Operation(summary = "Get dashboard summary")
    public ResponseEntity<ApiResponse<DashboardSummaryResponse>> getDashboardSummary(
            @RequestParam Long branchId) {

        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
        LocalDateTime endOfDay = LocalDate.now().atTime(LocalTime.MAX);
        LocalDate startOfMonth = LocalDate.now().withDayOfMonth(1);
        LocalDate endOfMonth = LocalDate.now().withDayOfMonth(LocalDate.now().lengthOfMonth());
        LocalDate expiryAlertDate = LocalDate.now().plusDays(30);

        // Today's summary
        BigDecimal todaySales = saleRepository.getTotalSalesByBranchAndDate(branchId, startOfDay, endOfDay);
        Long todaySalesCount = (long) saleRepository.findByBranchAndDateRange(branchId, startOfDay, endOfDay).size();
        BigDecimal todayPurchases = grnRepository.getTotalReceiptsByBranch(branchId, LocalDate.now(), LocalDate.now());

        DashboardSummaryResponse.TodaySummary todaySummary = DashboardSummaryResponse.TodaySummary.builder()
                .totalSales(todaySales != null ? todaySales : BigDecimal.ZERO)
                .salesCount(todaySalesCount)
                .totalPurchases(todayPurchases != null ? todayPurchases : BigDecimal.ZERO)
                .purchasesCount(0L)
                .profit(BigDecimal.ZERO)
                .newCustomers(0L)
                .build();

        // Monthly summary
        BigDecimal monthlySales = saleRepository.getTotalSalesByBranchAndDate(
                branchId, startOfMonth.atStartOfDay(), endOfMonth.atTime(LocalTime.MAX));

        DashboardSummaryResponse.MonthlySummary monthlySummary = DashboardSummaryResponse.MonthlySummary.builder()
                .totalSales(monthlySales != null ? monthlySales : BigDecimal.ZERO)
                .salesCount(0L)
                .totalPurchases(BigDecimal.ZERO)
                .totalProfit(BigDecimal.ZERO)
                .averageDailySales(BigDecimal.ZERO)
                .build();

        // Inventory alerts
        Long lowStockCount = (long) branchInventoryRepository.findLowStockByBranch(branchId).size();
        Long outOfStockCount = (long) branchInventoryRepository.findOutOfStockByBranch(branchId).size();
        Long expiringCount = (long) inventoryBatchRepository.findExpiringBatchesForAlert(branchId, expiryAlertDate).size();
        Long expiredCount = (long) inventoryBatchRepository.findExpiredBatches(LocalDate.now()).size();

        DashboardSummaryResponse.InventoryAlerts alerts = DashboardSummaryResponse.InventoryAlerts.builder()
                .lowStockCount(lowStockCount)
                .outOfStockCount(outOfStockCount)
                .expiringCount(expiringCount)
                .expiredCount(expiredCount)
                .build();

        DashboardSummaryResponse response = DashboardSummaryResponse.builder()
                .todaySummary(todaySummary)
                .monthlySummary(monthlySummary)
                .inventoryAlerts(alerts)
                .recentSales(List.of())
                .topSellingProducts(List.of())
                .build();

        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/sales-chart")
    @Operation(summary = "Get sales chart data")
    public ResponseEntity<ApiResponse<List<Object>>> getSalesChartData(
            @RequestParam Long branchId,
            @RequestParam(defaultValue = "7") int days) {
        // Return placeholder for now - can be implemented with more detail
        return ResponseEntity.ok(ApiResponse.success(List.of()));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\EmployeeAuthController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class EmployeeAuthController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\GoodsReceiptController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class GoodsReceiptController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\GRNController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.inventory.CreateGRNRequest;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.inventory.GRNResponse;
import com.pharmacy.medlan.enums.GRNStatus;
import com.pharmacy.medlan.service.inventory.GRNService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/grn")
@RequiredArgsConstructor
@Tag(name = "GRN", description = "Goods Receipt Note Management APIs")
public class GRNController {

    private final GRNService grnService;

    @PostMapping
    @Operation(summary = "Create a new GRN")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<GRNResponse>> createGRN(
            @Valid @RequestBody CreateGRNRequest request) {
        GRNResponse grn = grnService.createGRN(request);
        return ResponseEntity.ok(ApiResponse.success("GRN created successfully", grn));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update an existing GRN")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<GRNResponse>> updateGRN(
            @PathVariable Long id,
            @Valid @RequestBody CreateGRNRequest request) {
        GRNResponse grn = grnService.updateGRN(id, request);
        return ResponseEntity.ok(ApiResponse.success("GRN updated successfully", grn));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get GRN by ID")
    public ResponseEntity<ApiResponse<GRNResponse>> getGRNById(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(grnService.getGRNById(id)));
    }

    @GetMapping("/number/{grnNumber}")
    @Operation(summary = "Get GRN by number")
    public ResponseEntity<ApiResponse<GRNResponse>> getGRNByNumber(@PathVariable String grnNumber) {
        return ResponseEntity.ok(ApiResponse.success(grnService.getGRNByNumber(grnNumber)));
    }

    @GetMapping
    @Operation(summary = "Get all GRNs with pagination")
    public ResponseEntity<ApiResponse<Page<GRNResponse>>> getAllGRNs(Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(grnService.getAllGRNs(pageable)));
    }

    @GetMapping("/branch/{branchId}")
    @Operation(summary = "Get GRNs by branch")
    public ResponseEntity<ApiResponse<Page<GRNResponse>>> getGRNsByBranch(
            @PathVariable Long branchId, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(grnService.getGRNsByBranch(branchId, pageable)));
    }

    @GetMapping("/supplier/{supplierId}")
    @Operation(summary = "Get GRNs by supplier")
    public ResponseEntity<ApiResponse<Page<GRNResponse>>> getGRNsBySupplier(
            @PathVariable Long supplierId, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(grnService.getGRNsBySupplier(supplierId, pageable)));
    }

    @GetMapping("/date-range")
    @Operation(summary = "Get GRNs by date range")
    public ResponseEntity<ApiResponse<List<GRNResponse>>> getGRNsByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(ApiResponse.success(grnService.getGRNsByDateRange(startDate, endDate)));
    }

    @GetMapping("/status/{status}")
    @Operation(summary = "Get GRNs by status")
    public ResponseEntity<ApiResponse<Page<GRNResponse>>> getGRNsByStatus(
            @PathVariable GRNStatus status, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(grnService.getGRNsByStatus(status, pageable)));
    }

    @PostMapping("/{id}/approve")
    @Operation(summary = "Approve a GRN")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    public ResponseEntity<ApiResponse<GRNResponse>> approveGRN(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success("GRN approved", grnService.approveGRN(id)));
    }

    @PostMapping("/{id}/reject")
    @Operation(summary = "Reject a GRN")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    public ResponseEntity<ApiResponse<GRNResponse>> rejectGRN(
            @PathVariable Long id,
            @RequestParam String reason) {
        return ResponseEntity.ok(ApiResponse.success("GRN rejected", grnService.rejectGRN(id, reason)));
    }

    @PostMapping("/{id}/cancel")
    @Operation(summary = "Cancel a GRN")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    public ResponseEntity<ApiResponse<GRNResponse>> cancelGRN(
            @PathVariable Long id,
            @RequestParam String reason) {
        return ResponseEntity.ok(ApiResponse.success("GRN cancelled", grnService.cancelGRN(id, reason)));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\InventoryController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.inventory.InventoryBatchResponse;
import com.pharmacy.medlan.dto.response.inventory.InventoryResponse;
import com.pharmacy.medlan.service.inventory.InventoryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/inventory")
@RequiredArgsConstructor
@Tag(name = "Inventory", description = "Inventory Management APIs")
public class InventoryController {

    private final InventoryService inventoryService;

    @GetMapping("/low-stock")
    @Operation(summary = "Get all low stock inventory across all branches")
    public ResponseEntity<ApiResponse<List<InventoryResponse>>> getAllLowStockInventory() {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getAllLowStockInventory()));
    }

    @GetMapping("/out-of-stock")
    @Operation(summary = "Get all out of stock inventory across all branches")
    public ResponseEntity<ApiResponse<List<InventoryResponse>>> getAllOutOfStockInventory() {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getAllOutOfStockInventory()));
    }

    @GetMapping("/product/{productId}/branch/{branchId}")
    @Operation(summary = "Get inventory by product and branch")
    public ResponseEntity<ApiResponse<InventoryResponse>> getInventoryByProductAndBranch(
            @PathVariable Long productId,
            @PathVariable Long branchId) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getInventoryByProductAndBranch(productId, branchId)));
    }

    @GetMapping("/branch/{branchId}")
    @Operation(summary = "Get all inventory by branch")
    public ResponseEntity<ApiResponse<Page<InventoryResponse>>> getInventoryByBranch(
            @PathVariable Long branchId, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getInventoryByBranch(branchId, pageable)));
    }

    @GetMapping("/branch/{branchId}/low-stock")
    @Operation(summary = "Get low stock inventory")
    public ResponseEntity<ApiResponse<List<InventoryResponse>>> getLowStockInventory(
            @PathVariable Long branchId) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getLowStockInventory(branchId)));
    }

    @GetMapping("/branch/{branchId}/out-of-stock")
    @Operation(summary = "Get out of stock inventory")
    public ResponseEntity<ApiResponse<List<InventoryResponse>>> getOutOfStockInventory(
            @PathVariable Long branchId) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getOutOfStockInventory(branchId)));
    }

    @GetMapping("/batches/product/{productId}/branch/{branchId}")
    @Operation(summary = "Get batches by product and branch")
    public ResponseEntity<ApiResponse<List<InventoryBatchResponse>>> getBatchesByProduct(
            @PathVariable Long productId,
            @PathVariable Long branchId) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getBatchesByProduct(productId, branchId)));
    }

    @GetMapping("/branch/{branchId}/expiring")
    @Operation(summary = "Get expiring batches")
    public ResponseEntity<ApiResponse<List<InventoryBatchResponse>>> getExpiringBatches(
            @PathVariable Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate alertDate) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getExpiringBatches(branchId, alertDate)));
    }

    @GetMapping("/branch/{branchId}/expired")
    @Operation(summary = "Get expired batches")
    public ResponseEntity<ApiResponse<List<InventoryBatchResponse>>> getExpiredBatches(
            @PathVariable Long branchId) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getExpiredBatches(branchId)));
    }

    @GetMapping("/available-quantity/product/{productId}/branch/{branchId}")
    @Operation(summary = "Get available quantity for a product")
    public ResponseEntity<ApiResponse<Integer>> getAvailableQuantity(
            @PathVariable Long productId,
            @PathVariable Long branchId) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getAvailableQuantity(productId, branchId)));
    }

    @GetMapping("/expiring")
    @Operation(summary = "Get all expiring batches across all branches")
    public ResponseEntity<ApiResponse<Page<InventoryBatchResponse>>> getAllExpiringBatches(
            @RequestParam(defaultValue = "90") int days,
            Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getAllExpiringBatches(days, pageable)));
    }

    @GetMapping("/expired")
    @Operation(summary = "Get all expired batches across all branches")
    public ResponseEntity<ApiResponse<Page<InventoryBatchResponse>>> getAllExpiredBatches(
            Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(
                inventoryService.getAllExpiredBatches(pageable)));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\InventoryTransactionController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class InventoryTransactionController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\InvoiceController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.pos.InvoiceResponse;
import com.pharmacy.medlan.enums.InvoiceStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.service.pos.InvoiceService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/invoices")
@RequiredArgsConstructor
@Tag(name = "Invoices", description = "Invoice Management APIs")
public class InvoiceController {

    private final InvoiceService invoiceService;

    @GetMapping("/{id}")
    @Operation(summary = "Get invoice by ID")
    public ResponseEntity<ApiResponse<InvoiceResponse>> getInvoiceById(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(invoiceService.getInvoiceById(id)));
    }

    @GetMapping("/number/{invoiceNumber}")
    @Operation(summary = "Get invoice by number")
    public ResponseEntity<ApiResponse<InvoiceResponse>> getInvoiceByNumber(
            @PathVariable String invoiceNumber) {
        return ResponseEntity.ok(ApiResponse.success(invoiceService.getInvoiceByNumber(invoiceNumber)));
    }

    @GetMapping
    @Operation(summary = "Get all invoices with pagination")
    public ResponseEntity<ApiResponse<Page<InvoiceResponse>>> getAllInvoices(Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(invoiceService.getAllInvoices(pageable)));
    }

    @GetMapping("/branch/{branchId}")
    @Operation(summary = "Get invoices by branch")
    public ResponseEntity<ApiResponse<Page<InvoiceResponse>>> getInvoicesByBranch(
            @PathVariable Long branchId, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(invoiceService.getInvoicesByBranch(branchId, pageable)));
    }

    @GetMapping("/customer/{customerId}")
    @Operation(summary = "Get invoices by customer")
    public ResponseEntity<ApiResponse<Page<InvoiceResponse>>> getInvoicesByCustomer(
            @PathVariable Long customerId, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(invoiceService.getInvoicesByCustomer(customerId, pageable)));
    }

    @GetMapping("/date-range")
    @Operation(summary = "Get invoices by date range")
    public ResponseEntity<ApiResponse<List<InvoiceResponse>>> getInvoicesByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(ApiResponse.success(
                invoiceService.getInvoicesByDateRange(startDate, endDate)));
    }

    @GetMapping("/status/{status}")
    @Operation(summary = "Get invoices by status")
    public ResponseEntity<ApiResponse<Page<InvoiceResponse>>> getInvoicesByStatus(
            @PathVariable InvoiceStatus status, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(invoiceService.getInvoicesByStatus(status, pageable)));
    }

    @GetMapping("/payment-status/{paymentStatus}")
    @Operation(summary = "Get invoices by payment status")
    public ResponseEntity<ApiResponse<Page<InvoiceResponse>>> getInvoicesByPaymentStatus(
            @PathVariable PaymentStatus paymentStatus, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(
                invoiceService.getInvoicesByPaymentStatus(paymentStatus, pageable)));
    }

    @PostMapping("/{id}/payment")
    @Operation(summary = "Record payment for invoice")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'CASHIER')")
    public ResponseEntity<ApiResponse<InvoiceResponse>> recordPayment(
            @PathVariable Long id,
            @RequestParam BigDecimal amount,
            @RequestParam(required = false) String paymentReference) {
        return ResponseEntity.ok(ApiResponse.success("Payment recorded", 
                invoiceService.recordPayment(id, amount, paymentReference)));
    }

    @GetMapping("/customer/{customerId}/outstanding")
    @Operation(summary = "Get total outstanding amount by customer")
    public ResponseEntity<ApiResponse<BigDecimal>> getTotalOutstandingByCustomer(
            @PathVariable Long customerId) {
        return ResponseEntity.ok(ApiResponse.success(
                invoiceService.getTotalOutstandingByCustomer(customerId)));
    }

    @GetMapping("/overdue")
    @Operation(summary = "Get overdue invoices")
    public ResponseEntity<ApiResponse<List<InvoiceResponse>>> getOverdueInvoices() {
        return ResponseEntity.ok(ApiResponse.success(invoiceService.getOverdueInvoices()));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\LegacyMigrationController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class LegacyMigrationController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\NotificationController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.validation.annotation.RateLimit;
import com.pharmacy.medlan.dto.request.NotificationRequest;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.model.notification.Notification;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.user.UserRepository;
import com.pharmacy.medlan.service.notification.NotificationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

/**
 * REST Controller for notification management
 */
@Slf4j
@RestController
@RequestMapping("/api/notifications")
@RequiredArgsConstructor
@Tag(name = "Notifications", description = "Notification management APIs")
public class NotificationController {

    private final NotificationService notificationService;
    private final UserRepository userRepository;

    @GetMapping
    @Operation(summary = "Get all notifications for current user")
    @RateLimit(key = "default", capacity = 100, refillTokens = 100, refillSeconds = 60)
    public ResponseEntity<ApiResponse<List<Notification>>> getUserNotifications(
            @AuthenticationPrincipal UserDetails userDetails) {
        
        // In real implementation, get user ID from UserDetails
        // For now, using a placeholder - this should be enhanced
        Long userId = extractUserId(userDetails);
        List<Notification> notifications = notificationService.getUserNotifications(userId);
        
        return ResponseEntity.ok(ApiResponse.success("Notifications retrieved successfully", notifications));
    }

    @GetMapping("/unread")
    @Operation(summary = "Get unread notifications for current user")
    @RateLimit(key = "default", capacity = 100, refillTokens = 100, refillSeconds = 60)
    public ResponseEntity<ApiResponse<List<Notification>>> getUnreadNotifications(
            @AuthenticationPrincipal UserDetails userDetails) {
        
        Long userId = extractUserId(userDetails);
        List<Notification> notifications = notificationService.getUnreadNotifications(userId);
        
        return ResponseEntity.ok(ApiResponse.success("Unread notifications retrieved successfully", notifications));
    }

    @GetMapping("/count")
    @Operation(summary = "Get unread notification count")
    @RateLimit(key = "default", capacity = 100, refillTokens = 100, refillSeconds = 60)
    public ResponseEntity<ApiResponse<Map<String, Integer>>> getUnreadCount(
            @AuthenticationPrincipal UserDetails userDetails) {
        
        Long userId = extractUserId(userDetails);
        int count = notificationService.getUnreadCount(userId);
        
        return ResponseEntity.ok(ApiResponse.success("Unread count retrieved successfully", 
                Map.of("unreadCount", count)));
    }

    @PostMapping
    @Operation(summary = "Send a notification")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @RateLimit(key = "default", capacity = 50, refillTokens = 50, refillSeconds = 60)
    public ResponseEntity<ApiResponse<Notification>> sendNotification(
            @Valid @RequestBody NotificationRequest request) {
        
        log.info("Sending notification to user: {}", request.getUserId());
        Notification notification = notificationService.sendNotification(request);
        
        return ResponseEntity.ok(ApiResponse.success("Notification sent successfully", notification));
    }

    @PostMapping("/bulk")
    @Operation(summary = "Send notifications to multiple users")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @RateLimit(key = "bulk", capacity = 10, refillTokens = 10, refillSeconds = 60)
    public ResponseEntity<ApiResponse<List<Notification>>> sendBulkNotifications(
            @Valid @RequestBody NotificationRequest request,
            @RequestParam List<Long> userIds) {
        
        log.info("Sending bulk notifications to {} users", userIds.size());
        List<Notification> notifications = notificationService.sendBulkNotifications(request, userIds);
        
        return ResponseEntity.ok(ApiResponse.success("Bulk notifications sent successfully", notifications));
    }

    @PostMapping("/branch/{branchId}")
    @Operation(summary = "Send notification to all users in a branch")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @RateLimit(key = "bulk", capacity = 10, refillTokens = 10, refillSeconds = 60)
    public ResponseEntity<ApiResponse<List<Notification>>> sendToBranch(
            @PathVariable Long branchId,
            @Valid @RequestBody NotificationRequest request) {
        
        log.info("Sending notification to all users in branch: {}", branchId);
        List<Notification> notifications = notificationService.sendToBranch(branchId, request);
        
        return ResponseEntity.ok(ApiResponse.success("Branch notifications sent successfully", notifications));
    }

    @PostMapping("/role")
    @Operation(summary = "Send notification to users with specific role")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @RateLimit(key = "bulk", capacity = 10, refillTokens = 10, refillSeconds = 60)
    public ResponseEntity<ApiResponse<List<Notification>>> sendToRole(
            @RequestParam Long branchId,
            @RequestParam String role,
            @Valid @RequestBody NotificationRequest request) {
        
        log.info("Sending notification to role {} in branch: {}", role, branchId);
        List<Notification> notifications = notificationService.sendToRole(branchId, role, request);
        
        return ResponseEntity.ok(ApiResponse.success("Role notifications sent successfully", notifications));
    }

    @PutMapping("/{notificationId}/read")
    @Operation(summary = "Mark notification as read")
    @RateLimit(key = "default", capacity = 100, refillTokens = 100, refillSeconds = 60)
    public ResponseEntity<ApiResponse<Void>> markAsRead(@PathVariable Long notificationId) {
        
        log.info("Marking notification {} as read", notificationId);
        notificationService.markAsRead(notificationId);
        
        return ResponseEntity.ok(ApiResponse.<Void>success("Notification marked as read"));
    }

    @PutMapping("/read-all")
    @Operation(summary = "Mark all notifications as read")
    @RateLimit(key = "default", capacity = 50, refillTokens = 50, refillSeconds = 60)
    public ResponseEntity<ApiResponse<Void>> markAllAsRead(
            @AuthenticationPrincipal UserDetails userDetails) {
        
        Long userId = extractUserId(userDetails);
        log.info("Marking all notifications as read for user: {}", userId);
        notificationService.markAllAsRead(userId);
        
        return ResponseEntity.ok(ApiResponse.<Void>success("All notifications marked as read"));
    }

    @DeleteMapping("/{notificationId}")
    @Operation(summary = "Delete a notification")
    @RateLimit(key = "default", capacity = 50, refillTokens = 50, refillSeconds = 60)
    public ResponseEntity<ApiResponse<Void>> deleteNotification(@PathVariable Long notificationId) {
        
        log.info("Deleting notification: {}", notificationId);
        notificationService.deleteNotification(notificationId);
        
        return ResponseEntity.ok(ApiResponse.<Void>success("Notification deleted"));
    }

    @DeleteMapping("/all")
    @Operation(summary = "Delete all notifications for current user")
    @RateLimit(key = "default", capacity = 10, refillTokens = 10, refillSeconds = 60)
    public ResponseEntity<ApiResponse<Void>> deleteAllNotifications(
            @AuthenticationPrincipal UserDetails userDetails) {
        
        Long userId = extractUserId(userDetails);
        log.info("Deleting all notifications for user: {}", userId);
        notificationService.deleteAllNotifications(userId);
        
        return ResponseEntity.ok(ApiResponse.<Void>success("All notifications deleted"));
    }

    /**
     * Extract user ID from UserDetails by querying the repository
     */
    private Long extractUserId(UserDetails userDetails) {
        if (userDetails == null) {
            return 1L; // Default fallback
        }
        User user = userRepository.findByUsername(userDetails.getUsername()).orElse(null);
        return user != null ? user.getId() : 1L;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\PayrollController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class PayrollController{
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\PrescriptionController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class PrescriptionController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\ProductBinCardController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class ProductBinCardController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\ProductController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.product.CreateProductRequest;
import com.pharmacy.medlan.dto.request.product.UpdateProductRequest;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.common.PageResponse;
import com.pharmacy.medlan.dto.response.product.ProductResponse;
import com.pharmacy.medlan.service.product.ProductService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
@Tag(name = "Product Management", description = "APIs for managing products")
public class ProductController {

    private final ProductService productService;

    @PostMapping
    @Operation(summary = "Create product", description = "Create a new product")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<ProductResponse>> createProduct(
            @Valid @RequestBody CreateProductRequest request) {
        ProductResponse response = productService.createProduct(request);
        return ResponseEntity.ok(ApiResponse.success("Product created successfully", response));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update product", description = "Update an existing product")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<ProductResponse>> updateProduct(
            @PathVariable Long id,
            @Valid @RequestBody UpdateProductRequest request) {
        ProductResponse response = productService.updateProduct(id, request);
        return ResponseEntity.ok(ApiResponse.success("Product updated successfully", response));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get product by ID", description = "Get product details by ID")
    public ResponseEntity<ApiResponse<ProductResponse>> getProductById(@PathVariable Long id) {
        ProductResponse response = productService.getProductById(id);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/code/{productCode}")
    @Operation(summary = "Get product by code", description = "Get product details by product code")
    public ResponseEntity<ApiResponse<ProductResponse>> getProductByCode(@PathVariable String productCode) {
        ProductResponse response = productService.getProductByCode(productCode);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping
    @Operation(summary = "Get all products", description = "Get all products with pagination")
    public ResponseEntity<ApiResponse<PageResponse<ProductResponse>>> getAllProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "productName") String sortBy,
            @RequestParam(defaultValue = "asc") String sortDir) {
        Sort sort = sortDir.equalsIgnoreCase("desc") ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
        Pageable pageable = PageRequest.of(page, size, sort);
        Page<ProductResponse> productsPage = productService.getAllProducts(pageable);
        return ResponseEntity.ok(ApiResponse.success(PageResponse.of(productsPage)));
    }

    @GetMapping("/search")
    @Operation(summary = "Search products", description = "Search products by name, code, or barcode")
    public ResponseEntity<ApiResponse<List<ProductResponse>>> searchProducts(@RequestParam String query) {
        List<ProductResponse> response = productService.searchProducts(query);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/low-stock")
    @Operation(summary = "Get low stock products", description = "Get products below reorder level")
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getLowStockProducts(
            @RequestParam(required = false) Long branchId) {
        List<ProductResponse> response = productService.getLowStockProducts(branchId);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete product", description = "Soft delete a product")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER')")
    public ResponseEntity<ApiResponse<Void>> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.ok(ApiResponse.success("Product deleted successfully"));
    }

    @PatchMapping("/{id}/discontinue")
    @Operation(summary = "Discontinue product", description = "Mark product as discontinued")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<Void>> discontinueProduct(@PathVariable Long id) {
        productService.discontinueProduct(id);
        return ResponseEntity.ok(ApiResponse.success("Product discontinued successfully"));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\PurchaseOrderController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.supplier.CreatePurchaseOrderRequest;
import com.pharmacy.medlan.dto.response.supplier.PurchaseOrderResponse;
import com.pharmacy.medlan.enums.PurchaseOrderStatus;
import com.pharmacy.medlan.service.supplier.PurchaseOrderService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/purchase-orders")
@RequiredArgsConstructor
@Tag(name = "Purchase Orders", description = "APIs for managing purchase orders")
public class PurchaseOrderController {

    private final PurchaseOrderService purchaseOrderService;

    @PostMapping
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Create purchase order", description = "Create a new purchase order")
    public ResponseEntity<PurchaseOrderResponse> createPurchaseOrder(
            @Valid @RequestBody CreatePurchaseOrderRequest request) {
        return new ResponseEntity<>(purchaseOrderService.createPurchaseOrder(request), HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get purchase order by ID", description = "Retrieve a purchase order by its ID")
    public ResponseEntity<PurchaseOrderResponse> getById(@PathVariable Long id) {
        return ResponseEntity.ok(purchaseOrderService.getById(id));
    }

    @GetMapping("/number/{poNumber}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get purchase order by PO number", description = "Retrieve a purchase order by its number")
    public ResponseEntity<PurchaseOrderResponse> getByPoNumber(@PathVariable String poNumber) {
        return ResponseEntity.ok(purchaseOrderService.getByPoNumber(poNumber));
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get all purchase orders", description = "Retrieve all purchase orders with pagination")
    public ResponseEntity<Page<PurchaseOrderResponse>> getAllPurchaseOrders(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sortBy,
            @RequestParam(defaultValue = "desc") String sortDir) {
        Sort sort = sortDir.equalsIgnoreCase("desc") ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
        Pageable pageable = PageRequest.of(page, size, sort);
        return ResponseEntity.ok(purchaseOrderService.getAllPurchaseOrders(pageable));
    }

    @GetMapping("/supplier/{supplierId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get purchase orders by supplier", description = "Retrieve purchase orders for a supplier")
    public ResponseEntity<List<PurchaseOrderResponse>> getBySupplier(@PathVariable Long supplierId) {
        return ResponseEntity.ok(purchaseOrderService.getBySupplier(supplierId));
    }

    @GetMapping("/branch/{branchId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get purchase orders by branch", description = "Retrieve purchase orders for a branch")
    public ResponseEntity<List<PurchaseOrderResponse>> getByBranch(@PathVariable Long branchId) {
        return ResponseEntity.ok(purchaseOrderService.getByBranch(branchId));
    }

    @GetMapping("/status/{status}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get purchase orders by status", description = "Retrieve purchase orders by status")
    public ResponseEntity<List<PurchaseOrderResponse>> getByStatus(@PathVariable PurchaseOrderStatus status) {
        return ResponseEntity.ok(purchaseOrderService.getByStatus(status));
    }

    @GetMapping("/date-range")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get purchase orders by date range", description = "Retrieve purchase orders within a date range")
    public ResponseEntity<List<PurchaseOrderResponse>> getByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(purchaseOrderService.getByDateRange(startDate, endDate));
    }

    @PutMapping("/{id}/status")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN', 'MANAGER')")
    @Operation(summary = "Update purchase order status", description = "Update the status of a purchase order")
    public ResponseEntity<PurchaseOrderResponse> updateStatus(
            @PathVariable Long id,
            @RequestParam PurchaseOrderStatus status) {
        return ResponseEntity.ok(purchaseOrderService.updateStatus(id, status));
    }

    @PostMapping("/{id}/approve")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN', 'MANAGER')")
    @Operation(summary = "Approve purchase order", description = "Approve a purchase order")
    public ResponseEntity<PurchaseOrderResponse> approvePurchaseOrder(@PathVariable Long id) {
        return ResponseEntity.ok(purchaseOrderService.approvePurchaseOrder(id));
    }

    @PostMapping("/{id}/reject")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN', 'MANAGER')")
    @Operation(summary = "Reject purchase order", description = "Reject a purchase order")
    public ResponseEntity<PurchaseOrderResponse> rejectPurchaseOrder(
            @PathVariable Long id,
            @RequestParam String reason) {
        return ResponseEntity.ok(purchaseOrderService.rejectPurchaseOrder(id, reason));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    @Operation(summary = "Delete purchase order", description = "Delete a draft purchase order (admin only)")
    public ResponseEntity<Void> deletePurchaseOrder(@PathVariable Long id) {
        purchaseOrderService.deletePurchaseOrder(id);
        return ResponseEntity.noContent().build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\ReportController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.response.pos.SaleResponse;
import com.pharmacy.medlan.service.report.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/reports")
@RequiredArgsConstructor
@Tag(name = "Reports", description = "Reporting APIs for sales, inventory, and financials")
public class ReportController {

    private final SalesReportService salesReportService;
    private final InventoryReportService inventoryReportService;
    private final FinancialReportService financialReportService;
    private final AlertService alertService;

    // ===================== SALES REPORTS =====================

    @GetMapping("/sales/total")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get total sales", description = "Get total sales amount for a date range")
    public ResponseEntity<BigDecimal> getTotalSales(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(salesReportService.getTotalSales(branchId, startDate, endDate));
    }

    @GetMapping("/sales/count")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get sales count", description = "Get number of sales for a date range")
    public ResponseEntity<Long> getSalesCount(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(salesReportService.getSalesCount(branchId, startDate, endDate));
    }

    @GetMapping("/sales/details")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get sales report", description = "Get detailed sales report for a date range")
    public ResponseEntity<List<SaleResponse>> getSalesReport(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(salesReportService.getSalesReport(branchId, startDate, endDate));
    }

    @GetMapping("/sales/daily")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get daily sales summary", description = "Get daily sales breakdown for a date range")
    public ResponseEntity<Map<String, BigDecimal>> getDailySalesSummary(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(salesReportService.getDailySalesSummary(branchId, startDate, endDate));
    }

    @GetMapping("/sales/top-products")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get top selling products", description = "Get top selling products for a date range")
    public ResponseEntity<List<Map<String, Object>>> getTopSellingProducts(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate,
            @RequestParam(defaultValue = "10") int limit) {
        return ResponseEntity.ok(salesReportService.getTopSellingProducts(branchId, startDate, endDate, limit));
    }

    @GetMapping("/sales/by-payment-method")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get sales by payment method", description = "Get sales breakdown by payment method")
    public ResponseEntity<List<Map<String, Object>>> getSalesByPaymentMethod(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(salesReportService.getSalesByPaymentMethod(branchId, startDate, endDate));
    }

    @GetMapping("/sales/comparison")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Compare sales periods", description = "Compare sales between two periods")
    public ResponseEntity<Map<String, Object>> getSalesComparison(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate1,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate1,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate2,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate2) {
        return ResponseEntity.ok(salesReportService.getSalesComparison(branchId, startDate1, endDate1, startDate2, endDate2));
    }

    // ===================== INVENTORY REPORTS =====================

    @GetMapping("/inventory/stock-value")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get total stock value", description = "Get total value of inventory stock")
    public ResponseEntity<BigDecimal> getTotalStockValue(@RequestParam Long branchId) {
        return ResponseEntity.ok(inventoryReportService.getTotalStockValue(branchId));
    }

    @GetMapping("/inventory/stock-value/by-category")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get stock value by category", description = "Get stock value breakdown by category")
    public ResponseEntity<Map<String, BigDecimal>> getStockValueByCategory(@RequestParam Long branchId) {
        return ResponseEntity.ok(inventoryReportService.getStockValueByCategory(branchId));
    }

    @GetMapping("/inventory/low-stock")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get low stock report", description = "Get products with low stock levels")
    public ResponseEntity<List<Map<String, Object>>> getLowStockReport(@RequestParam Long branchId) {
        return ResponseEntity.ok(inventoryReportService.getLowStockReport(branchId));
    }

    @GetMapping("/inventory/expiring")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get expiring stock report", description = "Get products expiring within days threshold")
    public ResponseEntity<List<Map<String, Object>>> getExpiringStockReport(
            @RequestParam Long branchId,
            @RequestParam(defaultValue = "30") int daysToExpiry) {
        return ResponseEntity.ok(inventoryReportService.getExpiringStockReport(branchId, daysToExpiry));
    }

    @GetMapping("/inventory/expired")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get expired stock report", description = "Get all expired products")
    public ResponseEntity<List<Map<String, Object>>> getExpiredStockReport(@RequestParam Long branchId) {
        return ResponseEntity.ok(inventoryReportService.getExpiredStockReport(branchId));
    }

    @GetMapping("/inventory/summary")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get inventory summary", description = "Get overall inventory summary")
    public ResponseEntity<Map<String, Object>> getInventorySummary(@RequestParam Long branchId) {
        return ResponseEntity.ok(inventoryReportService.getInventorySummary(branchId));
    }

    @GetMapping("/inventory/dead-stock")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get dead stock report", description = "Get products with no recent sales")
    public ResponseEntity<List<Map<String, Object>>> getDeadStockReport(
            @RequestParam Long branchId,
            @RequestParam(defaultValue = "90") int daysSinceLastSale) {
        return ResponseEntity.ok(inventoryReportService.getDeadStockReport(branchId, daysSinceLastSale));
    }

    // ===================== FINANCIAL REPORTS =====================

    @GetMapping("/financial/revenue")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get total revenue", description = "Get total revenue for a date range")
    public ResponseEntity<BigDecimal> getTotalRevenue(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(financialReportService.getTotalRevenue(branchId, startDate, endDate));
    }

    @GetMapping("/financial/daily-revenue")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get daily revenue", description = "Get daily revenue breakdown")
    public ResponseEntity<Map<String, BigDecimal>> getDailyRevenue(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(financialReportService.getDailyRevenue(branchId, startDate, endDate));
    }

    @GetMapping("/financial/profit-loss")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get profit and loss report", description = "Get comprehensive P&L report")
    public ResponseEntity<Map<String, Object>> getProfitAndLossReport(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(financialReportService.getProfitAndLossReport(branchId, startDate, endDate));
    }

    @GetMapping("/financial/cash-flow")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get cash flow report", description = "Get cash flow analysis")
    public ResponseEntity<Map<String, Object>> getCashFlowReport(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(financialReportService.getCashFlowReport(branchId, startDate, endDate));
    }

    @GetMapping("/financial/receivables")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get total receivables", description = "Get total outstanding receivables")
    public ResponseEntity<BigDecimal> getTotalReceivables(@RequestParam Long branchId) {
        return ResponseEntity.ok(financialReportService.getTotalReceivables(branchId));
    }

    @GetMapping("/financial/ageing")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get ageing report", description = "Get receivables/payables ageing analysis")
    public ResponseEntity<List<Map<String, Object>>> getAgeingReport(
            @RequestParam Long branchId,
            @RequestParam(defaultValue = "receivables") String type) {
        return ResponseEntity.ok(financialReportService.getAgeingReport(branchId, type));
    }

    @GetMapping("/financial/tax-summary")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get tax summary", description = "Get tax collection summary")
    public ResponseEntity<Map<String, BigDecimal>> getTaxSummary(
            @RequestParam Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(financialReportService.getTaxSummary(branchId, startDate, endDate));
    }

    // ===================== ALERTS =====================

    @GetMapping("/alerts")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get all alerts", description = "Get all system alerts for a branch")
    public ResponseEntity<Map<String, Object>> getAllAlerts(@RequestParam Long branchId) {
        return ResponseEntity.ok(alertService.getAllAlerts(branchId));
    }

    @GetMapping("/alerts/count")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get alert count", description = "Get total number of active alerts")
    public ResponseEntity<Integer> getAlertCount(@RequestParam Long branchId) {
        return ResponseEntity.ok(alertService.getAlertCount(branchId));
    }

    @GetMapping("/alerts/low-stock")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get low stock alerts", description = "Get low stock warnings")
    public ResponseEntity<List<Map<String, Object>>> getLowStockAlerts(@RequestParam Long branchId) {
        return ResponseEntity.ok(alertService.getLowStockAlerts(branchId));
    }

    @GetMapping("/alerts/expiry")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get expiry alerts", description = "Get expiring product warnings")
    public ResponseEntity<List<Map<String, Object>>> getExpiryAlerts(
            @RequestParam Long branchId,
            @RequestParam(defaultValue = "30") int daysThreshold) {
        return ResponseEntity.ok(alertService.getExpiryAlerts(branchId, daysThreshold));
    }

    @GetMapping("/alerts/overdue-invoices")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Get overdue invoice alerts", description = "Get overdue invoice warnings")
    public ResponseEntity<List<Map<String, Object>>> getOverdueInvoiceAlerts(@RequestParam Long branchId) {
        return ResponseEntity.ok(alertService.getOverdueInvoiceAlerts(branchId));
    }

    @PostMapping("/alerts/{alertId}/acknowledge")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Acknowledge alert", description = "Mark an alert as acknowledged")
    public ResponseEntity<Void> acknowledgeAlert(@PathVariable Long alertId) {
        alertService.acknowledgeAlert(alertId);
        return ResponseEntity.ok().build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\RGRNController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.inventory.CreateRGRNRequest;
import com.pharmacy.medlan.dto.response.inventory.RGRNResponse;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.service.inventory.RGRNService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/rgrns")
@RequiredArgsConstructor
@Tag(name = "RGRN", description = "APIs for managing Return Goods Receipt Notes")
public class RGRNController {

    private final RGRNService rgrnService;

    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Create RGRN", description = "Create a new Return Goods Receipt Note")
    public ResponseEntity<RGRNResponse> createRGRN(@Valid @RequestBody CreateRGRNRequest request) {
        return new ResponseEntity<>(rgrnService.createRGRN(request), HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get RGRN by ID", description = "Retrieve an RGRN by its ID")
    public ResponseEntity<RGRNResponse> getById(@PathVariable Long id) {
        return ResponseEntity.ok(rgrnService.getById(id));
    }

    @GetMapping("/number/{rgrnNumber}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get RGRN by number", description = "Retrieve an RGRN by its number")
    public ResponseEntity<RGRNResponse> getByRgrnNumber(@PathVariable String rgrnNumber) {
        return ResponseEntity.ok(rgrnService.getByRgrnNumber(rgrnNumber));
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get all RGRNs", description = "Retrieve all RGRNs with pagination")
    public ResponseEntity<Page<RGRNResponse>> getAllRGRNs(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sortBy,
            @RequestParam(defaultValue = "desc") String sortDir) {
        Sort sort = sortDir.equalsIgnoreCase("desc") ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
        Pageable pageable = PageRequest.of(page, size, sort);
        return ResponseEntity.ok(rgrnService.getAllRGRNs(pageable));
    }

    @GetMapping("/supplier/{supplierId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get RGRNs by supplier", description = "Retrieve RGRNs for a supplier")
    public ResponseEntity<List<RGRNResponse>> getBySupplier(@PathVariable Long supplierId) {
        return ResponseEntity.ok(rgrnService.getBySupplier(supplierId));
    }

    @GetMapping("/branch/{branchId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get RGRNs by branch", description = "Retrieve RGRNs for a branch")
    public ResponseEntity<List<RGRNResponse>> getByBranch(@PathVariable Long branchId) {
        return ResponseEntity.ok(rgrnService.getByBranch(branchId));
    }

    @GetMapping("/grn/{grnId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get RGRNs by original GRN", description = "Retrieve RGRNs linked to a GRN")
    public ResponseEntity<List<RGRNResponse>> getByOriginalGrn(@PathVariable Long grnId) {
        return ResponseEntity.ok(rgrnService.getByOriginalGrn(grnId));
    }

    @GetMapping("/refund-status/{status}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get RGRNs by refund status", description = "Retrieve RGRNs by refund status")
    public ResponseEntity<List<RGRNResponse>> getByRefundStatus(@PathVariable PaymentStatus status) {
        return ResponseEntity.ok(rgrnService.getByRefundStatus(status));
    }

    @GetMapping("/date-range")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get RGRNs by date range", description = "Retrieve RGRNs within a date range")
    public ResponseEntity<List<RGRNResponse>> getByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(rgrnService.getByDateRange(startDate, endDate));
    }

    @PutMapping("/{id}/refund-status")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Update refund status", description = "Update the refund status of an RGRN")
    public ResponseEntity<RGRNResponse> updateRefundStatus(
            @PathVariable Long id,
            @RequestParam PaymentStatus refundStatus) {
        return ResponseEntity.ok(rgrnService.updateRefundStatus(id, refundStatus));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Delete RGRN", description = "Delete an RGRN (admin only)")
    public ResponseEntity<Void> deleteRGRN(@PathVariable Long id) {
        rgrnService.deleteRGRN(id);
        return ResponseEntity.noContent().build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\SaleController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.pos.CreateSaleRequest;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.pos.SaleResponse;
import com.pharmacy.medlan.enums.SaleStatus;
import com.pharmacy.medlan.service.pos.SaleService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/sales")
@RequiredArgsConstructor
@Tag(name = "Sales", description = "POS Sales Management APIs")
public class SaleController {

    private final SaleService saleService;

    @PostMapping
    @Operation(summary = "Create a new sale")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'CASHIER')")
    public ResponseEntity<ApiResponse<SaleResponse>> createSale(
            @Valid @RequestBody CreateSaleRequest request) {
        SaleResponse sale = saleService.createSale(request);
        return ResponseEntity.ok(ApiResponse.success("Sale created successfully", sale));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get sale by ID")
    public ResponseEntity<ApiResponse<SaleResponse>> getSaleById(@PathVariable Long id) {
        return ResponseEntity.ok(ApiResponse.success(saleService.getSaleById(id)));
    }

    @GetMapping("/number/{saleNumber}")
    @Operation(summary = "Get sale by sale number")
    public ResponseEntity<ApiResponse<SaleResponse>> getSaleBySaleNumber(
            @PathVariable String saleNumber) {
        return ResponseEntity.ok(ApiResponse.success(saleService.getSaleBySaleNumber(saleNumber)));
    }

    @GetMapping
    @Operation(summary = "Get all sales with pagination")
    public ResponseEntity<ApiResponse<Page<SaleResponse>>> getAllSales(Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(saleService.getAllSales(pageable)));
    }

    @GetMapping("/branch/{branchId}")
    @Operation(summary = "Get sales by branch")
    public ResponseEntity<ApiResponse<Page<SaleResponse>>> getSalesByBranch(
            @PathVariable Long branchId, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(saleService.getSalesByBranch(branchId, pageable)));
    }

    @GetMapping("/customer/{customerId}")
    @Operation(summary = "Get sales by customer")
    public ResponseEntity<ApiResponse<Page<SaleResponse>>> getSalesByCustomer(
            @PathVariable Long customerId, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(saleService.getSalesByCustomer(customerId, pageable)));
    }

    @GetMapping("/date-range")
    @Operation(summary = "Get sales by date range")
    public ResponseEntity<ApiResponse<List<SaleResponse>>> getSalesByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate) {
        return ResponseEntity.ok(ApiResponse.success(
                saleService.getSalesByDateRange(startDate, endDate)));
    }

    @GetMapping("/branch/{branchId}/date-range")
    @Operation(summary = "Get sales by branch and date range")
    public ResponseEntity<ApiResponse<List<SaleResponse>>> getSalesByBranchAndDateRange(
            @PathVariable Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate) {
        return ResponseEntity.ok(ApiResponse.success(
                saleService.getSalesByBranchAndDateRange(branchId, startDate, endDate)));
    }

    @GetMapping("/status/{status}")
    @Operation(summary = "Get sales by status")
    public ResponseEntity<ApiResponse<Page<SaleResponse>>> getSalesByStatus(
            @PathVariable SaleStatus status, Pageable pageable) {
        return ResponseEntity.ok(ApiResponse.success(saleService.getSalesByStatus(status, pageable)));
    }

    @PostMapping("/{id}/cancel")
    @Operation(summary = "Cancel a sale")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    public ResponseEntity<ApiResponse<SaleResponse>> cancelSale(
            @PathVariable Long id,
            @RequestParam String reason) {
        return ResponseEntity.ok(ApiResponse.success("Sale cancelled", saleService.cancelSale(id, reason)));
    }

    @PostMapping("/{id}/void")
    @Operation(summary = "Void a sale")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse<SaleResponse>> voidSale(
            @PathVariable Long id,
            @RequestParam String reason) {
        return ResponseEntity.ok(ApiResponse.success("Sale voided", saleService.voidSale(id, reason)));
    }

    @GetMapping("/branch/{branchId}/total")
    @Operation(summary = "Get total sales amount by branch and date range")
    public ResponseEntity<ApiResponse<BigDecimal>> getTotalSales(
            @PathVariable Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate) {
        return ResponseEntity.ok(ApiResponse.success(
                saleService.getTotalSalesByBranchAndDate(branchId, startDate, endDate)));
    }

    @GetMapping("/branch/{branchId}/count")
    @Operation(summary = "Get sales count by branch and date range")
    public ResponseEntity<ApiResponse<Long>> getSalesCount(
            @PathVariable Long branchId,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endDate) {
        return ResponseEntity.ok(ApiResponse.success(
                saleService.getSalesCountByBranchAndDate(branchId, startDate, endDate)));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\SaleReturnController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.pos.CreateSaleReturnRequest;
import com.pharmacy.medlan.dto.response.pos.SaleReturnResponse;
import com.pharmacy.medlan.service.pos.SaleReturnService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/sale-returns")
@RequiredArgsConstructor
@Tag(name = "Sale Returns", description = "APIs for managing sale returns and refunds")
public class SaleReturnController {

    private final SaleReturnService saleReturnService;

    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST', 'CASHIER')")
    @Operation(summary = "Create sale return", description = "Process a sale return")
    public ResponseEntity<SaleReturnResponse> createSaleReturn(@Valid @RequestBody CreateSaleReturnRequest request) {
        return new ResponseEntity<>(saleReturnService.createSaleReturn(request), HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST', 'CASHIER')")
    @Operation(summary = "Get sale return by ID", description = "Retrieve a sale return by its ID")
    public ResponseEntity<SaleReturnResponse> getById(@PathVariable Long id) {
        return ResponseEntity.ok(saleReturnService.getById(id));
    }

    @GetMapping("/number/{returnNumber}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST', 'CASHIER')")
    @Operation(summary = "Get sale return by number", description = "Retrieve a sale return by its number")
    public ResponseEntity<SaleReturnResponse> getByReturnNumber(@PathVariable String returnNumber) {
        return ResponseEntity.ok(saleReturnService.getByReturnNumber(returnNumber));
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST', 'CASHIER')")
    @Operation(summary = "Get all sale returns", description = "Retrieve all sale returns with pagination")
    public ResponseEntity<Page<SaleReturnResponse>> getAllSaleReturns(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sortBy,
            @RequestParam(defaultValue = "desc") String sortDir) {
        Sort sort = sortDir.equalsIgnoreCase("desc") ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
        Pageable pageable = PageRequest.of(page, size, sort);
        return ResponseEntity.ok(saleReturnService.getAllSaleReturns(pageable));
    }

    @GetMapping("/customer/{customerId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST', 'CASHIER')")
    @Operation(summary = "Get sale returns by customer", description = "Retrieve returns for a customer")
    public ResponseEntity<List<SaleReturnResponse>> getByCustomer(@PathVariable Long customerId) {
        return ResponseEntity.ok(saleReturnService.getByCustomer(customerId));
    }

    @GetMapping("/branch/{branchId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST', 'CASHIER')")
    @Operation(summary = "Get sale returns by branch", description = "Retrieve returns for a branch")
    public ResponseEntity<List<SaleReturnResponse>> getByBranch(@PathVariable Long branchId) {
        return ResponseEntity.ok(saleReturnService.getByBranch(branchId));
    }

    @GetMapping("/date-range")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST', 'CASHIER')")
    @Operation(summary = "Get sale returns by date range", description = "Retrieve returns within a date range")
    public ResponseEntity<List<SaleReturnResponse>> getByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(saleReturnService.getByDateRange(startDate, endDate));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Delete sale return", description = "Delete a sale return (admin only)")
    public ResponseEntity<Void> deleteSaleReturn(@PathVariable Long id) {
        saleReturnService.deleteSaleReturn(id);
        return ResponseEntity.noContent().build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\ScanController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.inventory.BarcodeScanRequest;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.inventory.ScanResultResponse;
import com.pharmacy.medlan.enums.ScanContext;
import com.pharmacy.medlan.service.inventory.InventoryScanService;
import com.pharmacy.medlan.validation.annotation.RateLimit;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/scan")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Barcode Scanning", description = "APIs for barcode/QR code scanning operations")
public class ScanController {

    private final InventoryScanService inventoryScanService;

    @PostMapping
    @Operation(summary = "Process scan", description = "Process a barcode or QR code scan with context")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'CASHIER', 'INVENTORY_MANAGER')")
    @RateLimit(requests = 100, duration = 60, scope = RateLimit.Scope.USER)
    public ResponseEntity<ApiResponse<ScanResultResponse>> processScan(
            @Valid @RequestBody BarcodeScanRequest request) {
        log.info("Processing scan: {} for context: {}", request.getScanData(), request.getContext());
        ScanResultResponse result = inventoryScanService.processScan(request);
        
        if (result.isSuccess()) {
            return ResponseEntity.ok(ApiResponse.success("Scan processed successfully", result));
        } else {
            return ResponseEntity.ok(ApiResponse.error(result.getErrorMessage(), result));
        }
    }

    @GetMapping("/pos/{barcode}")
    @Operation(summary = "Quick POS lookup", description = "Quick product lookup for Point of Sale")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'CASHIER')")
    @RateLimit(requests = 200, duration = 60, scope = RateLimit.Scope.USER)
    public ResponseEntity<ApiResponse<ScanResultResponse>> quickPOSLookup(
            @PathVariable String barcode,
            @RequestParam Long branchId) {
        log.info("Quick POS lookup: barcode={}, branch={}", barcode, branchId);
        ScanResultResponse result = inventoryScanService.quickLookupForPOS(barcode, branchId);
        
        if (result.isSuccess()) {
            return ResponseEntity.ok(ApiResponse.success(result));
        } else {
            return ResponseEntity.ok(ApiResponse.error(result.getErrorMessage(), result));
        }
    }

    @GetMapping("/receiving/{barcode}")
    @Operation(summary = "Lookup for receiving", description = "Product lookup for goods receiving")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<ScanResultResponse>> lookupForReceiving(
            @PathVariable String barcode,
            @RequestParam Long branchId) {
        log.info("Lookup for receiving: barcode={}, branch={}", barcode, branchId);
        ScanResultResponse result = inventoryScanService.lookupForReceiving(barcode, branchId);
        return ResponseEntity.ok(ApiResponse.success(result));
    }

    @GetMapping("/stock-taking/{barcode}")
    @Operation(summary = "Lookup for stock taking", description = "Product lookup for physical inventory")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<ScanResultResponse>> lookupForStockTaking(
            @PathVariable String barcode,
            @RequestParam Long branchId) {
        log.info("Lookup for stock taking: barcode={}, branch={}", barcode, branchId);
        ScanResultResponse result = inventoryScanService.lookupForStockTaking(barcode, branchId);
        return ResponseEntity.ok(ApiResponse.success(result));
    }

    @PostMapping("/verify")
    @Operation(summary = "Verify product", description = "Verify product authenticity via QR code")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<ScanResultResponse>> verifyProduct(
            @RequestParam String qrData) {
        log.info("Verifying product via QR");
        ScanResultResponse result = inventoryScanService.verifyProduct(qrData);
        return ResponseEntity.ok(ApiResponse.success("Verification complete", result));
    }

    @PostMapping("/batch-qr")
    @Operation(summary = "Process batch QR", description = "Process batch-level QR code scan")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'PHARMACIST', 'INVENTORY_MANAGER')")
    public ResponseEntity<ApiResponse<ScanResultResponse>> processBatchQR(
            @RequestParam String qrData,
            @RequestParam Long branchId) {
        log.info("Processing batch QR for branch: {}", branchId);
        ScanResultResponse result = inventoryScanService.processBatchQRScan(qrData, branchId);
        return ResponseEntity.ok(ApiResponse.success(result));
    }

    @PostMapping("/bulk")
    @Operation(summary = "Bulk scan processing", description = "Process multiple barcodes at once")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER', 'INVENTORY_MANAGER')")
    @RateLimit(requests = 10, duration = 60, scope = RateLimit.Scope.USER, bucket = "bulk_scan")
    public ResponseEntity<ApiResponse<List<ScanResultResponse>>> processBulkScans(
            @RequestBody List<String> barcodes,
            @RequestParam Long branchId,
            @Parameter(description = "Scan context") @RequestParam(defaultValue = "STOCK_TAKING") ScanContext context) {
        log.info("Processing bulk scans: {} barcodes for context: {}", barcodes.size(), context);
        
        if (barcodes.size() > 100) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error("Maximum 100 barcodes allowed per request"));
        }
        
        List<ScanResultResponse> results = inventoryScanService.processBulkScans(barcodes, branchId, context);
        return ResponseEntity.ok(ApiResponse.success("Bulk scan processed", results));
    }

    @GetMapping("/history")
    @Operation(summary = "Get scan history", description = "Get recent scan history for audit")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<List<ScanResultResponse>>> getScanHistory(
            @RequestParam Long branchId,
            @RequestParam(required = false) Long userId,
            @RequestParam(defaultValue = "50") int limit) {
        log.info("Getting scan history for branch: {}", branchId);
        List<ScanResultResponse> history = inventoryScanService.getScanHistory(branchId, userId, limit);
        return ResponseEntity.ok(ApiResponse.success(history));
    }

    @GetMapping("/contexts")
    @Operation(summary = "Get scan contexts", description = "Get all available scan contexts")
    public ResponseEntity<ApiResponse<ScanContext[]>> getScanContexts() {
        return ResponseEntity.ok(ApiResponse.success(ScanContext.values()));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\StockTransferController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.inventory.ApproveStockTransferRequest;
import com.pharmacy.medlan.dto.request.inventory.CreateStockTransferRequest;
import com.pharmacy.medlan.dto.response.inventory.StockTransferResponse;
import com.pharmacy.medlan.enums.StockTransferStatus;
import com.pharmacy.medlan.service.inventory.StockTransferService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequestMapping("/api/stock-transfers")
@RequiredArgsConstructor
@Tag(name = "Stock Transfer", description = "APIs for managing stock transfers between branches")
public class StockTransferController {

    private final StockTransferService stockTransferService;

    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Create stock transfer", description = "Create a new stock transfer request")
    public ResponseEntity<StockTransferResponse> createStockTransfer(
            @Valid @RequestBody CreateStockTransferRequest request) {
        return new ResponseEntity<>(stockTransferService.createStockTransfer(request), HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get stock transfer by ID", description = "Retrieve a stock transfer by its ID")
    public ResponseEntity<StockTransferResponse> getById(@PathVariable Long id) {
        return ResponseEntity.ok(stockTransferService.getById(id));
    }

    @GetMapping("/number/{transferNumber}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get stock transfer by number", description = "Retrieve a stock transfer by its number")
    public ResponseEntity<StockTransferResponse> getByTransferNumber(@PathVariable String transferNumber) {
        return ResponseEntity.ok(stockTransferService.getByTransferNumber(transferNumber));
    }

    @GetMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get all stock transfers", description = "Retrieve all stock transfers with pagination")
    public ResponseEntity<Page<StockTransferResponse>> getAllStockTransfers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "createdAt") String sortBy,
            @RequestParam(defaultValue = "desc") String sortDir) {
        Sort sort = sortDir.equalsIgnoreCase("desc") ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
        Pageable pageable = PageRequest.of(page, size, sort);
        return ResponseEntity.ok(stockTransferService.getAllStockTransfers(pageable));
    }

    @GetMapping("/from-branch/{branchId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get transfers by source branch", description = "Retrieve transfers originating from a branch")
    public ResponseEntity<List<StockTransferResponse>> getByFromBranch(@PathVariable Long branchId) {
        return ResponseEntity.ok(stockTransferService.getByFromBranch(branchId));
    }

    @GetMapping("/to-branch/{branchId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get transfers by destination branch", description = "Retrieve transfers destined to a branch")
    public ResponseEntity<List<StockTransferResponse>> getByToBranch(@PathVariable Long branchId) {
        return ResponseEntity.ok(stockTransferService.getByToBranch(branchId));
    }

    @GetMapping("/branch/{branchId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get transfers by branch", description = "Retrieve all transfers involving a branch")
    public ResponseEntity<List<StockTransferResponse>> getByBranch(@PathVariable Long branchId) {
        return ResponseEntity.ok(stockTransferService.getByBranch(branchId));
    }

    @GetMapping("/status/{status}")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get transfers by status", description = "Retrieve transfers by status")
    public ResponseEntity<List<StockTransferResponse>> getByStatus(@PathVariable StockTransferStatus status) {
        return ResponseEntity.ok(stockTransferService.getByStatus(status));
    }

    @GetMapping("/date-range")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Get transfers by date range", description = "Retrieve transfers within a date range")
    public ResponseEntity<List<StockTransferResponse>> getByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        return ResponseEntity.ok(stockTransferService.getByDateRange(startDate, endDate));
    }

    @PostMapping("/{id}/approve")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Approve stock transfer", description = "Approve a pending stock transfer")
    public ResponseEntity<StockTransferResponse> approveStockTransfer(
            @PathVariable Long id,
            @RequestBody(required = false) ApproveStockTransferRequest request) {
        return ResponseEntity.ok(stockTransferService.approveStockTransfer(id, request));
    }

    @PostMapping("/{id}/receive")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER', 'PHARMACIST')")
    @Operation(summary = "Receive stock transfer", description = "Mark a stock transfer as received")
    public ResponseEntity<StockTransferResponse> receiveStockTransfer(
            @PathVariable Long id,
            @RequestParam Long receivedByUserId) {
        return ResponseEntity.ok(stockTransferService.receiveStockTransfer(id, receivedByUserId));
    }

    @PostMapping("/{id}/reject")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Reject stock transfer", description = "Reject a pending stock transfer")
    public ResponseEntity<StockTransferResponse> rejectStockTransfer(
            @PathVariable Long id,
            @RequestParam String reason) {
        return ResponseEntity.ok(stockTransferService.rejectStockTransfer(id, reason));
    }

    @PostMapping("/{id}/cancel")
    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    @Operation(summary = "Cancel stock transfer", description = "Cancel a stock transfer")
    public ResponseEntity<StockTransferResponse> cancelStockTransfer(
            @PathVariable Long id,
            @RequestParam String reason) {
        return ResponseEntity.ok(stockTransferService.cancelStockTransfer(id, reason));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\SubCategoryController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class SubCategoryController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\SupplierController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.supplier.CreateSupplierRequest;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.common.PageResponse;
import com.pharmacy.medlan.dto.response.supplier.SupplierResponse;
import com.pharmacy.medlan.service.supplier.SupplierService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/suppliers")
@RequiredArgsConstructor
@Tag(name = "Supplier Management", description = "APIs for managing suppliers")
public class SupplierController {

    private final SupplierService supplierService;

    @PostMapping
    @Operation(summary = "Create supplier", description = "Create a new supplier")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<SupplierResponse>> createSupplier(
            @Valid @RequestBody CreateSupplierRequest request) {
        SupplierResponse response = supplierService.createSupplier(request);
        return ResponseEntity.ok(ApiResponse.success("Supplier created successfully", response));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update supplier", description = "Update an existing supplier")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<SupplierResponse>> updateSupplier(
            @PathVariable Long id,
            @Valid @RequestBody CreateSupplierRequest request) {
        SupplierResponse response = supplierService.updateSupplier(id, request);
        return ResponseEntity.ok(ApiResponse.success("Supplier updated successfully", response));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get supplier by ID", description = "Get supplier details by ID")
    public ResponseEntity<ApiResponse<SupplierResponse>> getSupplierById(@PathVariable Long id) {
        SupplierResponse response = supplierService.getSupplierById(id);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/code/{supplierCode}")
    @Operation(summary = "Get supplier by code", description = "Get supplier details by supplier code")
    public ResponseEntity<ApiResponse<SupplierResponse>> getSupplierByCode(@PathVariable String supplierCode) {
        SupplierResponse response = supplierService.getSupplierByCode(supplierCode);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping
    @Operation(summary = "Get all suppliers", description = "Get all suppliers with pagination and filtering")
    public ResponseEntity<ApiResponse<PageResponse<SupplierResponse>>> getAllSuppliers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String sort,
            @RequestParam(required = false) Boolean isActive,
            @RequestParam(required = false) String search) {
        
        // Parse sort parameter (format: "field,direction" or "field")
        String sortBy = "supplierName";
        String sortDir = "asc";
        if (sort != null && !sort.isEmpty()) {
            String[] sortParts = sort.split(",");
            sortBy = sortParts[0];
            if (sortParts.length > 1) {
                sortDir = sortParts[1];
            }
        }
        
        Sort sortObj = sortDir.equalsIgnoreCase("desc") ? 
            Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
        Pageable pageable = PageRequest.of(page, size, sortObj);
        
        Page<SupplierResponse> suppliersPage = supplierService.getAllSuppliers(pageable, isActive, search);
        return ResponseEntity.ok(ApiResponse.success(PageResponse.of(suppliersPage)));
    }

    @GetMapping("/search")
    @Operation(summary = "Search suppliers", description = "Search suppliers by name or contact")
    public ResponseEntity<ApiResponse<List<SupplierResponse>>> searchSuppliers(@RequestParam String query) {
        List<SupplierResponse> response = supplierService.searchSuppliers(query);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/active")
    @Operation(summary = "Get active suppliers", description = "Get all active suppliers")
    public ResponseEntity<ApiResponse<List<SupplierResponse>>> getActiveSuppliers() {
        List<SupplierResponse> response = supplierService.getActiveSuppliers();
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete supplier", description = "Soft delete a supplier")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER')")
    public ResponseEntity<ApiResponse<Void>> deleteSupplier(@PathVariable Long id) {
        supplierService.deleteSupplier(id);
        return ResponseEntity.ok(ApiResponse.success("Supplier deleted successfully"));
    }

    @PatchMapping("/{id}/activate")
    @Operation(summary = "Activate supplier", description = "Activate a supplier")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<Void>> activateSupplier(@PathVariable Long id) {
        supplierService.activateSupplier(id);
        return ResponseEntity.ok(ApiResponse.success("Supplier activated successfully"));
    }

    @PatchMapping("/{id}/deactivate")
    @Operation(summary = "Deactivate supplier", description = "Deactivate a supplier")
    @PreAuthorize("hasAnyRole('ADMIN', 'OWNER', 'MANAGER')")
    public ResponseEntity<ApiResponse<Void>> deactivateSupplier(@PathVariable Long id) {
        supplierService.deactivateSupplier(id);
        return ResponseEntity.ok(ApiResponse.success("Supplier deactivated successfully"));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\SupplierPaymentController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class SupplierPaymentController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\SyncController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class SyncController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\SystemConfigController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class SystemConfigController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\TransactionTypeController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class TransactionTypeController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\UnitController.java"   & echo.. 
package com.pharmacy.medlan.controller;

public class UnitController {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\controller\UserController.java"   & echo.. 
package com.pharmacy.medlan.controller;

import com.pharmacy.medlan.dto.request.user.CreateUserRequest;
import com.pharmacy.medlan.dto.request.user.UpdateUserRequest;
import com.pharmacy.medlan.dto.response.common.ApiResponse;
import com.pharmacy.medlan.dto.response.common.PageResponse;
import com.pharmacy.medlan.dto.response.user.UserResponse;
import com.pharmacy.medlan.enums.Role;
import com.pharmacy.medlan.service.user.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Tag(name = "User Management", description = "APIs for managing users")
@PreAuthorize("hasAnyRole('ADMIN', 'OWNER')")
public class UserController {

    private final UserService userService;

    @PostMapping
    @Operation(summary = "Create user", description = "Create a new user")
    public ResponseEntity<ApiResponse<UserResponse>> createUser(
            @Valid @RequestBody CreateUserRequest request) {
        UserResponse response = userService.createUser(request);
        return ResponseEntity.ok(ApiResponse.success("User created successfully", response));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update user", description = "Update an existing user")
    public ResponseEntity<ApiResponse<UserResponse>> updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UpdateUserRequest request) {
        UserResponse response = userService.updateUser(id, request);
        return ResponseEntity.ok(ApiResponse.success("User updated successfully", response));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get user by ID", description = "Get user details by ID")
    public ResponseEntity<ApiResponse<UserResponse>> getUserById(@PathVariable Long id) {
        UserResponse response = userService.getUserById(id);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/username/{username}")
    @Operation(summary = "Get user by username", description = "Get user details by username")
    public ResponseEntity<ApiResponse<UserResponse>> getUserByUsername(@PathVariable String username) {
        UserResponse response = userService.getUserByUsername(username);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping
    @Operation(summary = "Get all users", description = "Get all users with pagination")
    public ResponseEntity<ApiResponse<PageResponse<UserResponse>>> getAllUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "username") String sortBy,
            @RequestParam(defaultValue = "asc") String sortDir) {
        Sort sort = sortDir.equalsIgnoreCase("desc") ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
        Pageable pageable = PageRequest.of(page, size, sort);
        Page<UserResponse> usersPage = userService.getAllUsers(pageable);
        return ResponseEntity.ok(ApiResponse.success(PageResponse.of(usersPage)));
    }

    @GetMapping("/role/{role}")
    @Operation(summary = "Get users by role", description = "Get all users with a specific role")
    public ResponseEntity<ApiResponse<List<UserResponse>>> getUsersByRole(@PathVariable Role role) {
        List<UserResponse> response = userService.getUsersByRole(role);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/active")
    @Operation(summary = "Get active users", description = "Get all active users")
    public ResponseEntity<ApiResponse<List<UserResponse>>> getActiveUsers() {
        List<UserResponse> response = userService.getActiveUsers();
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @GetMapping("/branch/{branchId}")
    @Operation(summary = "Get users by branch", description = "Get all users assigned to a branch")
    public ResponseEntity<ApiResponse<List<UserResponse>>> getUsersByBranch(@PathVariable Long branchId) {
        List<UserResponse> response = userService.getUsersByBranch(branchId);
        return ResponseEntity.ok(ApiResponse.success(response));
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete user", description = "Soft delete a user")
    public ResponseEntity<ApiResponse<Void>> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.ok(ApiResponse.success("User deleted successfully"));
    }

    @PatchMapping("/{id}/activate")
    @Operation(summary = "Activate user", description = "Activate a user")
    public ResponseEntity<ApiResponse<Void>> activateUser(@PathVariable Long id) {
        userService.activateUser(id);
        return ResponseEntity.ok(ApiResponse.success("User activated successfully"));
    }

    @PatchMapping("/{id}/deactivate")
    @Operation(summary = "Deactivate user", description = "Deactivate a user")
    public ResponseEntity<ApiResponse<Void>> deactivateUser(@PathVariable Long id) {
        userService.deactivateUser(id);
        return ResponseEntity.ok(ApiResponse.success("User deactivated successfully"));
    }

    @PatchMapping("/{id}/reset-password")
    @Operation(summary = "Reset password", description = "Reset user's password")
    public ResponseEntity<ApiResponse<Void>> resetPassword(
            @PathVariable Long id,
            @RequestParam String newPassword) {
        userService.resetPassword(id, newPassword);
        return ResponseEntity.ok(ApiResponse.success("Password reset successfully"));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\NotificationRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request;

import com.pharmacy.medlan.enums.NotificationType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Request DTO for creating notifications
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationRequest {
    
    /**
     * User ID to send notification to
     */
    private Long userId;
    
    /**
     * Notification title
     */
    @NotBlank(message = "Title is required")
    @Size(max = 200, message = "Title cannot exceed 200 characters")
    private String title;
    
    /**
     * Notification message body
     */
    @NotBlank(message = "Message is required")
    @Size(max = 1000, message = "Message cannot exceed 1000 characters")
    private String message;
    
    /**
     * Type of notification
     */
    @NotNull(message = "Notification type is required")
    private NotificationType type;
    
    /**
     * Priority level
     */
    @Builder.Default
    private Priority priority = Priority.NORMAL;
    
    /**
     * Optional reference ID (e.g., product ID, invoice ID)
     */
    private Long referenceId;
    
    /**
     * Type of reference (e.g., PRODUCT, INVOICE, BATCH)
     */
    private String referenceType;
    
    /**
     * Action URL to redirect when notification is clicked
     */
    private String actionUrl;
    
    /**
     * Whether to also send an email notification
     */
    @Builder.Default
    private boolean sendEmail = false;
    
    /**
     * Whether to also send SMS notification
     */
    @Builder.Default
    private boolean sendSms = false;
    
    /**
     * Custom data/metadata in JSON format
     */
    private String metadata;
    
    /**
     * Priority levels for notifications
     */
    public enum Priority {
        LOW,
        NORMAL,
        MEDIUM,
        HIGH,
        CRITICAL
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\auth\ChangePasswordRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.auth;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChangePasswordRequest {

    @NotBlank(message = "Current password is required")
    private String currentPassword;

    @NotBlank(message = "New password is required")
    @Size(min = 6, message = "New password must be at least 6 characters")
    private String newPassword;

    @NotBlank(message = "Confirm password is required")
    private String confirmPassword;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\auth\LoginRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.auth;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {

    @NotBlank(message = "Username is required")
    private String username;

    @NotBlank(message = "Password is required")
    private String password;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\auth\RegisterRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.auth;

import com.pharmacy.medlan.enums.Role;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RegisterRequest {

    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 100, message = "Username must be between 3 and 100 characters")
    private String username;

    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;

    @NotBlank(message = "Full name is required")
    @Size(max = 200, message = "Full name must not exceed 200 characters")
    private String fullName;

    @Email(message = "Invalid email format")
    private String email;

    private String phoneNumber;

    private Role role;

    private String employeeCode;

    private BigDecimal discountLimit;

    private BigDecimal creditTransactionLimit;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\barcode\BarcodeGenerateRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.barcode;

import com.pharmacy.medlan.enums.BarcodeFormat;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BarcodeGenerateRequest {

    @NotBlank(message = "Content is required for barcode generation")
    @Size(max = 100, message = "Content must not exceed 100 characters")
    private String content;

    private BarcodeFormat format;

    @Min(value = 50, message = "Width must be at least 50 pixels")
    @Max(value = 1000, message = "Width must not exceed 1000 pixels")
    private int width = 300;

    @Min(value = 30, message = "Height must be at least 30 pixels")
    @Max(value = 500, message = "Height must not exceed 500 pixels")
    private int height = 100;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\barcode\BulkBarcodeRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.barcode;

import com.pharmacy.medlan.enums.BarcodeFormat;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BulkBarcodeRequest {

    @NotEmpty(message = "At least one product ID is required")
    @Size(max = 100, message = "Cannot generate more than 100 barcodes at once")
    private List<Long> productIds;

    private BarcodeFormat format;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\barcode\DecodeRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.barcode;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DecodeRequest {

    @NotBlank(message = "Base64 image is required for decoding")
    private String base64Image;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\branch\CreateBranchRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.branch;

import jakarta.validation.constraints.*;
import lombok.*;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateBranchRequest {

    @NotBlank(message = "Branch code is required")
    @Size(max = 50, message = "Branch code cannot exceed 50 characters")
    private String branchCode;

    @NotBlank(message = "Branch name is required")
    @Size(max = 200, message = "Branch name cannot exceed 200 characters")
    private String branchName;

    @Size(max = 500, message = "Address cannot exceed 500 characters")
    private String address;

    @Size(max = 100, message = "City cannot exceed 100 characters")
    private String city;

    @Size(max = 100, message = "State cannot exceed 100 characters")
    private String state;

    @Size(max = 20, message = "Pincode cannot exceed 20 characters")
    private String pincode;

    @Size(max = 50, message = "Phone number cannot exceed 50 characters")
    private String phoneNumber;

    @Email(message = "Invalid email format")
    @Size(max = 100, message = "Email cannot exceed 100 characters")
    private String email;

    @Size(max = 50, message = "GSTIN number cannot exceed 50 characters")
    private String gstinNumber;

    @Size(max = 50, message = "Drug license number cannot exceed 50 characters")
    private String drugLicenseNumber;

    private Long managerId;

    private Boolean isMainBranch = false;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\branch\UpdateBranchRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.branch;

public class UpdateBranchRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\finance\CreateBankRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.finance;

public class CreateBankRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\finance\CreateCashBookEntryRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.finance;

public class CreateCashBookEntryRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\finance\CreateChequeRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.finance;

public class CreateChequeRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\inventory\ApproveStockTransferRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.inventory;

public class ApproveStockTransferRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\inventory\ApproveTransactionRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.inventory;

public class ApproveTransactionRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\inventory\BarcodeScanRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.inventory;

import com.pharmacy.medlan.enums.ScanContext;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BarcodeScanRequest {

    @NotBlank(message = "Barcode/QR data is required")
    private String scanData;

    @NotNull(message = "Branch ID is required")
    private Long branchId;

    private ScanContext context = ScanContext.POS;

    /**
     * Quantity (for contexts that need quantity input)
     */
    private Integer quantity;

    /**
     * Whether this is a QR code scan (vs barcode)
     */
    private boolean qrCode = false;

    /**
     * Session ID for tracking related scans
     */
    private String sessionId;

    /**
     * Additional context-specific data
     */
    private String additionalData;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\inventory\CreateGRNRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.inventory;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateGRNRequest {

    @NotNull(message = "Supplier ID is required")
    private Long supplierId;

    @NotNull(message = "Branch ID is required")
    private Long branchId;

    private Long purchaseOrderId;

    @NotNull(message = "Received date is required")
    private LocalDate receivedDate;

    @Size(max = 100, message = "Supplier invoice number cannot exceed 100 characters")
    private String supplierInvoiceNumber;

    private LocalDate supplierInvoiceDate;

    @Size(max = 1000, message = "Remarks cannot exceed 1000 characters")
    private String remarks;

    @NotEmpty(message = "GRN must have at least one item")
    @Valid
    private List<GRNLineRequest> items;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class GRNLineRequest {

        @NotNull(message = "Product ID is required")
        private Long productId;

        @NotBlank(message = "Batch number is required")
        @Size(max = 100, message = "Batch number cannot exceed 100 characters")
        private String batchNumber;

        @NotNull(message = "Quantity is required")
        @Min(value = 1, message = "Quantity must be at least 1")
        private Integer quantity;

        @NotNull(message = "Cost price is required")
        @DecimalMin(value = "0.01", message = "Cost price must be greater than 0")
        private BigDecimal costPrice;

        @NotNull(message = "Selling price is required")
        @DecimalMin(value = "0.01", message = "Selling price must be greater than 0")
        private BigDecimal sellingPrice;

        @NotNull(message = "MRP is required")
        @DecimalMin(value = "0.01", message = "MRP must be greater than 0")
        private BigDecimal mrp;

        private LocalDate manufacturingDate;

        @NotNull(message = "Expiry date is required")
        private LocalDate expiryDate;

        @DecimalMin(value = "0.00", message = "Discount cannot be negative")
        private BigDecimal discountAmount;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\inventory\CreateInventoryTransactionRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.inventory;

public class CreateInventoryTransactionRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\inventory\CreateRGRNRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.inventory;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateRGRNRequest {

    private Long originalGrnId;

    @NotNull(message = "Supplier ID is required")
    private Long supplierId;

    @NotNull(message = "Branch ID is required")
    private Long branchId;

    @NotNull(message = "Return reason is required")
    private String returnReason;

    private String remarks;

    @NotEmpty(message = "At least one return line is required")
    @Valid
    private List<RGRNLineRequest> lines;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RGRNLineRequest {

        @NotNull(message = "Product ID is required")
        private Long productId;

        private Long inventoryBatchId;

        private String batchNumber;

        @NotNull(message = "Quantity returned is required")
        @Positive(message = "Quantity must be positive")
        private Integer quantityReturned;

        @NotNull(message = "Unit price is required")
        @Positive(message = "Unit price must be positive")
        private BigDecimal unitPrice;

        private String returnReason;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\inventory\CreateStockTransferRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.inventory;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateStockTransferRequest {

    @NotNull(message = "From branch ID is required")
    private Long fromBranchId;

    @NotNull(message = "To branch ID is required")
    private Long toBranchId;

    private LocalDate expectedReceiptDate;

    private String remarks;

    @NotEmpty(message = "At least one transfer item is required")
    @Valid
    private List<StockTransferItemRequest> items;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class StockTransferItemRequest {

        @NotNull(message = "Product ID is required")
        private Long productId;

        private Long inventoryBatchId;

        @NotNull(message = "Quantity is required")
        @Positive(message = "Quantity must be positive")
        private Integer quantityTransferred;

        private String remarks;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\payroll\CreatePayrollRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.payroll;

public class CreatePayrollRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\pos\CreateCustomerPrescriptionRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.pos;

public class CreateCustomerPrescriptionRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\pos\CreateCustomerRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.pos;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateCustomerRequest {

    @NotBlank(message = "Customer name is required")
    @Size(max = 200, message = "Customer name must not exceed 200 characters")
    private String customerName;

    private String phoneNumber;

    private String email;

    private String gender;

    private LocalDate dateOfBirth;

    private String address;

    private String city;

    private String state;

    private String pincode;

    private String fax;

    private BigDecimal creditLimit;

    private String description;

    private String medicalHistory;

    private String allergies;

    private String insuranceProvider;

    private String insurancePolicyNumber;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\pos\CreateInvoiceRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.pos;

public class CreateInvoiceRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\pos\CreatePrescriptionRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.pos;

public class CreatePrescriptionRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\pos\CreateSaleRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.pos;

import com.pharmacy.medlan.enums.PaymentMethod;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import lombok.*;
import java.math.BigDecimal;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateSaleRequest {

    private Long customerId;

    @NotNull(message = "Branch ID is required")
    private Long branchId;

    @NotEmpty(message = "Sale must have at least one item")
    @Valid
    private List<SaleItemRequest> items;

    @DecimalMin(value = "0.00", message = "Discount cannot be negative")
    private BigDecimal discountAmount;

    @Min(value = 0, message = "Discount percent cannot be negative")
    @Max(value = 100, message = "Discount percent cannot exceed 100")
    private BigDecimal discountPercent;

    @NotNull(message = "Payment method is required")
    private PaymentMethod paymentMethod;

    @NotNull(message = "Paid amount is required")
    @DecimalMin(value = "0.00", message = "Paid amount cannot be negative")
    private BigDecimal paidAmount;

    @Size(max = 200, message = "Patient name cannot exceed 200 characters")
    private String patientName;

    @Size(max = 200, message = "Doctor name cannot exceed 200 characters")
    private String doctorName;

    @Size(max = 1000, message = "Remarks cannot exceed 1000 characters")
    private String remarks;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class SaleItemRequest {

        @NotNull(message = "Product ID is required")
        private Long productId;

        private Long inventoryBatchId;

        @NotNull(message = "Quantity is required")
        @Min(value = 1, message = "Quantity must be at least 1")
        private Integer quantity;

        @DecimalMin(value = "0.00", message = "Discount cannot be negative")
        private BigDecimal discountAmount;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\pos\CreateSaleReturnRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.pos;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateSaleReturnRequest {

    private Long originalSaleId;

    @NotNull(message = "Branch ID is required")
    private Long branchId;

    private Long customerId;

    @NotNull(message = "Return reason is required")
    private String returnReason;

    @NotEmpty(message = "At least one return item is required")
    @Valid
    private List<SaleReturnItemRequest> items;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class SaleReturnItemRequest {

        private Long originalSaleItemId;

        @NotNull(message = "Product ID is required")
        private Long productId;

        private Long inventoryBatchId;

        @NotNull(message = "Quantity returned is required")
        @Positive(message = "Quantity must be positive")
        private Integer quantityReturned;

        @NotNull(message = "Unit price is required")
        @Positive(message = "Unit price must be positive")
        private BigDecimal unitPrice;

        private String returnReason;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\product\CreateProductRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.product;

import com.pharmacy.medlan.enums.DosageForm;
import com.pharmacy.medlan.enums.DrugSchedule;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateProductRequest {

    @NotBlank(message = "Product name is required")
    @Size(max = 200, message = "Product name must not exceed 200 characters")
    private String productName;

    @Size(max = 200, message = "Generic name must not exceed 200 characters")
    private String genericName;

    private Long categoryId;

    private Long subCategoryId;

    private Long unitId;

    private DosageForm dosageForm;

    @Size(max = 100, message = "Strength must not exceed 100 characters")
    private String strength;

    private DrugSchedule drugSchedule;

    @Size(max = 200, message = "Manufacturer must not exceed 200 characters")
    private String manufacturer;

    @Size(max = 200, message = "Supplier must not exceed 200 characters")
    private String supplier;

    @Size(max = 200, message = "Barcode must not exceed 200 characters")
    private String barcode;

    private String description;

    // Pricing
    private BigDecimal costPrice;
    private BigDecimal sellingPrice;
    private BigDecimal mrp;
    private BigDecimal profitMargin;
    private BigDecimal gstRate;
    private Long taxCategoryId;

    // Inventory thresholds
    private Integer reorderLevel;
    private Integer minimumStock;
    private Integer maximumStock;

    // Flags
    private Boolean isPrescriptionRequired;
    private Boolean isNarcotic;
    private Boolean isRefrigerated;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\product\UpdatePricingRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.product;

public class UpdatePricingRequest{
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\product\UpdateProductRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.product;

import com.pharmacy.medlan.enums.DosageForm;
import com.pharmacy.medlan.enums.DrugSchedule;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UpdateProductRequest {

    @Size(max = 200, message = "Product name must not exceed 200 characters")
    private String productName;

    @Size(max = 200, message = "Generic name must not exceed 200 characters")
    private String genericName;

    private Long categoryId;

    private Long subCategoryId;

    private Long unitId;

    private DosageForm dosageForm;

    @Size(max = 100, message = "Strength must not exceed 100 characters")
    private String strength;

    private DrugSchedule drugSchedule;

    @Size(max = 200, message = "Manufacturer must not exceed 200 characters")
    private String manufacturer;

    @Size(max = 200, message = "Supplier must not exceed 200 characters")
    private String supplier;

    @Size(max = 200, message = "Barcode must not exceed 200 characters")
    private String barcode;

    private String description;

    // Pricing
    private BigDecimal costPrice;
    private BigDecimal sellingPrice;
    private BigDecimal mrp;
    private BigDecimal profitMargin;
    private BigDecimal gstRate;
    private Long taxCategoryId;

    // Inventory thresholds
    private Integer reorderLevel;
    private Integer minimumStock;
    private Integer maximumStock;

    // Flags
    private Boolean isPrescriptionRequired;
    private Boolean isActive;
    private Boolean isDiscontinued;
    private Boolean isNarcotic;
    private Boolean isRefrigerated;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\report\FinancialReportRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.report;

public class FinancialReportRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\report\InventoryReportRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.report;

public class InventoryReportRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\report\SalesReportRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.report;

public class SalesReportRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\supplier\CreateGoodsReceiptRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.supplier;

public class CreateGoodsReceiptRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\supplier\CreatePurchaseOrderRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.supplier;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreatePurchaseOrderRequest {

    @NotNull(message = "Supplier ID is required")
    private Long supplierId;

    @NotNull(message = "Branch ID is required")
    private Long branchId;

    private LocalDate expectedDeliveryDate;

    private BigDecimal discountAmount;

    private String remarks;

    private String supplierReference;

    @NotEmpty(message = "At least one item is required")
    @Valid
    private List<PurchaseOrderItemRequest> items;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PurchaseOrderItemRequest {

        @NotNull(message = "Product ID is required")
        private Long productId;

        @NotNull(message = "Quantity ordered is required")
        @Positive(message = "Quantity must be positive")
        private Integer quantityOrdered;

        @NotNull(message = "Unit price is required")
        @Positive(message = "Unit price must be positive")
        private BigDecimal unitPrice;

        private BigDecimal discountPercent;

        @NotNull(message = "GST rate is required")
        private BigDecimal gstRate;

        private String remarks;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\supplier\CreateSupplierPaymentRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.supplier;

public class CreateSupplierPaymentRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\supplier\CreateSupplierRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.supplier;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateSupplierRequest {

    @NotBlank(message = "Supplier name is required")
    @Size(max = 200, message = "Supplier name must not exceed 200 characters")
    private String supplierName;

    private String contactPerson;

    private String phoneNumber;

    private String email;

    private String address;

    private String city;

    private String state;

    private String pincode;

    private String gstinNumber;

    private String panNumber;

    private String drugLicenseNumber;

    private BigDecimal defaultDiscountPercent;

    private Integer paymentTermDays;

    private BigDecimal creditLimit;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\user\AuthorizeEmployeeRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.user;

public class AuthorizeEmployeeRequest {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\user\CreateUserRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.user;

import com.pharmacy.medlan.enums.Role;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateUserRequest {

    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 100, message = "Username must be between 3 and 100 characters")
    private String username;

    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;

    @NotBlank(message = "Full name is required")
    @Size(max = 200, message = "Full name must not exceed 200 characters")
    private String fullName;

    @Email(message = "Invalid email format")
    private String email;

    private String phoneNumber;

    private Role role;

    private String employeeCode;

    private BigDecimal discountLimit;

    private BigDecimal creditTransactionLimit;

    private Long branchId;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\request\user\UpdateUserRequest.java"   & echo.. 
package com.pharmacy.medlan.dto.request.user;

import com.pharmacy.medlan.enums.Role;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UpdateUserRequest {

    @Size(max = 200, message = "Full name must not exceed 200 characters")
    private String fullName;

    @Email(message = "Invalid email format")
    private String email;

    private String phoneNumber;

    private Role role;

    private Boolean isActive;

    private BigDecimal discountLimit;

    private BigDecimal creditTransactionLimit;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\auth\LoginResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.auth;

import com.pharmacy.medlan.enums.Role;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse {

    private String accessToken;
    private String refreshToken;
    private String tokenType;
    private Long expiresIn;
    private Long userId;
    private String username;
    private String fullName;
    private String email;
    private Role role;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\auth\UserDetailsResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.auth;

public class UserDetailsResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\barcode\BarcodeResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.barcode;

import com.pharmacy.medlan.enums.BarcodeFormat;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BarcodeResponse {
    
    /**
     * The encoded content of the barcode
     */
    private String content;
    
    /**
     * Base64 encoded barcode image
     */
    private String imageBase64;
    
    /**
     * MIME type of the image (e.g., "image/png")
     */
    private String mimeType;
    
    /**
     * Barcode format used
     */
    private BarcodeFormat format;
    
    /**
     * Width of the generated image
     */
    private int width;
    
    /**
     * Height of the generated image
     */
    private int height;
    
    /**
     * Product ID if this barcode is for a product
     */
    private Long productId;
    
    /**
     * Product name for reference
     */
    private String productName;
    
    /**
     * Product code
     */
    private String productCode;
    
    /**
     * Selling price for shelf label
     */
    private String price;
    
    /**
     * MRP for shelf label
     */
    private String mrp;
    
    /**
     * Generation timestamp
     */
    private LocalDateTime generatedAt;
    
    /**
     * Data URL ready for direct HTML embedding
     */
    public String getDataUrl() {
        return "data:" + mimeType + ";base64," + imageBase64;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\barcode\QRCodeResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.barcode;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class QRCodeResponse {
    
    /**
     * The encoded content of the QR code
     */
    private String content;
    
    /**
     * Base64 encoded QR code image
     */
    private String imageBase64;
    
    /**
     * MIME type of the image
     */
    private String mimeType;
    
    /**
     * Size of the QR code (width = height)
     */
    private int size;
    
    /**
     * Error correction level used
     */
    private String errorCorrectionLevel;
    
    /**
     * Type of QR code (PRODUCT, BATCH, INVOICE, PRESCRIPTION)
     */
    private String qrType;
    
    /**
     * Associated entity ID
     */
    private Long entityId;
    
    /**
     * Entity reference number
     */
    private String entityReference;
    
    /**
     * Additional metadata embedded in QR
     */
    private Map<String, Object> metadata;
    
    /**
     * Generation timestamp
     */
    private LocalDateTime generatedAt;
    
    /**
     * Expiry time for time-limited QR codes
     */
    private LocalDateTime expiresAt;
    
    /**
     * Data URL ready for direct HTML embedding
     */
    public String getDataUrl() {
        return "data:" + mimeType + ";base64," + imageBase64;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\branch\BranchResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.branch;

import lombok.*;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BranchResponse {

    private Long id;
    private String branchCode;
    private String branchName;
    private String address;
    private String city;
    private String state;
    private String pincode;
    private String phoneNumber;
    private String email;
    private String gstinNumber;
    private String drugLicenseNumber;
    private Long managerId;
    private String managerName;
    private Boolean isActive;
    private Boolean isMainBranch;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\branch\BranchStaffResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.branch;

public class BranchStaffResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\common\ApiResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.common;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiResponse<T> {

    private boolean success;
    private String message;
    private T data;
    private LocalDateTime timestamp;

    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
                .success(true)
                .message("Success")
                .data(data)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public static <T> ApiResponse<T> success(String message, T data) {
        return ApiResponse.<T>builder()
                .success(true)
                .message(message)
                .data(data)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public static <T> ApiResponse<T> success(String message) {
        return ApiResponse.<T>builder()
                .success(true)
                .message(message)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public static <T> ApiResponse<T> error(String message) {
        return ApiResponse.<T>builder()
                .success(false)
                .message(message)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public static <T> ApiResponse<T> error(String message, T data) {
        return ApiResponse.<T>builder()
                .success(false)
                .message(message)
                .data(data)
                .timestamp(LocalDateTime.now())
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\common\ErrorResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.common;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {

    private int status;
    private String error;
    private String message;
    private String path;
    private LocalDateTime timestamp;
    private Map<String, String> fieldErrors;
    private List<String> errors;

    public static ErrorResponse of(int status, String error, String message, String path) {
        return ErrorResponse.builder()
                .status(status)
                .error(error)
                .message(message)
                .path(path)
                .timestamp(LocalDateTime.now())
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\common\PageResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.common;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.domain.Page;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {

    private List<T> content;
    private int pageNumber;
    private int pageSize;
    private long totalElements;
    private int totalPages;
    private boolean first;
    private boolean last;
    private boolean hasNext;
    private boolean hasPrevious;

    public static <T> PageResponse<T> of(Page<T> page) {
        return PageResponse.<T>builder()
                .content(page.getContent())
                .pageNumber(page.getNumber())
                .pageSize(page.getSize())
                .totalElements(page.getTotalElements())
                .totalPages(page.getTotalPages())
                .first(page.isFirst())
                .last(page.isLast())
                .hasNext(page.hasNext())
                .hasPrevious(page.hasPrevious())
                .build();
    }

    public static <T, U> PageResponse<U> of(Page<T> page, List<U> content) {
        return PageResponse.<U>builder()
                .content(content)
                .pageNumber(page.getNumber())
                .pageSize(page.getSize())
                .totalElements(page.getTotalElements())
                .totalPages(page.getTotalPages())
                .first(page.isFirst())
                .last(page.isLast())
                .hasNext(page.hasNext())
                .hasPrevious(page.hasPrevious())
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\dashboard\DashboardSummaryResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.dashboard;

import lombok.*;
import java.math.BigDecimal;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DashboardSummaryResponse {

    private TodaySummary todaySummary;
    private MonthlySummary monthlySummary;
    private InventoryAlerts inventoryAlerts;
    private List<RecentSale> recentSales;
    private List<TopProduct> topSellingProducts;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class TodaySummary {
        private BigDecimal totalSales;
        private Long salesCount;
        private BigDecimal totalPurchases;
        private Long purchasesCount;
        private BigDecimal profit;
        private Long newCustomers;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class MonthlySummary {
        private BigDecimal totalSales;
        private Long salesCount;
        private BigDecimal totalPurchases;
        private BigDecimal totalProfit;
        private BigDecimal averageDailySales;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class InventoryAlerts {
        private Long lowStockCount;
        private Long outOfStockCount;
        private Long expiringCount;
        private Long expiredCount;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RecentSale {
        private Long id;
        private String saleNumber;
        private String customerName;
        private BigDecimal totalAmount;
        private String status;
        private String saleTime;
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class TopProduct {
        private Long productId;
        private String productName;
        private String productCode;
        private Long quantitySold;
        private BigDecimal revenue;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\dashboard\InventoryAnalyticsResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.dashboard;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

/**
 * Inventory analytics response for dashboard
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class InventoryAnalyticsResponse {
    
    /**
     * Branch information
     */
    private Long branchId;
    private String branchName;
    
    /**
     * Overall inventory metrics
     */
    private int totalProducts;
    private int totalBatches;
    private BigDecimal totalStockValue;
    private BigDecimal totalCostValue;
    private BigDecimal potentialProfit;
    
    /**
     * Stock status breakdown
     */
    private int inStockCount;
    private int lowStockCount;
    private int outOfStockCount;
    private int overstockCount;
    
    /**
     * Expiry analysis
     */
    private int expiredCount;
    private int expiringIn7Days;
    private int expiringIn30Days;
    private int expiringIn90Days;
    private BigDecimal expiredValue;
    private BigDecimal expiringValue;
    
    /**
     * Category-wise stock
     */
    private List<CategoryStock> categoryStockBreakdown;
    
    /**
     * Stock movement analysis
     */
    private List<StockMovement> recentStockMovements;
    
    /**
     * ABC analysis
     */
    private AbcAnalysis abcAnalysis;
    
    /**
     * Inventory turnover metrics
     */
    private BigDecimal inventoryTurnoverRatio;
    private int averageDaysToSell;
    private BigDecimal stockoutRate;
    
    /**
     * Dead stock analysis
     */
    private int deadStockCount;
    private BigDecimal deadStockValue;
    
    /**
     * Value distribution
     */
    private Map<String, BigDecimal> stockValueBySchedule;
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CategoryStock {
        private Long categoryId;
        private String categoryName;
        private int productCount;
        private int totalQuantity;
        private BigDecimal stockValue;
        private int lowStockCount;
        private int expiringCount;
        private Double percentageOfTotal;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class StockMovement {
        private LocalDate date;
        private String type; // GRN, SALE, ADJUSTMENT, TRANSFER
        private String reference;
        private int quantity;
        private BigDecimal value;
        private String productName;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AbcAnalysis {
        /**
         * A Items: Top 20% products contributing 80% revenue
         */
        private int aItemsCount;
        private BigDecimal aItemsValue;
        
        /**
         * B Items: Next 30% products contributing 15% revenue
         */
        private int bItemsCount;
        private BigDecimal bItemsValue;
        
        /**
         * C Items: Bottom 50% products contributing 5% revenue
         */
        private int cItemsCount;
        private BigDecimal cItemsValue;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\dashboard\SalesAnalyticsResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.dashboard;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

/**
 * Sales analytics response for dashboard
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SalesAnalyticsResponse {
    
    /**
     * Date range
     */
    private LocalDate startDate;
    private LocalDate endDate;
    private Long branchId;
    
    /**
     * Summary metrics
     */
    private BigDecimal totalSales;
    private BigDecimal totalProfit;
    private int totalTransactions;
    private BigDecimal averageOrderValue;
    private BigDecimal averageProfitMargin;
    
    /**
     * Comparison with previous period
     */
    private BigDecimal salesGrowth;
    private BigDecimal profitGrowth;
    private Double transactionGrowth;
    
    /**
     * Sales by day
     */
    private List<DailySales> dailySales;
    
    /**
     * Sales by category
     */
    private List<CategorySales> categorySales;
    
    /**
     * Sales by payment method
     */
    private Map<String, BigDecimal> paymentMethodSales;
    
    /**
     * Peak hours analysis
     */
    private List<HourlySales> hourlySalesPattern;
    
    /**
     * Top performing products
     */
    private List<ProductPerformance> topProducts;
    
    /**
     * Sales by staff
     */
    private List<StaffPerformance> staffPerformance;
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class DailySales {
        private LocalDate date;
        private BigDecimal sales;
        private BigDecimal profit;
        private int transactions;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class CategorySales {
        private Long categoryId;
        private String categoryName;
        private BigDecimal sales;
        private int itemsSold;
        private Double percentageOfTotal;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class HourlySales {
        private int hour;
        private BigDecimal sales;
        private int transactions;
        private BigDecimal averageOrderValue;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ProductPerformance {
        private Long productId;
        private String productName;
        private String category;
        private int quantitySold;
        private BigDecimal revenue;
        private BigDecimal profit;
        private Double profitMargin;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class StaffPerformance {
        private Long userId;
        private String staffName;
        private int transactionsHandled;
        private BigDecimal totalSales;
        private BigDecimal averageOrderValue;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\finance\BankResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.finance;

public class BankResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\finance\CashBookResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.finance;

public class CashBookResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\finance\ChequeResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.finance;

public class ChequeResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\ExpiryAlertResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

import com.pharmacy.medlan.enums.AlertLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExpiryAlertResponse {
    
    private Long alertId;
    private Long batchId;
    private String batchNumber;
    
    private Long productId;
    private String productCode;
    private String productName;
    private String genericName;
    private String manufacturer;
    
    private Long branchId;
    private String branchName;
    private String rackLocation;
    
    private LocalDate manufacturingDate;
    private LocalDate expiryDate;
    private Integer daysToExpiry;
    private Boolean isExpired;
    
    private Integer quantityAvailable;
    private BigDecimal purchasePrice;
    private BigDecimal mrp;
    private BigDecimal sellingPrice;
    
    private BigDecimal potentialLoss; // quantity * purchase price
    private BigDecimal retailValue;   // quantity * selling price
    
    private AlertLevel alertLevel;
    private String alertMessage;
    private String recommendedAction;
    
    private LocalDateTime detectedAt;
    private LocalDateTime acknowledgedAt;
    private String acknowledgedBy;
    
    /**
     * Generate recommended action based on days to expiry
     */
    public static String getRecommendedAction(int daysToExpiry, int quantity) {
        if (daysToExpiry < 0) {
            return "URGENT: Remove from shelf immediately. Process return to supplier or dispose as per regulations.";
        } else if (daysToExpiry <= 30) {
            return "CRITICAL: Consider marking down for quick sale. Contact supplier for returns if applicable.";
        } else if (daysToExpiry <= 60) {
            return "HIGH PRIORITY: Prioritize this batch for sales. Consider promotional pricing.";
        } else if (daysToExpiry <= 90) {
            return "Monitor closely. Use FEFO (First Expiry First Out) strictly.";
        } else {
            return "Normal monitoring. Ensure proper stock rotation.";
        }
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\GRNResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

import com.pharmacy.medlan.enums.GRNStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class GRNResponse {

    private Long id;
    private String grnNumber;
    private Long purchaseOrderId;
    private String purchaseOrderNumber;
    private Long supplierId;
    private String supplierName;
    private Long branchId;
    private String branchName;
    private LocalDate receivedDate;
    private String supplierInvoiceNumber;
    private LocalDate supplierInvoiceDate;
    private BigDecimal totalAmount;
    private BigDecimal discountAmount;
    private BigDecimal taxAmount;
    private BigDecimal netAmount;
    private GRNStatus status;
    private String remarks;
    private String receivedByUserName;
    private String approvedByUserName;
    private LocalDateTime approvedAt;
    private BigDecimal paidAmount;
    private BigDecimal balanceAmount;
    private PaymentStatus paymentStatus;
    private List<GRNLineResponse> items;
    private LocalDateTime createdAt;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class GRNLineResponse {
        private Long id;
        private Long productId;
        private String productName;
        private String productCode;
        private String batchNumber;
        private Integer quantity;
        private BigDecimal costPrice;
        private BigDecimal sellingPrice;
        private BigDecimal mrp;
        private LocalDate manufacturingDate;
        private LocalDate expiryDate;
        private BigDecimal discountAmount;
        private BigDecimal totalAmount;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\InventoryBatchResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class InventoryBatchResponse {

    private Long id;
    private Long productId;
    private String productCode;
    private String productName;
    private Long branchId;
    private String branchName;
    private String batchNumber;
    private LocalDate manufacturingDate;
    private LocalDate expiryDate;
    private Integer quantityReceived;
    private Integer quantityAvailable;
    private Integer quantitySold;
    private BigDecimal costPrice;
    private BigDecimal sellingPrice;
    private Boolean isActive;
    private Boolean isExpired;
    private Integer daysToExpiry;
    private LocalDateTime createdAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\InventoryResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

import lombok.*;
import java.math.BigDecimal;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class InventoryResponse {

    private Long productId;
    private String productCode;
    private String productName;
    private Long branchId;
    private String branchName;
    private Integer totalQuantity;
    private Integer minimumStock;
    private Integer reorderLevel;
    private BigDecimal averageCostPrice;
    private BigDecimal sellingPrice;
    private String stockStatus; // IN_STOCK, LOW_STOCK, OUT_OF_STOCK
    private List<InventoryBatchResponse> batches;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\InventoryTransactionResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

public class InventoryTransactionResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\LowStockAlertResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

import com.pharmacy.medlan.enums.AlertLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LowStockAlertResponse {
    
    private Long alertId;
    private Long productId;
    private String productCode;
    private String productName;
    private String genericName;
    private String categoryName;
    
    private Long branchId;
    private String branchName;
    
    private Integer currentStock;
    private Integer reorderLevel;
    private Integer minimumStock;
    private Integer maximumStock;
    
    private Integer stockDeficit;
    private Integer suggestedOrderQuantity;
    
    private AlertLevel alertLevel;
    private String alertMessage;
    
    private BigDecimal lastPurchasePrice;
    private String preferredSupplier;
    
    private LocalDateTime detectedAt;
    private LocalDateTime acknowledgedAt;
    private String acknowledgedBy;
    
    private Integer daysOutOfStock;
    private BigDecimal estimatedLostRevenue;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\ProductBinCardResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

public class ProductBinCardResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\RGRNResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

import com.pharmacy.medlan.enums.PaymentStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RGRNResponse {

    private Long id;
    private String rgrnNumber;
    private Long originalGrnId;
    private String originalGrnNumber;
    private Long supplierId;
    private String supplierName;
    private Long branchId;
    private String branchName;
    private LocalDate returnDate;
    private BigDecimal totalReturnAmount;
    private PaymentStatus refundStatus;
    private String returnReason;
    private String returnedByName;
    private String remarks;
    private List<RGRNLineResponse> lines;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class RGRNLineResponse {
        private Long id;
        private Long productId;
        private String productName;
        private Long inventoryBatchId;
        private String batchNumber;
        private Integer quantityReturned;
        private BigDecimal unitPrice;
        private BigDecimal totalAmount;
        private String returnReason;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\ScanResultResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

import com.pharmacy.medlan.enums.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ScanResultResponse {

    // Scan metadata
    private String scanId;
    private String scannedData;
    private ScanContext context;
    private LocalDateTime scannedAt;
    private boolean success;
    private String errorMessage;

    // Product information
    private Long productId;
    private String productCode;
    private String productName;
    private String genericName;
    private String barcode;
    private String manufacturer;
    private String categoryName;
    private String subCategoryName;
    private String unitName;

    // Drug information
    private DosageForm dosageForm;
    private String strength;
    private DrugSchedule drugSchedule;
    private boolean prescriptionRequired;
    private boolean isNarcotic;
    private boolean isRefrigerated;

    // Pricing (for POS context)
    private BigDecimal mrp;
    private BigDecimal sellingPrice;
    private BigDecimal costPrice;
    private BigDecimal gstRate;
    private BigDecimal discountAllowed;

    // Stock information
    private Integer totalStockAvailable;
    private Integer stockAtBranch;
    private String stockStatus; // IN_STOCK, LOW_STOCK, OUT_OF_STOCK

    // Batch information (for FEFO selection)
    private List<BatchInfo> availableBatches;
    private BatchInfo suggestedBatch; // FEFO recommended batch

    // Alerts
    private List<AlertInfo> alerts;

    // Context-specific data
    private Map<String, Object> additionalData;

    // For POS - quick add support
    private boolean canAddToCart;
    private String addToCartBlockReason;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class BatchInfo {
        private Long batchId;
        private String batchNumber;
        private LocalDate expiryDate;
        private Integer daysToExpiry;
        private Integer quantityAvailable;
        private BigDecimal purchasePrice;
        private BigDecimal mrp;
        private BigDecimal sellingPrice;
        private String rackLocation;
        private boolean isExpired;
        private boolean isExpiringSoon; // Within 90 days
    }

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class AlertInfo {
        private AlertLevel level;
        private String alertType;
        private String message;
        private String action;
    }

    /**
     * Create a successful scan result
     */
    public static ScanResultResponse success(String scanId, String scannedData, ScanContext context) {
        return ScanResultResponse.builder()
                .scanId(scanId)
                .scannedData(scannedData)
                .context(context)
                .scannedAt(LocalDateTime.now())
                .success(true)
                .build();
    }

    /**
     * Create a failed scan result
     */
    public static ScanResultResponse error(String scannedData, String errorMessage) {
        return ScanResultResponse.builder()
                .scannedData(scannedData)
                .scannedAt(LocalDateTime.now())
                .success(false)
                .errorMessage(errorMessage)
                .canAddToCart(false)
                .addToCartBlockReason(errorMessage)
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\inventory\StockTransferResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.inventory;

import com.pharmacy.medlan.enums.StockTransferStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class StockTransferResponse {

    private Long id;
    private String transferNumber;
    private Long fromBranchId;
    private String fromBranchName;
    private Long toBranchId;
    private String toBranchName;
    private LocalDate transferDate;
    private LocalDate expectedReceiptDate;
    private LocalDate actualReceiptDate;
    private StockTransferStatus status;
    private String initiatedByName;
    private String approvedByName;
    private LocalDateTime approvedAt;
    private String receivedByName;
    private String remarks;
    private List<StockTransferItemResponse> items;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class StockTransferItemResponse {
        private Long id;
        private Long productId;
        private String productName;
        private String productSku;
        private Long inventoryBatchId;
        private String batchNumber;
        private Integer quantityTransferred;
        private Integer quantityReceived;
        private String remarks;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\notification\NotificationResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.notification;

public class NotificationResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\payroll\PayrollResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.payroll;

public class PayrollResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\pos\CustomerPrescriptionResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.pos;

public class CustomerPrescriptionResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\pos\CustomerResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.pos;

import com.pharmacy.medlan.enums.CustomerStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CustomerResponse {

    private Long id;
    private String customerCode;
    private String customerName;
    private String phoneNumber;
    private String email;
    private String gender;
    private LocalDate dateOfBirth;
    private String address;
    private String city;
    private String state;
    private String pincode;
    private String fax;
    private BigDecimal creditLimit;
    private BigDecimal currentBalance;
    private CustomerStatus status;
    private String description;
    private String medicalHistory;
    private String allergies;
    private String insuranceProvider;
    private String insurancePolicyNumber;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\pos\InvoiceResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.pos;

import com.pharmacy.medlan.enums.InvoiceStatus;
import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.PaymentStatus;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class InvoiceResponse {

    private Long id;
    private String invoiceNumber;
    private Long customerId;
    private String customerName;
    private Long branchId;
    private String branchName;
    private LocalDate invoiceDate;
    private LocalDate dueDate;
    private BigDecimal subtotal;
    private BigDecimal discount;
    private BigDecimal totalAmount;
    private BigDecimal paidAmount;
    private BigDecimal balanceAmount;
    private InvoiceStatus status;
    private PaymentStatus paymentStatus;
    private PaymentMethod paymentType;
    private String chequeNumber;
    private LocalDate chequeDate;
    private String remarks;
    private LocalDateTime createdAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\pos\PrescriptionResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.pos;

public class PrescriptionResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\pos\SaleItemResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.pos;

import lombok.*;
import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SaleItemResponse {

    private Long id;
    private Long productId;
    private String productName;
    private String productCode;
    private Long inventoryBatchId;
    private String batchNumber;
    private Integer quantity;
    private BigDecimal unitPrice;
    private BigDecimal discountAmount;
    private BigDecimal taxAmount;
    private BigDecimal totalAmount;
    private BigDecimal costPrice;
    private BigDecimal profit;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\pos\SaleResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.pos;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.SaleStatus;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SaleResponse {

    private Long id;
    private String saleNumber;
    private Long invoiceId;
    private String invoiceNumber;
    private Long branchId;
    private String branchName;
    private Long customerId;
    private String customerName;
    private LocalDateTime saleDate;
    private BigDecimal subtotal;
    private BigDecimal discountAmount;
    private BigDecimal discountPercent;
    private BigDecimal taxAmount;
    private BigDecimal totalAmount;
    private BigDecimal paidAmount;
    private BigDecimal changeAmount;
    private PaymentMethod paymentMethod;
    private SaleStatus status;
    private String soldByUserName;
    private String patientName;
    private String doctorName;
    private String remarks;
    private List<SaleItemResponse> items;
    private LocalDateTime createdAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\pos\SaleReturnResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.pos;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SaleReturnResponse {

    private Long id;
    private String returnNumber;
    private Long originalSaleId;
    private String originalSaleNumber;
    private Long branchId;
    private String branchName;
    private Long customerId;
    private String customerName;
    private LocalDate returnDate;
    private BigDecimal totalReturnAmount;
    private BigDecimal refundAmount;
    private String returnReason;
    private String processedByName;
    private List<SaleReturnItemResponse> items;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class SaleReturnItemResponse {
        private Long id;
        private Long originalSaleItemId;
        private Long productId;
        private String productName;
        private String productSku;
        private Long inventoryBatchId;
        private String batchNumber;
        private Integer quantityReturned;
        private BigDecimal unitPrice;
        private BigDecimal totalAmount;
        private String returnReason;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\product\CategoryResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.product;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CategoryResponse {

    private Long id;
    private String categoryName;
    private String categoryCode;
    private String description;
    private Integer minCode;
    private Integer maxCode;
    private Boolean isActive;
    private Integer subCategoryCount;
    private Integer productCount;
    private List<SubCategoryResponse> subCategories;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\product\ProductPricingResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.product;

public class ProductPricingResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\product\ProductResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.product;

import com.pharmacy.medlan.enums.DosageForm;
import com.pharmacy.medlan.enums.DrugSchedule;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponse {

    private Long id;
    private String productCode;
    private String productName;
    private String genericName;

    // Category info
    private Long categoryId;
    private String categoryName;
    private Long subCategoryId;
    private String subCategoryName;
    private Long unitId;
    private String unitName;

    private DosageForm dosageForm;
    private String strength;
    private DrugSchedule drugSchedule;
    private String manufacturer;
    private String supplier;
    private String barcode;
    private String description;

    // Pricing
    private BigDecimal costPrice;
    private BigDecimal sellingPrice;
    private BigDecimal mrp;
    private BigDecimal profitMargin;
    private BigDecimal gstRate;
    private Long taxCategoryId;
    private String taxCategoryName;

    // Inventory thresholds
    private Integer reorderLevel;
    private Integer minimumStock;
    private Integer maximumStock;

    // Flags
    private Boolean isPrescriptionRequired;
    private Boolean isActive;
    private Boolean isDiscontinued;
    private Boolean isNarcotic;
    private Boolean isRefrigerated;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\product\SubCategoryResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.product;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SubCategoryResponse {

    private Long id;
    private String subCategoryName;
    private String subCategoryCode;
    private String description;
    private Integer minCode;
    private Integer maxCode;
    private Boolean isActive;
    private Long categoryId;
    private String categoryName;
    private Integer productCount;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\report\DailySalesSummaryResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.report;

public class DailySalesSummaryResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\report\ExpiryAlertResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.report;

public class ExpiryAlertResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\report\ExportResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.report;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExportResponse {
    
    /**
     * Filename of the exported document
     */
    private String filename;
    
    /**
     * MIME type (application/pdf, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, etc.)
     */
    private String mimeType;
    
    /**
     * Base64 encoded file content
     */
    private String contentBase64;
    
    /**
     * File size in bytes
     */
    private long fileSize;
    
    /**
     * Export type (PDF, EXCEL, CSV)
     */
    private String exportType;
    
    /**
     * Report type identifier
     */
    private String reportType;
    
    /**
     * Generation timestamp
     */
    private LocalDateTime generatedAt;
    
    /**
     * Number of records/pages in the report
     */
    private int recordCount;
    
    /**
     * Any additional metadata
     */
    private String metadata;
    
    /**
     * Data URL for direct download
     */
    public String getDataUrl() {
        return "data:" + mimeType + ";base64," + contentBase64;
    }
    
    /**
     * Create a PDF response
     */
    public static ExportResponse pdf(String filename, String base64Content, int recordCount) {
        return ExportResponse.builder()
                .filename(filename)
                .mimeType("application/pdf")
                .contentBase64(base64Content)
                .exportType("PDF")
                .generatedAt(LocalDateTime.now())
                .recordCount(recordCount)
                .build();
    }
    
    /**
     * Create an Excel response
     */
    public static ExportResponse excel(String filename, String base64Content, int recordCount) {
        return ExportResponse.builder()
                .filename(filename)
                .mimeType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
                .contentBase64(base64Content)
                .exportType("EXCEL")
                .generatedAt(LocalDateTime.now())
                .recordCount(recordCount)
                .build();
    }
    
    /**
     * Create a CSV response
     */
    public static ExportResponse csv(String filename, String base64Content, int recordCount) {
        return ExportResponse.builder()
                .filename(filename)
                .mimeType("text/csv")
                .contentBase64(base64Content)
                .exportType("CSV")
                .generatedAt(LocalDateTime.now())
                .recordCount(recordCount)
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\report\FinancialReportResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.report;

public class FinancialReportResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\report\InventoryReportResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.report;

public class InventoryReportResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\report\LowStockAlertResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.report;

public class LowStockAlertResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\report\SalesReportResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.report;

public class SalesReportResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\supplier\GoodsReceiptResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.supplier;

public class GoodsReceiptResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\supplier\PurchaseOrderResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.supplier;

import com.pharmacy.medlan.enums.PurchaseOrderStatus;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PurchaseOrderResponse {

    private Long id;
    private String poNumber;
    private Long supplierId;
    private String supplierName;
    private Long branchId;
    private String branchName;
    private LocalDate orderDate;
    private LocalDate expectedDeliveryDate;
    private LocalDate actualDeliveryDate;
    private BigDecimal totalAmount;
    private BigDecimal discountAmount;
    private BigDecimal taxAmount;
    private BigDecimal netAmount;
    private PurchaseOrderStatus status;
    private String createdByName;
    private String approvedByName;
    private LocalDateTime approvedAt;
    private String remarks;
    private String supplierReference;
    private List<PurchaseOrderItemResponse> items;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class PurchaseOrderItemResponse {
        private Long id;
        private Long productId;
        private String productName;
        private String productSku;
        private Integer quantityOrdered;
        private Integer quantityReceived;
        private BigDecimal unitPrice;
        private BigDecimal discountPercent;
        private BigDecimal discountAmount;
        private BigDecimal gstRate;
        private BigDecimal gstAmount;
        private BigDecimal totalAmount;
        private String remarks;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\supplier\SupplierPaymentResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.supplier;

public class SupplierPaymentResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\supplier\SupplierResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.supplier;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SupplierResponse {

    private Long id;
    private String supplierCode;
    private String supplierName;
    private String contactPerson;
    private String phoneNumber;
    private String email;
    private String address;
    private String city;
    private String state;
    private String pincode;
    private String gstinNumber;
    private String panNumber;
    private String drugLicenseNumber;
    private BigDecimal defaultDiscountPercent;
    private Integer paymentTermDays;
    private BigDecimal creditLimit;
    private BigDecimal currentBalance;
    private Boolean isActive;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\user\EmployeeAuthorizationResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.user;

public class EmployeeAuthorizationResponse {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\dto\response\user\UserResponse.java"   & echo.. 
package com.pharmacy.medlan.dto.response.user;

import com.pharmacy.medlan.enums.Role;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserResponse {

    private Long id;
    private String username;
    private String fullName;
    private String email;
    private String phoneNumber;
    private Role role;
    private Boolean isActive;
    private LocalDate lastLoginDate;
    private BigDecimal discountLimit;
    private BigDecimal creditTransactionLimit;
    private String employeeCode;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\AlertLevel.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum AlertLevel {
    INFO("Information"),
    LOW("Low Priority"),
    WARNING("Warning"),
    URGENT("Urgent"),
    CRITICAL("Critical"),
    OUT_OF_STOCK("Out of Stock"),
    EXPIRED("Expired");

    private final String displayName;

    AlertLevel(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\AuthorizationStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum AuthorizationStatus {
    PENDING("Pending"),
    APPROVED("Approved"),
    REJECTED("Rejected"),
    EXPIRED("Expired");

    private final String displayName;

    AuthorizationStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\BarcodeFormat.java"   & echo.. 
package com.pharmacy.medlan.enums;

/**
 * Supported barcode formats for pharmacy products
 */
public enum BarcodeFormat {
    
    /**
     * EAN-13: European Article Number (13 digits)
     * Most common format for retail products worldwide
     */
    EAN_13("EAN-13", 13, "European Article Number - 13 digits"),
    
    /**
     * EAN-8: Shortened version for small products
     */
    EAN_8("EAN-8", 8, "European Article Number - 8 digits"),
    
    /**
     * UPC-A: Universal Product Code (North America)
     */
    UPC_A("UPC-A", 12, "Universal Product Code - 12 digits"),
    
    /**
     * CODE-128: High-density alphanumeric barcode
     * Excellent for inventory management
     */
    CODE_128("Code 128", -1, "Alphanumeric - Variable length"),
    
    /**
     * CODE-39: Alphanumeric, self-checking
     * Common in healthcare and defense
     */
    CODE_39("Code 39", -1, "Alphanumeric - Variable length"),
    
    /**
     * QR_CODE: 2D barcode for complex data
     */
    QR_CODE("QR Code", -1, "2D Matrix - Large data capacity"),
    
    /**
     * DATA_MATRIX: 2D barcode for small items
     * Used for pharmaceutical unit-dose packaging
     */
    DATA_MATRIX("Data Matrix", -1, "2D Matrix - Small form factor"),
    
    /**
     * PDF_417: 2D stacked barcode
     * Used for complex pharmaceutical data
     */
    PDF_417("PDF 417", -1, "2D Stacked - High capacity"),
    
    /**
     * ITF-14: Used for outer packaging/cases
     */
    ITF_14("ITF-14", 14, "Interleaved 2 of 5 - Shipping containers"),
    
    /**
     * GS1_DATABAR: For pharmaceutical products
     * Can encode expiry dates and batch numbers
     */
    GS1_DATABAR("GS1 DataBar", -1, "GS1 DataBar - Pharmaceutical standard");

    private final String displayName;
    private final int fixedLength;
    private final String description;

    BarcodeFormat(String displayName, int fixedLength, String description) {
        this.displayName = displayName;
        this.fixedLength = fixedLength;
        this.description = description;
    }

    public String getDisplayName() {
        return displayName;
    }

    public int getFixedLength() {
        return fixedLength;
    }

    public String getDescription() {
        return description;
    }

    public boolean isFixedLength() {
        return fixedLength > 0;
    }

    /**
     * Get ZXing compatible format
     */
    public com.google.zxing.BarcodeFormat toZxingFormat() {
        return switch (this) {
            case EAN_13 -> com.google.zxing.BarcodeFormat.EAN_13;
            case EAN_8 -> com.google.zxing.BarcodeFormat.EAN_8;
            case UPC_A -> com.google.zxing.BarcodeFormat.UPC_A;
            case CODE_128 -> com.google.zxing.BarcodeFormat.CODE_128;
            case CODE_39 -> com.google.zxing.BarcodeFormat.CODE_39;
            case QR_CODE -> com.google.zxing.BarcodeFormat.QR_CODE;
            case DATA_MATRIX -> com.google.zxing.BarcodeFormat.DATA_MATRIX;
            case PDF_417 -> com.google.zxing.BarcodeFormat.PDF_417;
            case ITF_14 -> com.google.zxing.BarcodeFormat.ITF;
            case GS1_DATABAR -> com.google.zxing.BarcodeFormat.RSS_14;
        };
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\ChequeStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum ChequeStatus {
    PENDING("Pending"),
    DEPOSITED("Deposited"),
    CLEARED("Cleared"),
    BOUNCED("Bounced"),
    CANCELLED("Cancelled");

    private final String displayName;

    ChequeStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\CustomerStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum CustomerStatus {
    ACTIVE("Active"),
    INACTIVE("Inactive"),
    BLOCKED("Blocked"),
    VIP("VIP Customer");

    private final String displayName;

    CustomerStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\DosageForm.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum DosageForm {
    TABLET("Tablet"),
    CAPSULE("Capsule"),
    SYRUP("Syrup"),
    INJECTION("Injection"),
    DROPS("Drops"),
    CREAM("Cream"),
    OINTMENT("Ointment"),
    INHALER("Inhaler"),
    POWDER("Powder"),
    SUSPENSION("Suspension"),
    GEL("Gel"),
    LOTION("Lotion"),
    SPRAY("Spray"),
    PATCH("Patch"),
    SUPPOSITORY("Suppository");

    private final String displayName;

    DosageForm(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\DrugSchedule.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum DrugSchedule {
    OTC("Over The Counter - No Prescription Required", false),
    H("Schedule H - Prescription Required", true),
    H1("Schedule H1 - Prescription Required (Restricted)", true),
    X("Schedule X - Narcotic/Psychotropic (Strictly Controlled)", true),
    G("Schedule G - General Sale", false),
    C("Schedule C - Controlled Drug", true),
    C1("Schedule C1 - Controlled Drug (Restricted)", true);

    private final String description;
    private final boolean prescriptionRequired;

    DrugSchedule(String description, boolean prescriptionRequired) {
        this.description = description;
        this.prescriptionRequired = prescriptionRequired;
    }

    public String getDescription() { return description; }
    public boolean isPrescriptionRequired() { return prescriptionRequired; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\EmploymentType.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum EmploymentType {
    FULL_TIME("Full Time"),
    PART_TIME("Part Time"),
    CONTRACT("Contract"),
    TEMPORARY("Temporary"),
    INTERN("Intern");

    private final String displayName;

    EmploymentType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\GRNStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum GRNStatus {
    DRAFT("Draft"),
    PENDING_APPROVAL("Pending Approval"),
    APPROVED("Approved"),
    RECEIVED("Received"),
    REJECTED("Rejected"),
    CANCELLED("Cancelled");

    private final String displayName;

    GRNStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\InvoiceStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum InvoiceStatus {
    DRAFT("Draft"),
    ISSUED("Issued"),
    PAID("Paid"),
    PARTIALLY_PAID("Partially Paid"),
    OVERDUE("Overdue"),
    CANCELLED("Cancelled"),
    VOID("Void");

    private final String displayName;

    InvoiceStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\NotificationType.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum NotificationType {
    // Inventory Alerts
    LOW_STOCK_ALERT("Low Stock Alert"),
    CRITICAL_STOCK_ALERT("Critical Stock Alert"),
    OUT_OF_STOCK_ALERT("Out of Stock Alert"),
    EXPIRY_ALERT("Expiry Alert"),
    EXPIRED_PRODUCT_ALERT("Expired Product Alert"),
    NEAR_EXPIRY_ALERT("Near Expiry Alert"),
    
    // Sales & POS
    SALE("Sale Notification"),
    SALE_RETURN("Sale Return"),
    SALE_VOID("Sale Void"),
    
    // Inventory Operations
    GRN("GRN Notification"),
    STOCK_TRANSFER("Stock Transfer"),
    STOCK_ADJUSTMENT("Stock Adjustment"),
    
    // Financial
    PAYMENT_DUE("Payment Due"),
    PAYMENT_RECEIVED("Payment Received"),
    INVOICE_GENERATED("Invoice Generated"),
    CREDIT_LIMIT_EXCEEDED("Credit Limit Exceeded"),
    
    // User & System
    USER_REGISTRATION("User Registration"),
    PASSWORD_RESET("Password Reset"),
    ROLE_CHANGED("Role Changed"),
    SYSTEM_ALERT("System Alert"),
    MAINTENANCE("System Maintenance"),
    
    // Reports
    REPORT_GENERATED("Report Generated"),
    SCHEDULED_REPORT("Scheduled Report"),
    
    // Purchase & Procurement
    REORDER_SUGGESTION("Auto-Reorder Suggestion"),
    PO_APPROVAL_REQUIRED("PO Approval Required"),
    PO_APPROVED("Purchase Order Approved"),
    PO_REJECTED("Purchase Order Rejected"),
    
    // Legacy/General
    LOW_STOCK("Low Stock Alert"),
    RETURN("Return Notification"),
    SYSTEM("System Notification"),
    USER("User Notification");

    private final String displayName;

    NotificationType(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\PaymentMethod.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum PaymentMethod {
    CASH("Cash"),
    CARD("Debit/Credit Card"),
    UPI("UPI Payment"),
    CHEQUE("Cheque"),
    BANK_TRANSFER("Bank Transfer"),
    CREDIT("Credit Sale");

    private final String displayName;

    PaymentMethod(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\PaymentStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum PaymentStatus {
    UNPAID("Unpaid"),
    PARTIALLY_PAID("Partially Paid"),
    PAID("Paid"),
    OVERDUE("Overdue"),
    REFUNDED("Refunded"),
    PENDING("Pending");

    private final String displayName;

    PaymentStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\PurchaseOrderStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum PurchaseOrderStatus {
    DRAFT("Draft"),
    PENDING_APPROVAL("Pending Approval"),
    APPROVED("Approved"),
    SENT("Sent to Supplier"),
    PARTIALLY_RECEIVED("Partially Received"),
    FULLY_RECEIVED("Fully Received"),
    CANCELLED("Cancelled"),
    CLOSED("Closed");

    private final String displayName;

    PurchaseOrderStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\Role.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum Role {
    SUPER_ADMIN("Super Administrator", "Full system access"),
    ADMIN("Administrator", "Branch-level admin access"),
    OWNER("Owner", "Business owner access"),
    BRANCH_MANAGER("Branch Manager", "Manage branch operations"),
    MANAGER("Manager", "Manage operations"),
    PHARMACIST("Pharmacist", "Dispense medicines and sales"),
    CASHIER("Cashier", "Sales and billing"),
    INVENTORY_MANAGER("Inventory Manager", "Manage stock and inventory"),
    ACCOUNTANT("Accountant", "Financial operations");

    private final String displayName;
    private final String description;

    Role(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }

    public String getDisplayName() { return displayName; }
    public String getDescription() { return description; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\SaleStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum SaleStatus {
    DRAFT("Draft"),
    COMPLETED("Completed"),
    CANCELLED("Cancelled"),
    RETURNED("Returned");

    private final String displayName;

    SaleStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\ScanContext.java"   & echo.. 
package com.pharmacy.medlan.enums;

/**
 * Context for barcode/QR scanning operations.
 * Different contexts require different data and validations.
 */
public enum ScanContext {
    
    /**
     * Point of Sale - quick product lookup for billing
     */
    POS("Point of Sale", "Quick lookup for billing, includes price and stock availability"),
    
    /**
     * Goods Receiving Note - receiving inventory from suppliers
     */
    GRN("Goods Receiving", "Product info with supplier and purchase history"),
    
    /**
     * Stock Taking / Physical Inventory
     */
    STOCK_TAKING("Stock Taking", "All batch details for inventory verification"),
    
    /**
     * Stock Transfer between branches
     */
    STOCK_TRANSFER("Stock Transfer", "Batch selection for inter-branch transfer"),
    
    /**
     * Return to Vendor
     */
    RETURN_VENDOR("Return to Vendor", "Batch details for supplier returns"),
    
    /**
     * Customer Return / Sale Return
     */
    SALE_RETURN("Sale Return", "Invoice lookup and return processing"),
    
    /**
     * Expiry Check
     */
    EXPIRY_CHECK("Expiry Check", "Batch expiry information and alerts"),
    
    /**
     * Price Check / Label Printing
     */
    PRICE_CHECK("Price Check", "Price information for customer or label printing"),
    
    /**
     * Prescription Dispensing
     */
    DISPENSING("Dispensing", "Drug schedule and prescription requirements"),
    
    /**
     * Product Verification / Authentication
     */
    VERIFICATION("Verification", "Authenticity verification via QR code");

    private final String displayName;
    private final String description;

    ScanContext(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getDescription() {
        return description;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\StockTransferStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum StockTransferStatus {
    PENDING("Pending"),
    APPROVED("Approved"),
    IN_TRANSIT("In Transit"),
    RECEIVED("Received"),
    REJECTED("Rejected"),
    CANCELLED("Cancelled");

    private final String displayName;

    StockTransferStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\SyncStatus.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum SyncStatus {
    PENDING("Pending"),
    IN_PROGRESS("In Progress"),
    COMPLETED("Completed"),
    FAILED("Failed"),
    CANCELLED("Cancelled");

    private final String displayName;

    SyncStatus(String displayName) {
        this.displayName = displayName;
    }

    public String getDisplayName() { return displayName; }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\TransactionType.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum TransactionType {
    GRN_RECEIVED("GRN Received", true),
    SALE("Sale", false),
    SALE_RETURN("Sale Return", true),
    PURCHASE_RETURN("Purchase Return (RGRN)", false),
    STOCK_ADJUSTMENT("Stock Adjustment", null),
    STOCK_TRANSFER_OUT("Stock Transfer Out", false),
    STOCK_TRANSFER_IN("Stock Transfer In", true),
    EXPIRED_STOCK("Expired Stock Removal", false),
    DAMAGED_STOCK("Damaged Stock Removal", false);

    private final String displayName;
    private final Boolean isIncrease; // true = increase, false = decrease, null = adjustment

    TransactionType(String displayName, Boolean isIncrease) {
        this.displayName = displayName;
        this.isIncrease = isIncrease;
    }

    public String getDisplayName() { return displayName; }
    public Boolean getIsIncrease() { return isIncrease; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\enums\UnitOfMeasure.java"   & echo.. 
package com.pharmacy.medlan.enums;

public enum UnitOfMeasure {
    PIECE("Piece", "pc"),
    TABLET("Tablet", "tab"),
    CAPSULE("Capsule", "cap"),
    BOTTLE("Bottle", "btl"),
    BOX("Box", "box"),
    STRIP("Strip", "strip"),
    VIAL("Vial", "vial"),
    AMPOULE("Ampoule", "amp"),
    TUBE("Tube", "tube"),
    SACHET("Sachet", "sac"),
    ML("Milliliter", "ml"),
    LITER("Liter", "L"),
    GRAM("Gram", "g"),
    KILOGRAM("Kilogram", "kg"),
    MICROGRAM("Microgram", "mcg"),
    MILLIGRAM("Milligram", "mg");

    private final String displayName;
    private final String abbreviation;

    UnitOfMeasure(String displayName, String abbreviation) {
        this.displayName = displayName;
        this.abbreviation = abbreviation;
    }

    public String getDisplayName() { return displayName; }
    public String getAbbreviation() { return abbreviation; }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\event\listener\InventoryEventListener.java"   & echo.. 
package com.pharmacy.medlan.event.listener;

public class InventoryEventListener {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\event\listener\SaleEventListener.java"   & echo.. 
package com.pharmacy.medlan.event.listener;

public class SaleEventListener {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\event\listener\SyncEventListener.java"   & echo.. 
package com.pharmacy.medlan.event.listener;

public class SyncEventListener {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\event\publisher\InventoryEventPublisher.java"   & echo.. 
package com.pharmacy.medlan.event.publisher;

public class InventoryEventPublisher {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\event\publisher\NotificationEventPublisher.java"   & echo.. 
package com.pharmacy.medlan.event.publisher;

public class NotificationEventPublisher {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\event\publisher\SaleEventPublisher.java"   & echo.. 
package com.pharmacy.medlan.event.publisher;

public class SaleEventPublisher {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\BusinessRuleViolationException.java"   & echo.. 
package com.pharmacy.medlan.exception;

public class BusinessRuleViolationException extends RuntimeException {
    public BusinessRuleViolationException(String message) {
        super(message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\DuplicationResourceException.java"   & echo.. 
package com.pharmacy.medlan.exception;

public class DuplicationResourceException extends RuntimeException {
    public DuplicationResourceException(String message) {
        super(message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\GlobalExceptionHandler.java"   & echo.. 
package com.pharmacy.medlan.exception;

import com.pharmacy.medlan.dto.response.common.ErrorResponse;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(
            ResourceNotFoundException ex, HttpServletRequest request) {
        log.error("Resource not found: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.NOT_FOUND.value(),
                "Not Found",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(DuplicationResourceException.class)
    public ResponseEntity<ErrorResponse> handleDuplicationResourceException(
            DuplicationResourceException ex, HttpServletRequest request) {
        log.error("Duplicate resource: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.CONFLICT.value(),
                "Conflict",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            ValidationException ex, HttpServletRequest request) {
        log.error("Validation error: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.BAD_REQUEST.value(),
                "Validation Error",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorizedException(
            UnauthorizedException ex, HttpServletRequest request) {
        log.error("Unauthorized: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.UNAUTHORIZED.value(),
                "Unauthorized",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }

    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<ErrorResponse> handleBadCredentialsException(
            BadCredentialsException ex, HttpServletRequest request) {
        log.error("Bad credentials: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.UNAUTHORIZED.value(),
                "Unauthorized",
                "Invalid username or password",
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(
            AuthenticationException ex, HttpServletRequest request) {
        log.error("Authentication failed: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.UNAUTHORIZED.value(),
                "Unauthorized",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDeniedException(
            AccessDeniedException ex, HttpServletRequest request) {
        log.error("Access denied: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.FORBIDDEN.value(),
                "Forbidden",
                "You don't have permission to access this resource",
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    @ExceptionHandler(InsufficientStockException.class)
    public ResponseEntity<ErrorResponse> handleInsufficientStockException(
            InsufficientStockException ex, HttpServletRequest request) {
        log.error("Insufficient stock: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.BAD_REQUEST.value(),
                "Insufficient Stock",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(BusinessRuleViolationException.class)
    public ResponseEntity<ErrorResponse> handleBusinessRuleViolationException(
            BusinessRuleViolationException ex, HttpServletRequest request) {
        log.error("Business rule violation: {}", ex.getMessage());
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.UNPROCESSABLE_ENTITY.value(),
                "Business Rule Violation",
                ex.getMessage(),
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValidException(
            MethodArgumentNotValidException ex, HttpServletRequest request) {
        log.error("Validation failed: {}", ex.getMessage());
        Map<String, String> fieldErrors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            fieldErrors.put(fieldName, errorMessage);
        });

        ErrorResponse error = ErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Validation Failed")
                .message("Request validation failed")
                .path(request.getRequestURI())
                .timestamp(LocalDateTime.now())
                .fieldErrors(fieldErrors)
                .build();

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex, HttpServletRequest request) {
        log.error("Unexpected error on path {}: {}", request.getRequestURI(), ex.getMessage(), ex);
        
        // Include more details in development (you can make this conditional based on profile)
        String message = "An unexpected error occurred";
        String errorDetail = ex.getMessage();
        
        // Get root cause for better debugging
        Throwable rootCause = ex;
        while (rootCause.getCause() != null && rootCause.getCause() != rootCause) {
            rootCause = rootCause.getCause();
        }
        
        if (rootCause != ex) {
            errorDetail = errorDetail + " | Root cause: " + rootCause.getMessage();
        }
        
        ErrorResponse error = ErrorResponse.of(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                "Internal Server Error",
                errorDetail != null ? errorDetail : message,
                request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\InsufficientStockException.java"   & echo.. 
package com.pharmacy.medlan.exception;

public class InsufficientStockException extends RuntimeException {
    public InsufficientStockException(String message) {
        super(message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\LegacyDataMigrationException.java"   & echo.. 
package com.pharmacy.medlan.exception;

public class LegacyDataMigrationException extends RuntimeException {
    public LegacyDataMigrationException(String message) {
        super(message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\ResourceNotFoundException.java"   & echo.. 
package com.pharmacy.medlan.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\SyncException.java"   & echo.. 
package com.pharmacy.medlan.exception;

public class SyncException extends RuntimeException {
    public SyncException(String message) {
        super(message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\UnauthorizedException.java"   & echo.. 
package com.pharmacy.medlan.exception;

public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\exception\ValidationException.java"   & echo.. 
package com.pharmacy.medlan.exception;

public class ValidationException extends RuntimeException {
    public ValidationException(String message) {
        super(message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\BranchMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.request.branch.CreateBranchRequest;
import com.pharmacy.medlan.dto.response.branch.BranchResponse;
import com.pharmacy.medlan.model.organization.Branch;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class BranchMapper {

    public BranchResponse toResponse(Branch branch) {
        if (branch == null) {
            return null;
        }

        return BranchResponse.builder()
                .id(branch.getId())
                .branchCode(branch.getBranchCode())
                .branchName(branch.getBranchName())
                .address(branch.getAddress())
                .city(branch.getCity())
                .state(branch.getState())
                .pincode(branch.getPincode())
                .phoneNumber(branch.getPhoneNumber())
                .email(branch.getEmail())
                .gstinNumber(branch.getGstinNumber())
                .drugLicenseNumber(branch.getDrugLicenseNumber())
                .managerId(branch.getManager() != null ? branch.getManager().getId() : null)
                .managerName(branch.getManager() != null ? branch.getManager().getUsername() : null)
                .isActive(branch.getIsActive())
                .isMainBranch(branch.getIsMainBranch())
                .createdAt(branch.getCreatedAt())
                .updatedAt(branch.getUpdatedAt())
                .build();
    }

    public List<BranchResponse> toResponseList(List<Branch> branches) {
        return branches.stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    public Branch toEntity(CreateBranchRequest request) {
        return Branch.builder()
                .branchCode(request.getBranchCode())
                .branchName(request.getBranchName())
                .address(request.getAddress())
                .city(request.getCity())
                .state(request.getState())
                .pincode(request.getPincode())
                .phoneNumber(request.getPhoneNumber())
                .email(request.getEmail())
                .gstinNumber(request.getGstinNumber())
                .drugLicenseNumber(request.getDrugLicenseNumber())
                .isMainBranch(request.getIsMainBranch() != null ? request.getIsMainBranch() : false)
                .isActive(true)
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\CustomerMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.request.pos.CreateCustomerRequest;
import com.pharmacy.medlan.dto.response.pos.CustomerResponse;
import com.pharmacy.medlan.enums.CustomerStatus;
import com.pharmacy.medlan.model.pos.Customer;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;

@Component
public class CustomerMapper {

    public CustomerResponse toResponse(Customer customer) {
        if (customer == null) {
            return null;
        }

        return CustomerResponse.builder()
                .id(customer.getId())
                .customerCode(customer.getCustomerCode())
                .customerName(customer.getCustomerName())
                .phoneNumber(customer.getPhoneNumber())
                .email(customer.getEmail())
                .gender(customer.getGender())
                .dateOfBirth(customer.getDateOfBirth())
                .address(customer.getAddress())
                .city(customer.getCity())
                .state(customer.getState())
                .pincode(customer.getPincode())
                .fax(customer.getFax())
                .creditLimit(customer.getCreditLimit())
                .currentBalance(customer.getCurrentBalance())
                .status(customer.getStatus())
                .description(customer.getDescription())
                .medicalHistory(customer.getMedicalHistory())
                .allergies(customer.getAllergies())
                .createdAt(customer.getCreatedAt())
                .updatedAt(customer.getUpdatedAt())
                .build();
    }

    public Customer toEntity(CreateCustomerRequest request) {
        if (request == null) {
            return null;
        }

        return Customer.builder()
                .customerName(request.getCustomerName())
                .phoneNumber(request.getPhoneNumber())
                .email(request.getEmail())
                .gender(request.getGender())
                .dateOfBirth(request.getDateOfBirth())
                .address(request.getAddress())
                .city(request.getCity())
                .state(request.getState())
                .pincode(request.getPincode())
                .fax(request.getFax())
                .creditLimit(request.getCreditLimit() != null ? request.getCreditLimit() : BigDecimal.ZERO)
                .currentBalance(BigDecimal.ZERO)
                .status(CustomerStatus.ACTIVE)
                .description(request.getDescription())
                .medicalHistory(request.getMedicalHistory())
                .allergies(request.getAllergies())
                .build();
    }

    public void updateEntityFromRequest(CreateCustomerRequest request, Customer customer) {
        if (request == null || customer == null) {
            return;
        }

        if (request.getCustomerName() != null) {
            customer.setCustomerName(request.getCustomerName());
        }
        if (request.getPhoneNumber() != null) {
            customer.setPhoneNumber(request.getPhoneNumber());
        }
        if (request.getEmail() != null) {
            customer.setEmail(request.getEmail());
        }
        if (request.getGender() != null) {
            customer.setGender(request.getGender());
        }
        if (request.getDateOfBirth() != null) {
            customer.setDateOfBirth(request.getDateOfBirth());
        }
        if (request.getAddress() != null) {
            customer.setAddress(request.getAddress());
        }
        if (request.getCity() != null) {
            customer.setCity(request.getCity());
        }
        if (request.getState() != null) {
            customer.setState(request.getState());
        }
        if (request.getPincode() != null) {
            customer.setPincode(request.getPincode());
        }
        if (request.getCreditLimit() != null) {
            customer.setCreditLimit(request.getCreditLimit());
        }
        if (request.getDescription() != null) {
            customer.setDescription(request.getDescription());
        }
        if (request.getMedicalHistory() != null) {
            customer.setMedicalHistory(request.getMedicalHistory());
        }
        if (request.getAllergies() != null) {
            customer.setAllergies(request.getAllergies());
        }
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\FinanceMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

public class FinanceMapper {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\GRNMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.response.inventory.GRNResponse;
import com.pharmacy.medlan.model.inventory.GRN;
import com.pharmacy.medlan.model.inventory.GRNLine;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class GRNMapper {

    public GRNResponse toResponse(GRN grn) {
        if (grn == null) {
            return null;
        }

        return GRNResponse.builder()
                .id(grn.getId())
                .grnNumber(grn.getGrnNumber())
                .purchaseOrderId(grn.getPurchaseOrder() != null ? grn.getPurchaseOrder().getId() : null)
                .purchaseOrderNumber(grn.getPurchaseOrder() != null ? grn.getPurchaseOrder().getPoNumber() : null)
                .supplierId(grn.getSupplier() != null ? grn.getSupplier().getId() : null)
                .supplierName(grn.getSupplier() != null ? grn.getSupplier().getSupplierName() : null)
                .branchId(grn.getBranch() != null ? grn.getBranch().getId() : null)
                .branchName(grn.getBranch() != null ? grn.getBranch().getBranchName() : null)
                .receivedDate(grn.getReceivedDate())
                .supplierInvoiceNumber(grn.getSupplierInvoiceNumber())
                .supplierInvoiceDate(grn.getSupplierInvoiceDate())
                .totalAmount(grn.getTotalAmount())
                .discountAmount(grn.getDiscountAmount())
                .taxAmount(grn.getTaxAmount())
                .netAmount(grn.getNetAmount())
                .status(grn.getStatus())
                .remarks(grn.getRemarks())
                .receivedByUserName(grn.getReceivedBy() != null ? grn.getReceivedBy().getUsername() : null)
                .approvedByUserName(grn.getApprovedBy() != null ? grn.getApprovedBy().getUsername() : null)
                .approvedAt(grn.getApprovedAt())
                .paidAmount(grn.getPaidAmount())
                .balanceAmount(grn.getBalanceAmount())
                .paymentStatus(grn.getPaymentStatus())
                .items(toLineResponses(grn.getGrnLines()))
                .createdAt(grn.getCreatedAt())
                .build();
    }

    public List<GRNResponse> toResponseList(List<GRN> grns) {
        return grns.stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    public GRNResponse.GRNLineResponse toLineResponse(GRNLine line) {
        if (line == null) {
            return null;
        }

        return GRNResponse.GRNLineResponse.builder()
                .id(line.getId())
                .productId(line.getProduct() != null ? line.getProduct().getId() : null)
                .productName(line.getProduct() != null ? line.getProduct().getProductName() : null)
                .productCode(line.getProduct() != null ? line.getProduct().getProductCode() : null)
                .batchNumber(line.getBatchNumber())
                .quantity(line.getQuantityReceived())
                .costPrice(line.getUnitPrice())
                .sellingPrice(line.getSellingPrice())
                .mrp(line.getMrp())
                .manufacturingDate(line.getManufacturingDate())
                .expiryDate(line.getExpiryDate())
                .discountAmount(line.getDiscountAmount())
                .totalAmount(line.getTotalAmount())
                .build();
    }

    public List<GRNResponse.GRNLineResponse> toLineResponses(List<GRNLine> lines) {
        if (lines == null) {
            return List.of();
        }
        return lines.stream()
                .map(this::toLineResponse)
                .collect(Collectors.toList());
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\InventoryMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.response.inventory.InventoryBatchResponse;
import com.pharmacy.medlan.dto.response.inventory.InventoryResponse;
import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.product.InventoryBatch;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class InventoryMapper {

    public InventoryBatchResponse toBatchResponse(InventoryBatch batch) {
        if (batch == null) {
            return null;
        }

        LocalDate today = LocalDate.now();
        boolean isExpired = batch.getExpiryDate() != null && batch.getExpiryDate().isBefore(today);
        int daysToExpiry = batch.getExpiryDate() != null ? 
                (int) ChronoUnit.DAYS.between(today, batch.getExpiryDate()) : 0;

        return InventoryBatchResponse.builder()
                .id(batch.getId())
                .productId(batch.getProduct() != null ? batch.getProduct().getId() : null)
                .productCode(batch.getProduct() != null ? batch.getProduct().getProductCode() : null)
                .productName(batch.getProduct() != null ? batch.getProduct().getProductName() : null)
                .branchId(batch.getBranch() != null ? batch.getBranch().getId() : null)
                .branchName(batch.getBranch() != null ? batch.getBranch().getBranchName() : null)
                .batchNumber(batch.getBatchNumber())
                .manufacturingDate(batch.getManufacturingDate())
                .expiryDate(batch.getExpiryDate())
                .quantityReceived(batch.getQuantityReceived())
                .quantityAvailable(batch.getQuantityAvailable())
                .quantitySold(batch.getQuantitySold())
                .costPrice(batch.getPurchasePrice())
                .sellingPrice(batch.getSellingPrice())
                .isActive(batch.getIsActive())
                .isExpired(isExpired)
                .daysToExpiry(daysToExpiry)
                .createdAt(batch.getCreatedAt())
                .build();
    }

    public List<InventoryBatchResponse> toBatchResponseList(List<InventoryBatch> batches) {
        return batches.stream()
                .map(this::toBatchResponse)
                .collect(Collectors.toList());
    }

    public InventoryResponse toInventoryResponse(BranchInventory inventory, List<InventoryBatch> batches) {
        if (inventory == null) {
            return null;
        }

        String stockStatus = "IN_STOCK";
        if (inventory.getQuantityAvailable() <= 0) {
            stockStatus = "OUT_OF_STOCK";
        } else if (inventory.getQuantityAvailable() <= inventory.getReorderLevel()) {
            stockStatus = "LOW_STOCK";
        }

        return InventoryResponse.builder()
                .productId(inventory.getProduct() != null ? inventory.getProduct().getId() : null)
                .productCode(inventory.getProduct() != null ? inventory.getProduct().getProductCode() : null)
                .productName(inventory.getProduct() != null ? inventory.getProduct().getProductName() : null)
                .branchId(inventory.getBranch() != null ? inventory.getBranch().getId() : null)
                .branchName(inventory.getBranch() != null ? inventory.getBranch().getBranchName() : null)
                .totalQuantity(inventory.getQuantityAvailable())
                .minimumStock(inventory.getMinimumStock())
                .reorderLevel(inventory.getReorderLevel())
                .sellingPrice(inventory.getProduct() != null ? inventory.getProduct().getSellingPrice() : null)
                .stockStatus(stockStatus)
                .batches(toBatchResponseList(batches))
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\InvoiceMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.response.pos.InvoiceResponse;
import com.pharmacy.medlan.model.pos.Invoice;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class InvoiceMapper {

    public InvoiceResponse toResponse(Invoice invoice) {
        if (invoice == null) {
            return null;
        }

        return InvoiceResponse.builder()
                .id(invoice.getId())
                .invoiceNumber(invoice.getInvoiceNumber())
                .customerId(invoice.getCustomer() != null ? invoice.getCustomer().getId() : null)
                .customerName(invoice.getCustomer() != null ? invoice.getCustomer().getCustomerName() : null)
                .branchId(invoice.getBranch() != null ? invoice.getBranch().getId() : null)
                .branchName(invoice.getBranch() != null ? invoice.getBranch().getBranchName() : null)
                .invoiceDate(invoice.getInvoiceDate())
                .dueDate(invoice.getDueDate())
                .subtotal(invoice.getSubtotal())
                .discount(invoice.getDiscount())
                .totalAmount(invoice.getTotalAmount())
                .paidAmount(invoice.getPaidAmount())
                .balanceAmount(invoice.getBalanceAmount())
                .status(invoice.getStatus())
                .paymentStatus(invoice.getPaymentStatus())
                .paymentType(invoice.getPaymentType())
                .chequeNumber(invoice.getChequeNumber())
                .chequeDate(invoice.getChequeDate())
                .createdAt(invoice.getCreatedAt())
                .build();
    }

    public List<InvoiceResponse> toResponseList(List<Invoice> invoices) {
        return invoices.stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\NotificationMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

public class NotificationMapper {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\PayrollMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

public class PayrollMapper {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\ProductMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.request.product.CreateProductRequest;
import com.pharmacy.medlan.dto.request.product.UpdateProductRequest;
import com.pharmacy.medlan.dto.response.product.CategoryResponse;
import com.pharmacy.medlan.dto.response.product.ProductResponse;
import com.pharmacy.medlan.dto.response.product.SubCategoryResponse;
import com.pharmacy.medlan.model.product.Category;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.product.SubCategory;
import org.springframework.stereotype.Component;
import java.util.stream.Collectors;

@Component
public class ProductMapper {

    // ==================== Product Mappings ====================

    public Product toEntity(CreateProductRequest request) {
        if (request == null) {
            return null;
        }

        return Product.builder()
                .productName(request.getProductName())
                .genericName(request.getGenericName())
                .dosageForm(request.getDosageForm())
                .strength(request.getStrength())
                .drugSchedule(request.getDrugSchedule())
                .manufacturer(request.getManufacturer())
                .supplier(request.getSupplier())
                .barcode(request.getBarcode())
                .description(request.getDescription())
                .costPrice(request.getCostPrice())
                .sellingPrice(request.getSellingPrice())
                .mrp(request.getMrp())
                .profitMargin(request.getProfitMargin())
                .gstRate(request.getGstRate())
                .reorderLevel(request.getReorderLevel() != null ? request.getReorderLevel() : 10)
                .minimumStock(request.getMinimumStock() != null ? request.getMinimumStock() : 5)
                .maximumStock(request.getMaximumStock() != null ? request.getMaximumStock() : 1000)
                .isPrescriptionRequired(request.getIsPrescriptionRequired() != null ? request.getIsPrescriptionRequired() : false)
                .isNarcotic(request.getIsNarcotic() != null ? request.getIsNarcotic() : false)
                .isRefrigerated(request.getIsRefrigerated() != null ? request.getIsRefrigerated() : false)
                .isActive(true)
                .isDiscontinued(false)
                .build();
    }

    public ProductResponse toResponse(Product product) {
        if (product == null) {
            return null;
        }

        return ProductResponse.builder()
                .id(product.getId())
                .productCode(product.getProductCode())
                .productName(product.getProductName())
                .genericName(product.getGenericName())
                .categoryId(product.getCategory() != null ? product.getCategory().getId() : null)
                .categoryName(product.getCategory() != null ? product.getCategory().getCategoryName() : null)
                .subCategoryId(product.getSubCategory() != null ? product.getSubCategory().getId() : null)
                .subCategoryName(product.getSubCategory() != null ? product.getSubCategory().getSubCategoryName() : null)
                .unitId(product.getUnit() != null ? product.getUnit().getId() : null)
                .unitName(product.getUnit() != null ? product.getUnit().getUnitName() : null)
                .dosageForm(product.getDosageForm())
                .strength(product.getStrength())
                .drugSchedule(product.getDrugSchedule())
                .manufacturer(product.getManufacturer())
                .supplier(product.getSupplier())
                .barcode(product.getBarcode())
                .description(product.getDescription())
                .costPrice(product.getCostPrice())
                .sellingPrice(product.getSellingPrice())
                .mrp(product.getMrp())
                .profitMargin(product.getProfitMargin())
                .gstRate(product.getGstRate())
                .taxCategoryId(product.getTaxCategory() != null ? product.getTaxCategory().getId() : null)
                .taxCategoryName(product.getTaxCategory() != null ? product.getTaxCategory().getTaxName() : null)
                .reorderLevel(product.getReorderLevel())
                .minimumStock(product.getMinimumStock())
                .maximumStock(product.getMaximumStock())
                .isPrescriptionRequired(product.getIsPrescriptionRequired())
                .isActive(product.getIsActive())
                .isDiscontinued(product.getIsDiscontinued())
                .isNarcotic(product.getIsNarcotic())
                .isRefrigerated(product.getIsRefrigerated())
                .createdAt(product.getCreatedAt())
                .updatedAt(product.getUpdatedAt())
                .build();
    }

    public void updateEntityFromRequest(UpdateProductRequest request, Product product) {
        if (request == null || product == null) {
            return;
        }

        if (request.getProductName() != null) {
            product.setProductName(request.getProductName());
        }
        if (request.getGenericName() != null) {
            product.setGenericName(request.getGenericName());
        }
        if (request.getDosageForm() != null) {
            product.setDosageForm(request.getDosageForm());
        }
        if (request.getStrength() != null) {
            product.setStrength(request.getStrength());
        }
        if (request.getDrugSchedule() != null) {
            product.setDrugSchedule(request.getDrugSchedule());
        }
        if (request.getManufacturer() != null) {
            product.setManufacturer(request.getManufacturer());
        }
        if (request.getSupplier() != null) {
            product.setSupplier(request.getSupplier());
        }
        if (request.getBarcode() != null) {
            product.setBarcode(request.getBarcode());
        }
        if (request.getDescription() != null) {
            product.setDescription(request.getDescription());
        }
        if (request.getCostPrice() != null) {
            product.setCostPrice(request.getCostPrice());
        }
        if (request.getSellingPrice() != null) {
            product.setSellingPrice(request.getSellingPrice());
        }
        if (request.getMrp() != null) {
            product.setMrp(request.getMrp());
        }
        if (request.getProfitMargin() != null) {
            product.setProfitMargin(request.getProfitMargin());
        }
        if (request.getGstRate() != null) {
            product.setGstRate(request.getGstRate());
        }
        if (request.getReorderLevel() != null) {
            product.setReorderLevel(request.getReorderLevel());
        }
        if (request.getMinimumStock() != null) {
            product.setMinimumStock(request.getMinimumStock());
        }
        if (request.getMaximumStock() != null) {
            product.setMaximumStock(request.getMaximumStock());
        }
        if (request.getIsPrescriptionRequired() != null) {
            product.setIsPrescriptionRequired(request.getIsPrescriptionRequired());
        }
        if (request.getIsActive() != null) {
            product.setIsActive(request.getIsActive());
        }
        if (request.getIsDiscontinued() != null) {
            product.setIsDiscontinued(request.getIsDiscontinued());
        }
        if (request.getIsNarcotic() != null) {
            product.setIsNarcotic(request.getIsNarcotic());
        }
        if (request.getIsRefrigerated() != null) {
            product.setIsRefrigerated(request.getIsRefrigerated());
        }
    }

    // ==================== Category Mappings ====================

    public CategoryResponse toCategoryResponse(Category category) {
        if (category == null) {
            return null;
        }

        return CategoryResponse.builder()
                .id(category.getId())
                .categoryName(category.getCategoryName())
                .categoryCode(category.getCategoryCode())
                .description(category.getDescription())
                .minCode(category.getMinCode())
                .maxCode(category.getMaxCode())
                .isActive(category.getIsActive())
                .subCategoryCount(0) // Set to 0 to avoid LazyInitializationException
                .productCount(0) // Set to 0 to avoid LazyInitializationException
                .subCategories(null) // Set to null to avoid LazyInitializationException
                .createdAt(category.getCreatedAt())
                .updatedAt(category.getUpdatedAt())
                .build();
    }

    // ==================== SubCategory Mappings ====================

    public SubCategoryResponse toSubCategoryResponse(SubCategory subCategory) {
        if (subCategory == null) {
            return null;
        }

        return SubCategoryResponse.builder()
                .id(subCategory.getId())
                .subCategoryName(subCategory.getSubCategoryName())
                .subCategoryCode(subCategory.getSubCategoryCode())
                .description(subCategory.getDescription())
                .minCode(subCategory.getMinCode())
                .maxCode(subCategory.getMaxCode())
                .isActive(subCategory.getIsActive())
                .categoryId(subCategory.getCategory() != null ? subCategory.getCategory().getId() : null)
                .categoryName(subCategory.getCategory() != null ? subCategory.getCategory().getCategoryName() : null)
                .productCount(subCategory.getProducts() != null ? subCategory.getProducts().size() : 0)
                .createdAt(subCategory.getCreatedAt())
                .updatedAt(subCategory.getUpdatedAt())
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\PurchaseOrderMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.response.supplier.PurchaseOrderResponse;
import com.pharmacy.medlan.model.supplier.PurchaseOrder;
import com.pharmacy.medlan.model.supplier.PurchaseOrderItem;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class PurchaseOrderMapper {

    public PurchaseOrderResponse toResponse(PurchaseOrder po) {
        if (po == null) {
            return null;
        }

        return PurchaseOrderResponse.builder()
                .id(po.getId())
                .poNumber(po.getPoNumber())
                .supplierId(po.getSupplier().getId())
                .supplierName(po.getSupplier().getSupplierName())
                .branchId(po.getBranch().getId())
                .branchName(po.getBranch().getBranchName())
                .orderDate(po.getOrderDate())
                .expectedDeliveryDate(po.getExpectedDeliveryDate())
                .actualDeliveryDate(po.getActualDeliveryDate())
                .totalAmount(po.getTotalAmount())
                .discountAmount(po.getDiscountAmount())
                .taxAmount(po.getTaxAmount())
                .netAmount(po.getNetAmount())
                .status(po.getStatus())
                .createdByName(po.getCreatedByUser() != null ? po.getCreatedByUser().getFullName() : null)
                .approvedByName(po.getApprovedByUser() != null ? po.getApprovedByUser().getFullName() : null)
                .approvedAt(po.getApprovedAt())
                .remarks(po.getRemarks())
                .supplierReference(po.getSupplierReference())
                .items(po.getItems() != null ? 
                        po.getItems().stream()
                                .map(this::toItemResponse)
                                .collect(Collectors.toList()) : null)
                .createdAt(po.getCreatedAt())
                .updatedAt(po.getUpdatedAt())
                .build();
    }

    public PurchaseOrderResponse.PurchaseOrderItemResponse toItemResponse(PurchaseOrderItem item) {
        if (item == null) {
            return null;
        }

        return PurchaseOrderResponse.PurchaseOrderItemResponse.builder()
                .id(item.getId())
                .productId(item.getProduct().getId())
                .productName(item.getProduct().getProductName())
                .productSku(item.getProduct().getProductCode())
                .quantityOrdered(item.getQuantityOrdered())
                .quantityReceived(item.getQuantityReceived())
                .unitPrice(item.getUnitPrice())
                .discountPercent(item.getDiscountPercent())
                .discountAmount(item.getDiscountAmount())
                .gstRate(item.getGstRate())
                .gstAmount(item.getGstAmount())
                .totalAmount(item.getTotalAmount())
                .remarks(item.getRemarks())
                .build();
    }

    public List<PurchaseOrderResponse> toResponseList(List<PurchaseOrder> purchaseOrders) {
        if (purchaseOrders == null) {
            return null;
        }
        return purchaseOrders.stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\RGRNMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.response.inventory.RGRNResponse;
import com.pharmacy.medlan.model.inventory.RGRN;
import com.pharmacy.medlan.model.inventory.RGRNLine;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class RGRNMapper {

    public RGRNResponse toResponse(RGRN rgrn) {
        if (rgrn == null) {
            return null;
        }

        return RGRNResponse.builder()
                .id(rgrn.getId())
                .rgrnNumber(rgrn.getRgrnNumber())
                .originalGrnId(rgrn.getOriginalGrn() != null ? rgrn.getOriginalGrn().getId() : null)
                .originalGrnNumber(rgrn.getOriginalGrn() != null ? rgrn.getOriginalGrn().getGrnNumber() : null)
                .supplierId(rgrn.getSupplier().getId())
                .supplierName(rgrn.getSupplier().getSupplierName())
                .branchId(rgrn.getBranch().getId())
                .branchName(rgrn.getBranch().getBranchName())
                .returnDate(rgrn.getReturnDate())
                .totalReturnAmount(rgrn.getTotalReturnAmount())
                .refundStatus(rgrn.getRefundStatus())
                .returnReason(rgrn.getReturnReason())
                .returnedByName(rgrn.getReturnedBy() != null ? rgrn.getReturnedBy().getFullName() : null)
                .remarks(rgrn.getRemarks())
                .lines(rgrn.getRgrnLines() != null ? 
                        rgrn.getRgrnLines().stream()
                                .map(this::toLineResponse)
                                .collect(Collectors.toList()) : null)
                .createdAt(rgrn.getCreatedAt())
                .updatedAt(rgrn.getUpdatedAt())
                .build();
    }

    public RGRNResponse.RGRNLineResponse toLineResponse(RGRNLine line) {
        if (line == null) {
            return null;
        }

        return RGRNResponse.RGRNLineResponse.builder()
                .id(line.getId())
                .productId(line.getProduct().getId())
                .productName(line.getProductName() != null ? line.getProductName() : line.getProduct().getProductName())
                .inventoryBatchId(line.getInventoryBatch() != null ? line.getInventoryBatch().getId() : null)
                .batchNumber(line.getBatchNumber())
                .quantityReturned(line.getQuantityReturned())
                .unitPrice(line.getUnitPrice())
                .totalAmount(line.getTotalAmount())
                .returnReason(line.getReturnReason())
                .build();
    }

    public List<RGRNResponse> toResponseList(List<RGRN> rgrns) {
        if (rgrns == null) {
            return null;
        }
        return rgrns.stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\SaleMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.response.pos.SaleItemResponse;
import com.pharmacy.medlan.dto.response.pos.SaleResponse;
import com.pharmacy.medlan.model.pos.Sale;
import com.pharmacy.medlan.model.pos.SaleItem;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class SaleMapper {

    public SaleResponse toResponse(Sale sale) {
        if (sale == null) {
            return null;
        }

        return SaleResponse.builder()
                .id(sale.getId())
                .saleNumber(sale.getSaleNumber())
                .invoiceId(sale.getInvoice() != null ? sale.getInvoice().getId() : null)
                .invoiceNumber(sale.getInvoice() != null ? sale.getInvoice().getInvoiceNumber() : null)
                .branchId(sale.getBranch() != null ? sale.getBranch().getId() : null)
                .branchName(sale.getBranch() != null ? sale.getBranch().getBranchName() : null)
                .customerId(sale.getCustomer() != null ? sale.getCustomer().getId() : null)
                .customerName(sale.getCustomer() != null ? sale.getCustomer().getCustomerName() : null)
                .saleDate(sale.getSaleDate())
                .subtotal(sale.getSubtotal())
                .discountAmount(sale.getDiscountAmount())
                .discountPercent(sale.getDiscountPercent())
                .taxAmount(sale.getTaxAmount())
                .totalAmount(sale.getTotalAmount())
                .paidAmount(sale.getPaidAmount())
                .changeAmount(sale.getChangeAmount())
                .paymentMethod(sale.getPaymentMethod())
                .status(sale.getStatus())
                .soldByUserName(sale.getSoldBy() != null ? sale.getSoldBy().getUsername() : null)
                .patientName(sale.getPatientName())
                .doctorName(sale.getDoctorName())
                .remarks(sale.getRemarks())
                .items(toSaleItemResponses(sale.getSaleItems()))
                .createdAt(sale.getCreatedAt())
                .build();
    }

    public List<SaleResponse> toResponseList(List<Sale> sales) {
        return sales.stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    public SaleItemResponse toSaleItemResponse(SaleItem item) {
        if (item == null) {
            return null;
        }

        return SaleItemResponse.builder()
                .id(item.getId())
                .productId(item.getProduct() != null ? item.getProduct().getId() : null)
                .productName(item.getProductName())
                .productCode(item.getProduct() != null ? item.getProduct().getProductCode() : null)
                .inventoryBatchId(item.getInventoryBatch() != null ? item.getInventoryBatch().getId() : null)
                .batchNumber(item.getBatchNumber())
                .quantity(item.getQuantity())
                .unitPrice(item.getUnitPrice())
                .discountAmount(item.getDiscountAmount())
                .taxAmount(item.getTaxAmount())
                .totalAmount(item.getTotalAmount())
                .costPrice(item.getCostPrice())
                .profit(item.getProfit())
                .build();
    }

    public List<SaleItemResponse> toSaleItemResponses(List<SaleItem> items) {
        if (items == null) {
            return List.of();
        }
        return items.stream()
                .map(this::toSaleItemResponse)
                .collect(Collectors.toList());
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\SaleReturnMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.response.pos.SaleReturnResponse;
import com.pharmacy.medlan.model.pos.SaleReturn;
import com.pharmacy.medlan.model.pos.SaleReturnItem;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class SaleReturnMapper {

    public SaleReturnResponse toResponse(SaleReturn saleReturn) {
        if (saleReturn == null) {
            return null;
        }

        return SaleReturnResponse.builder()
                .id(saleReturn.getId())
                .returnNumber(saleReturn.getReturnNumber())
                .originalSaleId(saleReturn.getOriginalSale() != null ? 
                        saleReturn.getOriginalSale().getId() : null)
                .originalSaleNumber(saleReturn.getOriginalSale() != null ? 
                        saleReturn.getOriginalSale().getSaleNumber() : null)
                .branchId(saleReturn.getBranch().getId())
                .branchName(saleReturn.getBranch().getBranchName())
                .customerId(saleReturn.getCustomer() != null ? saleReturn.getCustomer().getId() : null)
                .customerName(saleReturn.getCustomer() != null ? saleReturn.getCustomer().getCustomerName() : null)
                .returnDate(saleReturn.getReturnDate())
                .totalReturnAmount(saleReturn.getTotalReturnAmount())
                .refundAmount(saleReturn.getRefundAmount())
                .returnReason(saleReturn.getReturnReason())
                .processedByName(saleReturn.getProcessedBy() != null ? 
                        saleReturn.getProcessedBy().getFullName() : null)
                .items(saleReturn.getReturnItems() != null ? 
                        saleReturn.getReturnItems().stream()
                                .map(this::toItemResponse)
                                .collect(Collectors.toList()) : null)
                .createdAt(saleReturn.getCreatedAt())
                .updatedAt(saleReturn.getUpdatedAt())
                .build();
    }

    public SaleReturnResponse.SaleReturnItemResponse toItemResponse(SaleReturnItem item) {
        if (item == null) {
            return null;
        }

        return SaleReturnResponse.SaleReturnItemResponse.builder()
                .id(item.getId())
                .originalSaleItemId(item.getOriginalSaleItem() != null ? 
                        item.getOriginalSaleItem().getId() : null)
                .productId(item.getProduct().getId())
                .productName(item.getProduct().getProductName())
                .productSku(item.getProduct().getProductCode())
                .inventoryBatchId(item.getInventoryBatch() != null ? 
                        item.getInventoryBatch().getId() : null)
                .batchNumber(item.getInventoryBatch() != null ? 
                        item.getInventoryBatch().getBatchNumber() : null)
                .quantityReturned(item.getQuantityReturned())
                .unitPrice(item.getUnitPrice())
                .totalAmount(item.getTotalAmount())
                .returnReason(item.getReturnReason())
                .build();
    }

    public List<SaleReturnResponse> toResponseList(List<SaleReturn> saleReturns) {
        if (saleReturns == null) {
            return null;
        }
        return saleReturns.stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\StockTransferMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.response.inventory.StockTransferResponse;
import com.pharmacy.medlan.model.inventory.StockTransfer;
import com.pharmacy.medlan.model.inventory.StockTransferItem;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.stream.Collectors;

@Component
public class StockTransferMapper {

    public StockTransferResponse toResponse(StockTransfer stockTransfer) {
        if (stockTransfer == null) {
            return null;
        }

        return StockTransferResponse.builder()
                .id(stockTransfer.getId())
                .transferNumber(stockTransfer.getTransferNumber())
                .fromBranchId(stockTransfer.getFromBranch() != null ? stockTransfer.getFromBranch().getId() : null)
                .fromBranchName(stockTransfer.getFromBranch() != null ? stockTransfer.getFromBranch().getBranchName() : null)
                .toBranchId(stockTransfer.getToBranch() != null ? stockTransfer.getToBranch().getId() : null)
                .toBranchName(stockTransfer.getToBranch() != null ? stockTransfer.getToBranch().getBranchName() : null)
                .transferDate(stockTransfer.getTransferDate())
                .expectedReceiptDate(stockTransfer.getExpectedReceiptDate())
                .actualReceiptDate(stockTransfer.getActualReceiptDate())
                .status(stockTransfer.getStatus())
                .initiatedByName(stockTransfer.getInitiatedBy() != null ? stockTransfer.getInitiatedBy().getFullName() : null)
                .approvedByName(stockTransfer.getApprovedBy() != null ? stockTransfer.getApprovedBy().getFullName() : null)
                .approvedAt(stockTransfer.getApprovedAt())
                .receivedByName(stockTransfer.getReceivedBy() != null ? stockTransfer.getReceivedBy().getFullName() : null)
                .remarks(stockTransfer.getRemarks())
                .items(mapItems(stockTransfer.getItems()))
                .createdAt(stockTransfer.getCreatedAt())
                .updatedAt(stockTransfer.getUpdatedAt())
                .build();
    }

    public List<StockTransferResponse> toResponseList(List<StockTransfer> stockTransfers) {
        if (stockTransfers == null) {
            return null;
        }
        return stockTransfers.stream()
                .map(this::toResponse)
                .collect(Collectors.toList());
    }

    private List<StockTransferResponse.StockTransferItemResponse> mapItems(List<StockTransferItem> items) {
        if (items == null) {
            return null;
        }
        return items.stream()
                .map(this::mapItem)
                .collect(Collectors.toList());
    }

    private StockTransferResponse.StockTransferItemResponse mapItem(StockTransferItem item) {
        if (item == null) {
            return null;
        }

        return StockTransferResponse.StockTransferItemResponse.builder()
                .id(item.getId())
                .productId(item.getProduct() != null ? item.getProduct().getId() : null)
                .productName(item.getProduct() != null ? item.getProduct().getProductName() : null)
                .productSku(item.getProduct() != null ? item.getProduct().getProductCode() : null)
                .inventoryBatchId(item.getInventoryBatch() != null ? item.getInventoryBatch().getId() : null)
                .batchNumber(item.getInventoryBatch() != null ? item.getInventoryBatch().getBatchNumber() : null)
                .quantityTransferred(item.getQuantityTransferred())
                .quantityReceived(item.getQuantityReceived())
                .remarks(item.getRemarks())
                .build();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\SupplierMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.request.supplier.CreateSupplierRequest;
import com.pharmacy.medlan.dto.response.supplier.SupplierResponse;
import com.pharmacy.medlan.model.supplier.Supplier;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;

@Component
public class SupplierMapper {

    public SupplierResponse toResponse(Supplier supplier) {
        if (supplier == null) {
            return null;
        }

        return SupplierResponse.builder()
                .id(supplier.getId())
                .supplierCode(supplier.getSupplierCode())
                .supplierName(supplier.getSupplierName())
                .contactPerson(supplier.getContactPerson())
                .phoneNumber(supplier.getPhoneNumber())
                .email(supplier.getEmail())
                .address(supplier.getAddress())
                .city(supplier.getCity())
                .state(supplier.getState())
                .pincode(supplier.getPincode())
                .gstinNumber(supplier.getGstinNumber())
                .panNumber(supplier.getPanNumber())
                .drugLicenseNumber(supplier.getDrugLicenseNumber())
                .defaultDiscountPercent(supplier.getDefaultDiscountPercent())
                .paymentTermDays(supplier.getPaymentTermDays())
                .creditLimit(supplier.getCreditLimit())
                .currentBalance(supplier.getCurrentBalance())
                .isActive(supplier.getIsActive())
                .createdAt(supplier.getCreatedAt())
                .updatedAt(supplier.getUpdatedAt())
                .build();
    }

    public Supplier toEntity(CreateSupplierRequest request) {
        if (request == null) {
            return null;
        }

        return Supplier.builder()
                .supplierName(request.getSupplierName())
                .contactPerson(request.getContactPerson())
                .phoneNumber(request.getPhoneNumber())
                .email(request.getEmail())
                .address(request.getAddress())
                .city(request.getCity())
                .state(request.getState())
                .pincode(request.getPincode())
                .gstinNumber(request.getGstinNumber())
                .panNumber(request.getPanNumber())
                .drugLicenseNumber(request.getDrugLicenseNumber())
                .defaultDiscountPercent(request.getDefaultDiscountPercent() != null ? request.getDefaultDiscountPercent() : BigDecimal.ZERO)
                .paymentTermDays(request.getPaymentTermDays() != null ? request.getPaymentTermDays() : 30)
                .creditLimit(request.getCreditLimit() != null ? request.getCreditLimit() : BigDecimal.ZERO)
                .currentBalance(BigDecimal.ZERO)
                .isActive(true)
                .build();
    }

    public void updateEntityFromRequest(CreateSupplierRequest request, Supplier supplier) {
        if (request == null || supplier == null) {
            return;
        }

        if (request.getSupplierName() != null) {
            supplier.setSupplierName(request.getSupplierName());
        }
        if (request.getContactPerson() != null) {
            supplier.setContactPerson(request.getContactPerson());
        }
        if (request.getPhoneNumber() != null) {
            supplier.setPhoneNumber(request.getPhoneNumber());
        }
        if (request.getEmail() != null) {
            supplier.setEmail(request.getEmail());
        }
        if (request.getAddress() != null) {
            supplier.setAddress(request.getAddress());
        }
        if (request.getCity() != null) {
            supplier.setCity(request.getCity());
        }
        if (request.getState() != null) {
            supplier.setState(request.getState());
        }
        if (request.getPincode() != null) {
            supplier.setPincode(request.getPincode());
        }
        if (request.getGstinNumber() != null) {
            supplier.setGstinNumber(request.getGstinNumber());
        }
        if (request.getPanNumber() != null) {
            supplier.setPanNumber(request.getPanNumber());
        }
        if (request.getDrugLicenseNumber() != null) {
            supplier.setDrugLicenseNumber(request.getDrugLicenseNumber());
        }
        if (request.getDefaultDiscountPercent() != null) {
            supplier.setDefaultDiscountPercent(request.getDefaultDiscountPercent());
        }
        if (request.getPaymentTermDays() != null) {
            supplier.setPaymentTermDays(request.getPaymentTermDays());
        }
        if (request.getCreditLimit() != null) {
            supplier.setCreditLimit(request.getCreditLimit());
        }
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\mapper\UserMapper.java"   & echo.. 
package com.pharmacy.medlan.mapper;

import com.pharmacy.medlan.dto.request.user.CreateUserRequest;
import com.pharmacy.medlan.dto.request.user.UpdateUserRequest;
import com.pharmacy.medlan.dto.response.user.UserResponse;
import com.pharmacy.medlan.model.user.User;
import org.springframework.stereotype.Component;

@Component
public class UserMapper {

    public UserResponse toUserResponse(User user) {
        if (user == null) {
            return null;
        }

        return UserResponse.builder()
                .id(user.getId())
                .username(user.getUsername())
                .fullName(user.getFullName())
                .email(user.getEmail())
                .phoneNumber(user.getPhoneNumber())
                .role(user.getRole())
                .isActive(user.getIsActive())
                .lastLoginDate(user.getLastLoginDate())
                .discountLimit(user.getDiscountLimit())
                .creditTransactionLimit(user.getCreditTransactionLimit())
                .employeeCode(user.getEmployeeCode())
                .createdAt(user.getCreatedAt())
                .updatedAt(user.getUpdatedAt())
                .build();
    }

    public User toEntity(CreateUserRequest request) {
        if (request == null) {
            return null;
        }

        return User.builder()
                .username(request.getUsername())
                .fullName(request.getFullName())
                .email(request.getEmail())
                .phoneNumber(request.getPhoneNumber())
                .role(request.getRole())
                .employeeCode(request.getEmployeeCode())
                .discountLimit(request.getDiscountLimit())
                .creditTransactionLimit(request.getCreditTransactionLimit())
                .isActive(true)
                .build();
    }

    public void updateEntityFromRequest(UpdateUserRequest request, User user) {
        if (request == null || user == null) {
            return;
        }

        if (request.getFullName() != null) {
            user.setFullName(request.getFullName());
        }
        if (request.getEmail() != null) {
            user.setEmail(request.getEmail());
        }
        if (request.getPhoneNumber() != null) {
            user.setPhoneNumber(request.getPhoneNumber());
        }
        if (request.getRole() != null) {
            user.setRole(request.getRole());
        }
        if (request.getIsActive() != null) {
            user.setIsActive(request.getIsActive());
        }
        if (request.getDiscountLimit() != null) {
            user.setDiscountLimit(request.getDiscountLimit());
        }
        if (request.getCreditTransactionLimit() != null) {
            user.setCreditTransactionLimit(request.getCreditTransactionLimit());
        }
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\audit\AuditLog.java"   & echo.. 
package com.pharmacy.medlan.model.audit;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "audit_logs", indexes = {
        @Index(name = "idx_audit_timestamp", columnList = "timestamp"),
        @Index(name = "idx_audit_user", columnList = "user_id"),
        @Index(name = "idx_audit_entity", columnList = "entity_type, entity_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AuditLog extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "timestamp", nullable = false)
    private LocalDateTime timestamp;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @Column(name = "username", length = 100)
    private String username;

    @Column(name = "action", nullable = false, length = 100)
    private String action; // CREATE, UPDATE, DELETE, LOGIN, LOGOUT

    @Column(name = "entity_type", nullable = false, length = 100)
    private String entityType; // Product, Sale, GRN, etc.

    @Column(name = "entity_id")
    private Long entityId;

    @Column(name = "old_value", columnDefinition = "TEXT")
    private String oldValue;

    @Column(name = "new_value", columnDefinition = "TEXT")
    private String newValue;

    @Column(name = "ip_address", length = 50)
    private String ipAddress;

    @Column(name = "user_agent", columnDefinition = "TEXT")
    private String userAgent;

    @Column(name = "description", length = 500)
    private String description;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\audit\SyncLog.java"   & echo.. 
package com.pharmacy.medlan.model.audit;

import com.pharmacy.medlan.enums.SyncStatus;
import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.organization.Branch;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "sync_logs")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SyncLog extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "sync_type", nullable = false, length = 100)
    private String syncType; // PRODUCT, INVENTORY, SALES, etc.

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id")
    private Branch branch;

    @Column(name = "started_at", nullable = false)
    private LocalDateTime startedAt;

    @Column(name = "completed_at")
    private LocalDateTime completedAt;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private SyncStatus status = SyncStatus.PENDING;

    @Column(name = "records_processed")
    private Integer recordsProcessed = 0;

    @Column(name = "records_failed")
    private Integer recordsFailed = 0;

    @Column(name = "error_message", columnDefinition = "TEXT")
    private String errorMessage;

    @Column(name = "details", columnDefinition = "TEXT")
    private String details;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\base\AuditableEntity.java"   & echo.. 
package com.pharmacy.medlan.model.base;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
import java.time.LocalDateTime;

@Getter
@Setter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class AuditableEntity extends BaseEntity {

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @CreatedBy
    @Column(name = "created_by", nullable = false, updatable = false, length = 100)
    private String createdBy;

    @LastModifiedBy
    @Column(name = "last_modified_by", nullable = false, length = 100)
    private String lastModifiedBy;

    @Column(name = "deleted", nullable = false)
    private Boolean deleted = false; // Soft delete flag

    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;

    @Column(name = "deleted_by", length = 100)
    private String deletedBy;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\base\BaseEntity.java"   & echo.. 
package com.pharmacy.medlan.model.base;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import java.io.Serializable;

@Getter
@Setter
@MappedSuperclass
public abstract class BaseEntity implements Serializable {

    @Version
    @Column(name = "version")
    private Long version; // Optimistic locking
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\finance\Bank.java"   & echo.. 
package com.pharmacy.medlan.model.finance;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "banks")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Bank extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "bank_name", nullable = false, length = 200)
    private String bankName;

    @Column(name = "account_number", nullable = false, unique = true, length = 50)
    private String accountNumber;

    @Column(name = "ifsc_code", length = 50)
    private String ifscCode;

    @Column(name = "branch_name", length = 200)
    private String branchName;

    @Column(name = "account_holder_name", length = 200)
    private String accountHolderName;

    @Column(name = "account_type", length = 50)
    private String accountType; // SAVINGS, CURRENT

    @Column(name = "current_balance", nullable = false, precision = 15, scale = 2)
    private BigDecimal currentBalance = BigDecimal.ZERO;

    @Column(name = "opening_balance", precision = 15, scale = 2)
    private BigDecimal openingBalance = BigDecimal.ZERO;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @OneToMany(mappedBy = "bank", cascade = CascadeType.ALL)
    @Builder.Default
    private List<BankData> transactions = new ArrayList<>();
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\finance\BankData.java"   & echo.. 
package com.pharmacy.medlan.model.finance;

import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "bank_data")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BankData extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bank_id", nullable = false)
    private Bank bank;

    @Column(name = "bank_name", length = 200)
    private String bankName;

    @Column(name = "credit_amount", precision = 12, scale = 2)
    private BigDecimal creditAmount = BigDecimal.ZERO;

    @Column(name = "debit_amount", precision = 12, scale = 2)
    private BigDecimal debitAmount = BigDecimal.ZERO;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @Column(name = "cheque_number", length = 100)
    private String chequeNumber;

    @Column(name = "transaction_date")
    private LocalDate transactionDate;

    @Column(name = "actual_date")
    private LocalDate actualDate;

    @Column(name = "description", length = 500)
    private String description;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\finance\CashBook.java"   & echo.. 
package com.pharmacy.medlan.model.finance;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "cash_book", indexes = {
        @Index(name = "idx_cashbook_date", columnList = "transaction_date"),
        @Index(name = "idx_cashbook_branch", columnList = "branch_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CashBook extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "transaction_date", nullable = false)
    private LocalDate transactionDate;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "transaction_type_id")
    private TransactionType transactionType;

    @Column(name = "description", nullable = false, length = 500)
    private String description;

    @Column(name = "debit_amount", precision = 12, scale = 2)
    private BigDecimal debitAmount = BigDecimal.ZERO;

    @Column(name = "credit_amount", precision = 12, scale = 2)
    private BigDecimal creditAmount = BigDecimal.ZERO;

    @Column(name = "running_balance", nullable = false, precision = 12, scale = 2)
    private BigDecimal runningBalance;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @Column(name = "reference_number", length = 100)
    private String referenceNumber;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", length = 50)
    private PaymentMethod paymentMethod;

    @Column(name = "category", length = 100)
    private String category;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\finance\IncomingCheque.java"   & echo.. 
package com.pharmacy.medlan.model.finance;

import com.pharmacy.medlan.enums.ChequeStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.pos.Customer;
import com.pharmacy.medlan.model.supplier.Supplier;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "incoming_cheques", indexes = {
        @Index(name = "idx_cheque_number", columnList = "cheque_number"),
        @Index(name = "idx_cheque_status", columnList = "status")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IncomingCheque extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "cheque_number", nullable = false, unique = true, length = 100)
    private String chequeNumber;

    @Column(name = "amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal amount;

    @Column(name = "cheque_date", nullable = false)
    private LocalDate chequeDate;

    @Column(name = "deposit_date", nullable = false)
    private LocalDate depositDate;

    @Column(name = "clearance_date")
    private LocalDate clearanceDate;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "bank_id", nullable = false)
    private Bank bank;

    @Column(name = "bank_name", length = 200)
    private String bankName;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id")
    private Customer customer;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id")
    private Supplier supplier;

    @Column(name = "received_from", length = 200)
    private String receivedFrom;

    @Column(name = "company", length = 200)
    private String company;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private ChequeStatus status = ChequeStatus.PENDING;

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\finance\TransactionType.java"   & echo.. 
package com.pharmacy.medlan.model.finance;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "transaction_types")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TransactionType extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "type_name", nullable = false, unique = true, length = 100)
    private String typeName;

    @Column(name = "description", nullable = false, length = 500)
    private String description;

    @Column(name = "is_income", nullable = false)
    private Boolean isIncome; // true = Income, false = Expense

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\ExpiryData.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "expiry_data")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExpiryData extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id")
    private Product product;

    @Column(name = "product_code", length = 50)
    private String productCode;

    @Column(name = "product_name", length = 200)
    private String productName;

    @Column(name = "quantity")
    private Integer quantity;

    @Column(name = "batch_price", precision = 10, scale = 2)
    private BigDecimal batchPrice;

    @Column(name = "expiry_date")
    private LocalDate expiryDate;

    @Column(name = "found_date")
    private LocalDate foundDate;

    @Column(name = "company", length = 200)
    private String company;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\GRN.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.enums.GRNStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.supplier.PurchaseOrder;
import com.pharmacy.medlan.model.supplier.Supplier;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "grns", indexes = {
        @Index(name = "idx_grn_number", columnList = "grn_number"),
        @Index(name = "idx_grn_status", columnList = "status"),
        @Index(name = "idx_grn_date", columnList = "received_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GRN extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "grn_number", nullable = false, unique = true, length = 50)
    private String grnNumber; // GRN-2024-00001

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "purchase_order_id")
    private PurchaseOrder purchaseOrder;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "received_date", nullable = false)
    private LocalDate receivedDate;

    @Column(name = "supplier_invoice_number", length = 100)
    private String supplierInvoiceNumber;

    @Column(name = "supplier_invoice_date")
    private LocalDate supplierInvoiceDate;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "discount_amount", precision = 10, scale = 2)
    private BigDecimal discountAmount = BigDecimal.ZERO;

    @Column(name = "tax_amount", precision = 10, scale = 2)
    private BigDecimal taxAmount = BigDecimal.ZERO;

    @Column(name = "net_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal netAmount;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private GRNStatus status = GRNStatus.DRAFT;

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "received_by_user_id")
    private User receivedBy;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "approved_by_user_id")
    private User approvedBy;

    @Column(name = "approved_at")
    private LocalDateTime approvedAt;

    @OneToMany(mappedBy = "grn", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<GRNLine> grnLines = new ArrayList<>();

    // Payment tracking
    @Column(name = "paid_amount", precision = 12, scale = 2)
    private BigDecimal paidAmount = BigDecimal.ZERO;

    @Column(name = "balance_amount", precision = 12, scale = 2)
    private BigDecimal balanceAmount = BigDecimal.ZERO;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", length = 50)
    private PaymentStatus paymentStatus = PaymentStatus.UNPAID;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\GRNLine.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "grn_lines")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GRNLine extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "grn_id", nullable = false)
    private GRN grn;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(name = "batch_number", nullable = false, length = 100)
    private String batchNumber;

    @Column(name = "manufacturing_date")
    private LocalDate manufacturingDate;

    @Column(name = "expiry_date", nullable = false)
    private LocalDate expiryDate;

    @Column(name = "quantity_ordered")
    private Integer quantityOrdered;

    @Column(name = "quantity_received", nullable = false)
    private Integer quantityReceived;

    @Column(name = "free_quantity", nullable = false)
    private Integer freeQuantity = 0; // Free items from supplier

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "discount_percent", precision = 5, scale = 2)
    private BigDecimal discountPercent = BigDecimal.ZERO;

    @Column(name = "discount_amount", precision = 10, scale = 2)
    private BigDecimal discountAmount = BigDecimal.ZERO;

    @Column(name = "gst_rate", nullable = false, precision = 5, scale = 2)
    private BigDecimal gstRate;

    @Column(name = "gst_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal gstAmount;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "mrp", precision = 10, scale = 2)
    private BigDecimal mrp; // Maximum Retail Price

    @Column(name = "selling_price", precision = 10, scale = 2)
    private BigDecimal sellingPrice;

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\GRNTemp.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "grn_temp")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GRNTemp extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(name = "product_name", length = 200)
    private String productName;

    @Column(name = "batch_number", length = 100)
    private String batchNumber;

    @Column(name = "expiry_date")
    private LocalDate expiryDate;

    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    @Column(name = "unit_price", precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "user_id", nullable = false)
    private Long userId;

    @Column(name = "grn_number", length = 50)
    private String grnNumber;

    @Column(name = "status")
    private Integer status = 0; // 0 = Pending, 1 = Processed
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\InventoryTransaction.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.enums.TransactionType;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "inventory_transactions")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class InventoryTransaction extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "transaction_number", nullable = false, unique = true, length = 50)
    private String transactionNumber;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Enumerated(EnumType.STRING)
    @Column(name = "transaction_type", nullable = false, length = 50)
    private TransactionType transactionType;

    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    @Column(name = "transaction_date", nullable = false)
    private LocalDateTime transactionDate;

    @Column(name = "reason", columnDefinition = "TEXT")
    private String reason;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "approved_by_user_id")
    private User approvedBy;

    @Column(name = "is_approved", nullable = false)
    private Boolean isApproved = false;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\ProductBinCard.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.enums.TransactionType;
import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "product_bin_cards", indexes = {
        @Index(name = "idx_bincard_product", columnList = "product_id"),
        @Index(name = "idx_bincard_branch", columnList = "branch_id"),
        @Index(name = "idx_bincard_date", columnList = "transaction_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductBinCard extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "transaction_date", nullable = false)
    private LocalDateTime transactionDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "transaction_type", nullable = false, length = 50)
    private TransactionType transactionType;

    @Column(name = "reference_id")
    private Long referenceId; // GRN ID, Sale ID, Transfer ID, etc.

    @Column(name = "reference_number", length = 100)
    private String referenceNumber;

    @Column(name = "quantity_in", nullable = false)
    private Integer quantityIn = 0;

    @Column(name = "quantity_out", nullable = false)
    private Integer quantityOut = 0;

    @Column(name = "running_balance", nullable = false)
    private Integer runningBalance;

    @Column(name = "description", length = 500)
    private String description;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\RGRN.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.supplier.Supplier;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "rgrns")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RGRN extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "rgrn_number", nullable = false, unique = true, length = 50)
    private String rgrnNumber; // RGRN-2024-00001

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "original_grn_id")
    private GRN originalGrn;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "return_date", nullable = false)
    private LocalDate returnDate;

    @Column(name = "total_return_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalReturnAmount;

    @Enumerated(EnumType.STRING)
    @Column(name = "refund_status", nullable = false, length = 50)
    private PaymentStatus refundStatus = PaymentStatus.PENDING;

    @Column(name = "return_reason", columnDefinition = "TEXT")
    private String returnReason;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "returned_by_user_id")
    private User returnedBy;

    @OneToMany(mappedBy = "rgrn", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<RGRNLine> rgrnLines = new ArrayList<>();

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\RGRNLine.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "rgrn_lines")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RGRNLine extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "rgrn_id", nullable = false)
    private RGRN rgrn;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inventory_batch_id")
    private InventoryBatch inventoryBatch;

    @Column(name = "product_name", length = 200)
    private String productName;

    @Column(name = "batch_number", length = 100)
    private String batchNumber;

    @Column(name = "quantity_returned", nullable = false)
    private Integer quantityReturned;

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_amount", nullable = false, precision = 12,scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "return_reason", length = 500)
    private String returnReason;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\StockTransfer.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.enums.StockTransferStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "stock_transfers")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class StockTransfer extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "transfer_number", nullable = false, unique = true, length = 50)
    private String transferNumber; // ST-2024-00001

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "from_branch_id", nullable = false)
    private Branch fromBranch;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "to_branch_id", nullable = false)
    private Branch toBranch;

    @Column(name = "transfer_date", nullable = false)
    private LocalDate transferDate;

    @Column(name = "expected_receipt_date")
    private LocalDate expectedReceiptDate;

    @Column(name = "actual_receipt_date")
    private LocalDate actualReceiptDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private StockTransferStatus status = StockTransferStatus.PENDING;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "initiated_by_user_id")
    private User initiatedBy;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "approved_by_user_id")
    private User approvedBy;

    @Column(name = "approved_at")
    private LocalDateTime approvedAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "received_by_user_id")
    private User receivedBy;

    @OneToMany(mappedBy = "stockTransfer", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<StockTransferItem> items = new ArrayList<>();

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\inventory\StockTransferItem.java"   & echo.. 
package com.pharmacy.medlan.model.inventory;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "stock_transfer_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class StockTransferItem extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "stock_transfer_id", nullable = false)
    private StockTransfer stockTransfer;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inventory_batch_id")
    private InventoryBatch inventoryBatch;

    @Column(name = "quantity_transferred", nullable = false)
    private Integer quantityTransferred;

    @Column(name = "quantity_received")
    private Integer quantityReceived;

    @Column(name = "remarks", length = 500)
    private String remarks;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\notification\Notification.java"   & echo.. 
package com.pharmacy.medlan.model.notification;

import com.pharmacy.medlan.enums.NotificationType;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "notifications", indexes = {
        @Index(name = "idx_notification_user", columnList = "user_id"),
        @Index(name = "idx_notification_read", columnList = "is_read"),
        @Index(name = "idx_notification_created", columnList = "created_at")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Notification extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user; // null = broadcast to all

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 50)
    private NotificationType type;

    @Column(name = "title", nullable = false, length = 200)
    private String title;

    @Column(name = "message", nullable = false, columnDefinition = "TEXT")
    private String message;

    @Column(name = "reference_id")
    private Long referenceId; // Related entity ID

    @Column(name = "reference_type", length = 100)
    private String referenceType; // Entity type

    @Column(name = "is_read", nullable = false)
    private Boolean isRead = false;

    @Column(name = "read_at")
    private LocalDateTime readAt;

    @Column(name = "priority", length = 20)
    private String priority = "NORMAL"; // LOW, NORMAL, HIGH, URGENT

    @Column(name = "action_url", length = 500)
    private String actionUrl;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\organization\Branch.java"   & echo.. 
package com.pharmacy.medlan.model.organization;

import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.user.BranchStaff;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "branches")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Branch extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "branch_code", nullable = false, unique = true, length = 50)
    private String branchCode;

    @Column(name = "branch_name", nullable = false, length = 200)
    private String branchName;

    @Column(name = "address", columnDefinition = "TEXT")
    private String address;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "state", length = 100)
    private String state;

    @Column(name = "pincode", length = 20)
    private String pincode;

    @Column(name = "phone_number", length = 50)
    private String phoneNumber;

    @Column(name = "email", length = 100)
    private String email;

    @Column(name = "gstin_number", length = 50)
    private String gstinNumber;

    @Column(name = "drug_license_number", length = 50)
    private String drugLicenseNumber;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id")
    private User manager;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "is_main_branch", nullable = false)
    private Boolean isMainBranch = false;

    @OneToMany(mappedBy = "branch", cascade = CascadeType.ALL)
    @Builder.Default
    private List<BranchStaff> staff = new ArrayList<>();

    @OneToMany(mappedBy = "branch", cascade = CascadeType.ALL)
    @Builder.Default
    private List<BranchInventory> inventory = new ArrayList<>();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\payroll\Employee.java"   & echo.. 
package com.pharmacy.medlan.model.payroll;

import com.pharmacy.medlan.enums.EmploymentType;
import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "employees")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Employee extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "employee_code", nullable = false, unique = true, length = 50)
    private String employeeCode;

    @Column(name = "full_name", nullable = false, length = 200)
    private String fullName;

    @Column(name = "designation", length = 100)
    private String designation;

    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", length = 50)
    private EmploymentType employmentType;

    @Column(name = "basic_salary", precision = 10, scale = 2)
    private BigDecimal basicSalary;

    @Column(name = "allowances", precision = 10, scale = 2)
    private BigDecimal allowances = BigDecimal.ZERO;

    @Column(name = "joining_date")
    private LocalDate joiningDate;

    @Column(name = "leaving_date")
    private LocalDate leavingDate;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL)
    @Builder.Default
    private List<EmployeePayment> payments = new ArrayList<>();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\payroll\EmployeePayment.java"   & echo.. 
package com.pharmacy.medlan.model.payroll;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "employee_payments")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmployeePayment extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "employee_id", nullable = false)
    private Employee employee;

    @Column(name = "payment_date", nullable = false)
    private LocalDate paymentDate;

    @Column(name = "worker_name", length = 200)
    private String workerName;

    @Column(name = "amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    @Column(name = "reason", length = 500)
    private String reason;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", length = 50)
    private PaymentMethod paymentMethod;

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\Customer.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.enums.CustomerStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "customers", indexes = {
        @Index(name = "idx_customer_code", columnList = "customer_code"),
        @Index(name = "idx_customer_phone", columnList = "phone_number")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Customer extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "customer_code", nullable = false, unique = true, length = 50)
    private String customerCode; // CUST-00001

    @Column(name = "customer_name", nullable = false, length = 200)
    private String customerName;

    @Column(name = "phone_number", length = 50)
    private String phoneNumber;

    @Column(name = "email", length = 100)
    private String email;

    @Column(name = "gender", length = 20)
    private String gender;

    @Column(name = "date_of_birth")
    private LocalDate dateOfBirth;

    @Column(name = "address", columnDefinition = "TEXT")
    private String address;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "state", length = 100)
    private String state;

    @Column(name = "pincode", length = 20)
    private String pincode;

    @Column(name = "fax", length = 50)
    private String fax;

    @Column(name = "credit_limit", precision = 12, scale = 2)
    private BigDecimal creditLimit = BigDecimal.ZERO;

    @Column(name = "current_balance", precision = 12, scale = 2)
    private BigDecimal currentBalance = BigDecimal.ZERO;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private CustomerStatus status = CustomerStatus.ACTIVE;

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "medical_history", columnDefinition = "TEXT")
    private String medicalHistory;

    @Column(name = "allergies", columnDefinition = "TEXT")
    private String allergies;

    @Column(name = "insurance_provider", length = 100)
    private String insuranceProvider;

    @Column(name = "insurance_policy_number", length = 100)
    private String insurancePolicyNumber;

    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL)
    @Builder.Default
    private List<CustomerPrescription> prescriptions = new ArrayList<>();

    @OneToMany(mappedBy = "customer")
    @Builder.Default
    private List<Sale> sales = new ArrayList<>();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\CustomerData.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.BaseEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "customer_data")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CustomerData extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id")
    private Customer customer;

    @Column(name = "customer_name", length = 200)
    private String customerName;

    @Column(name = "credit_amount", precision = 12, scale = 2)
    private BigDecimal creditAmount;

    @Column(name = "paid_amount", precision = 12, scale = 2)
    private BigDecimal paidAmount;

    @Column(name = "balance", precision = 12, scale = 2)
    private BigDecimal balance;

    @Column(name = "transaction_date")
    private LocalDate transactionDate;

    @Column(name = "cheque_number", length = 100)
    private String chequeNumber;

    @Column(name = "user_id")
    private Long userId;

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "reference", length = 100)
    private String reference;

    @Column(name = "invoice_number")
    private Integer invoiceNumber;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\CustomerPrescription.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "customer_prescriptions")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CustomerPrescription extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id", nullable = false)
    private Customer customer;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id")
    private Product product;

    @Column(name = "product_name", length = 200)
    private String productName;

    @Column(name = "direction", length = 500)
    private String direction;

    @Column(name = "duration", length = 100)
    private String duration;

    @Column(name = "dosage", length = 100)
    private String dosage;

    @Column(name = "frequency", length = 200)
    private String frequency;

    @Column(name = "quantity_prescribed")
    private Integer quantityPrescribed;

    @Column(name = "instructions", columnDefinition = "TEXT")
    private String instructions;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\Invoice.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.enums.InvoiceStatus;
import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "invoices", indexes = {
        @Index(name = "idx_invoice_number", columnList = "invoice_number"),
        @Index(name = "idx_invoice_date", columnList = "invoice_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Invoice extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "invoice_number", nullable = false, unique = true, length = 50)
    private String invoiceNumber; // INV-2024-00001

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id")
    private Customer customer;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "invoice_date", nullable = false)
    private LocalDate invoiceDate;

    @Column(name = "due_date")
    private LocalDate dueDate;

    @Column(name = "subtotal", precision = 12, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "discount", precision = 10, scale = 2)
    private BigDecimal discount = BigDecimal.ZERO;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "paid_amount", precision = 12, scale = 2)
    private BigDecimal paidAmount = BigDecimal.ZERO;

    @Column(name = "balance_amount", precision = 12, scale = 2)
    private BigDecimal balanceAmount = BigDecimal.ZERO;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private InvoiceStatus status = InvoiceStatus.DRAFT;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_status", nullable = false, length = 50)
    private PaymentStatus paymentStatus = PaymentStatus.UNPAID;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_type", length = 50)
    private PaymentMethod paymentType;

    @Column(name = "cheque_number", length = 100)
    private String chequeNumber;

    @Column(name = "cheque_date")
    private LocalDate chequeDate;

    @Column(name = "card_details", length = 100)
    private String cardDetails;

    @Column(name = "doctor_name", length = 200)
    private String doctorName;

    @Column(name = "patient_number", length = 100)
    private String patientNumber;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @Column(name = "cashier_user_id")
    private Integer cashierUserId;

    @Column(name = "timestamp")
    private LocalDateTime timestamp;

    @OneToOne(mappedBy = "invoice", cascade = CascadeType.ALL)
    private Sale sale;

    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\InvoiceData.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "invoice_data")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class InvoiceData extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "invoice_id", nullable = false)
    private Invoice invoice;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id")
    private Product product;

    @Column(name = "product_name", length = 200)
    private String productName;

    @Column(name = "quantity")
    private Integer quantity;

    @Column(name = "selling_price", precision = 10, scale = 2)
    private BigDecimal sellingPrice;

    @Column(name = "profit", precision = 10, scale = 2)
    private BigDecimal profit;

    @Column(name = "stock_number")
    private Integer stockNumber;

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "date")
    private LocalDate date;

    @Column(name = "user_id")
    private Integer userId;

    @Column(name = "cashier_user_id")
    private Integer cashierUserId;

    @Column(name = "customer_id")
    private Integer customerId;

    @Column(name = "category", length = 100)
    private String category;

    @Column(name = "sub_category", length = 100)
    private String subCategory;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\InvoiceReturn.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;

@Entity
@Table(name = "invoice_returns")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class InvoiceReturn extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "invoice_id")
    private Invoice invoice;

    @Column(name = "return_date")
    private LocalDate returnDate;

    @Column(name = "return_amount")
    private Integer returnAmount;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\PatientNumber.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.BaseEntity;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;

@Entity
@Table(name = "patient_numbers")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PatientNumber extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "patient_number")
    private Integer patientNumber;

    @Column(name = "today")
    private LocalDate today;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\Payment.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "payments")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Payment extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "invoice_id")
    private Invoice invoice;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sale_id")
    private Sale sale;

    @Column(name = "payment_date", nullable = false)
    private LocalDate paymentDate;

    @Column(name = "amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal amount;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", nullable = false, length = 50)
    private PaymentMethod paymentMethod;

    @Column(name = "reference_number", length = 100)
    private String referenceNumber;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private PaymentStatus status = PaymentStatus.PAID;

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\ReturnInvoiceData.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.BaseEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "return_invoice_data")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ReturnInvoiceData extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "invoice_number")
    private Integer invoiceNumber;

    @Column(name = "product_code")
    private Integer productCode;

    @Column(name = "return_quantity")
    private Integer returnQuantity;

    @Column(name = "selling_price", precision = 10, scale = 2)
    private BigDecimal sellingPrice;

    @Column(name = "stock_number")
    private Integer stockNumber;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\Sale.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.SaleStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "sales", indexes = {
        @Index(name = "idx_sale_number", columnList = "sale_number"),
        @Index(name = "idx_sale_date", columnList = "sale_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Sale extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "sale_number", nullable = false, unique = true, length = 50)
    private String saleNumber; // SALE-2024-00001

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "invoice_id", nullable = false)
    private Invoice invoice;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id")
    private Customer customer;

    @Column(name = "sale_date", nullable = false)
    private LocalDateTime saleDate;

    @Column(name = "subtotal", nullable = false, precision = 12, scale = 2)
    private BigDecimal subtotal;

    @Column(name = "discount_amount", precision = 10, scale = 2)
    private BigDecimal discountAmount = BigDecimal.ZERO;

    @Column(name = "discount_percent", precision = 5, scale = 2)
    private BigDecimal discountPercent = BigDecimal.ZERO;

    @Column(name = "tax_amount", precision = 10, scale = 2)
    private BigDecimal taxAmount = BigDecimal.ZERO;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "paid_amount", precision = 12, scale = 2)
    private BigDecimal paidAmount = BigDecimal.ZERO;

    @Column(name = "change_amount", precision = 12, scale = 2)
    private BigDecimal changeAmount = BigDecimal.ZERO;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", nullable = false, length = 50)
    private PaymentMethod paymentMethod = PaymentMethod.CASH;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private SaleStatus status = SaleStatus.COMPLETED;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sold_by_user_id")
    private User soldBy;

    @OneToMany(mappedBy = "sale", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<SaleItem> saleItems = new ArrayList<>();

    @Column(name = "patient_name", length = 200)
    private String patientName;

    @Column(name = "doctor_name", length = 200)
    private String doctorName;

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\SaleItem.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "sale_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SaleItem extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sale_id", nullable = false)
    private Sale sale;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inventory_batch_id")
    private InventoryBatch inventoryBatch;

    @Column(name = "product_name", length = 200)
    private String productName;

    @Column(name = "batch_number", length = 100)
    private String batchNumber;

    @Column(name = "quantity", nullable = false)
    private Integer quantity;

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "discount_amount", precision = 10, scale = 2)
    private BigDecimal discountAmount = BigDecimal.ZERO;

    @Column(name = "tax_amount", precision = 10, scale = 2)
    private BigDecimal taxAmount = BigDecimal.ZERO;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    @Column(name = "profit", precision = 10, scale = 2)
    private BigDecimal profit;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\SaleReturn.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "sale_returns")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SaleReturn extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "return_number", nullable = false, unique = true, length = 50)
    private String returnNumber; // SR-2024-00001

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "original_sale_id")
    private Sale originalSale;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id")
    private Customer customer;

    @Column(name = "return_date", nullable = false)
    private LocalDate returnDate;

    @Column(name = "total_return_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalReturnAmount;

    @Column(name = "refund_amount", precision = 12, scale = 2)
    private BigDecimal refundAmount;

    @Column(name = "return_reason", columnDefinition = "TEXT")
    private String returnReason;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "processed_by_user_id")
    private User processedBy;

    @OneToMany(mappedBy = "saleReturn", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<SaleReturnItem> returnItems = new ArrayList<>();

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\pos\SaleReturnItem.java"   & echo.. 
package com.pharmacy.medlan.model.pos;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "sale_return_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SaleReturnItem extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sale_return_id", nullable = false)
    private SaleReturn saleReturn;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sale_item_id")
    private SaleItem originalSaleItem;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inventory_batch_id")
    private InventoryBatch inventoryBatch;

    @Column(name = "quantity_returned", nullable = false)
    private Integer quantityReturned;

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "return_reason", length = 500)
    private String returnReason;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\product\BranchInventory.java"   & echo.. 
package com.pharmacy.medlan.model.product;

import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "branch_inventory",
        uniqueConstraints = @UniqueConstraint(columnNames = {"product_id", "branch_id"}),
        indexes = {
                @Index(name = "idx_branch_inv_product", columnList = "product_id"),
                @Index(name = "idx_branch_inv_branch", columnList = "branch_id")
        })
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BranchInventory extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "quantity_on_hand", nullable = false)
    private Integer quantityOnHand = 0;

    @Column(name = "quantity_allocated", nullable = false)
    private Integer quantityAllocated = 0; // Reserved for pending orders

    @Column(name = "quantity_available", nullable = false)
    private Integer quantityAvailable = 0; // On hand - Allocated

    @Column(name = "reorder_level")
    private Integer reorderLevel;

    @Column(name = "minimum_stock")
    private Integer minimumStock;

    @Column(name = "maximum_stock")
    private Integer maximumStock;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\product\Category.java"   & echo.. 
package com.pharmacy.medlan.model.product;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "categories")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Category extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "category_name", nullable = false, unique = true, length = 100)
    private String categoryName;

    @Column(name = "category_code", unique = true, length = 50)
    private String categoryCode;

    @Column(name = "description", columnDefinition = "TEXT")
    private String description;

    @Column(name = "min_code")
    private Integer minCode; // For product code range

    @Column(name = "max_code")
    private Integer maxCode; // For product code range

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @OneToMany(mappedBy = "category", cascade = CascadeType.ALL)
    @Builder.Default
    private List<SubCategory> subCategories = new ArrayList<>();

    @OneToMany(mappedBy = "category")
    @Builder.Default
    private List<Product> products = new ArrayList<>();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\product\InventoryBatch.java"   & echo.. 
package com.pharmacy.medlan.model.product;

import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.inventory.GRNLine;
import com.pharmacy.medlan.model.organization.Branch;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "inventory_batches", indexes = {
        @Index(name = "idx_batch_expiry", columnList = "expiry_date"),
        @Index(name = "idx_batch_product", columnList = "product_id"),
        @Index(name = "idx_batch_branch", columnList = "branch_id"),
        @Index(name = "idx_batch_active", columnList = "is_active")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class InventoryBatch extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "batch_number", nullable = false, length = 100)
    private String batchNumber;

    @Column(name = "manufacturing_date", nullable = false)
    private LocalDate manufacturingDate;

    @Column(name = "expiry_date", nullable = false)
    private LocalDate expiryDate;

    @Column(name = "quantity_received", nullable = false)
    private Integer quantityReceived;

    @Column(name = "quantity_available", nullable = false)
    private Integer quantityAvailable;

    @Column(name = "quantity_sold", nullable = false)
    private Integer quantitySold = 0;

    @Column(name = "quantity_damaged", nullable = false)
    private Integer quantityDamaged = 0;

    @Column(name = "quantity_returned", nullable = false)
    private Integer quantityReturned = 0;

    @Column(name = "purchase_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal purchasePrice;

    @Column(name = "mrp", nullable = false, precision = 10, scale = 2)
    private BigDecimal mrp; // Maximum Retail Price

    @Column(name = "selling_price", precision = 10, scale = 2)
    private BigDecimal sellingPrice;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "grn_line_id")
    private GRNLine grnLine; // Link to GRN

    @Column(name = "is_expired", nullable = false)
    private Boolean isExpired = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "days_to_expiry_alert")
    private Integer daysToExpiryAlert = 90; // Alert 90 days before expiry

    @Column(name = "rack_location", length = 50)
    private String rackLocation; // Physical storage location
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\product\Product.java"   & echo.. 
package com.pharmacy.medlan.model.product;

import com.pharmacy.medlan.enums.DosageForm;
import com.pharmacy.medlan.enums.DrugSchedule;
import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "products", indexes = {
        @Index(name = "idx_product_code", columnList = "product_code"),
        @Index(name = "idx_product_name", columnList = "product_name"),
        @Index(name = "idx_barcode", columnList = "barcode"),
        @Index(name = "idx_is_active", columnList = "is_active")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Product extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "product_code", nullable = false, unique = true, length = 50)
    private String productCode; // e.g., "MED-00001"

    @Column(name = "product_name", nullable = false, length = 200)
    private String productName;

    @Column(name = "generic_name", length = 200)
    private String genericName; // Scientific/generic name

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sub_category_id")
    private SubCategory subCategory;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "unit_id")
    private Unit unit;

    @Enumerated(EnumType.STRING)
    @Column(name = "dosage_form", length = 50)
    private DosageForm dosageForm; // TABLET, CAPSULE, SYRUP, etc.

    @Column(name = "strength", length = 100)
    private String strength; // e.g., "500mg", "10ml"

    @Enumerated(EnumType.STRING)
    @Column(name = "drug_schedule", length = 20)
    private DrugSchedule drugSchedule; // H, H1, G, X (Indian pharmacy regulation)

    @Column(name = "manufacturer", length = 200)
    private String manufacturer;

    @Column(name = "supplier", length = 200)
    private String supplier;

    @Column(name = "barcode", length = 200)
    private String barcode;

    @Column(name = "description", columnDefinition = "TEXT")
    private String description;

    // Pricing
    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice; // Last purchase price

    @Column(name = "selling_price", precision = 10, scale = 2)
    private BigDecimal sellingPrice;

    @Column(name = "mrp", precision = 10, scale = 2)
    private BigDecimal mrp; // Maximum Retail Price

    @Column(name = "profit_margin", precision = 5, scale = 2)
    private BigDecimal profitMargin = BigDecimal.valueOf(15.00); // Default 15%

    @Column(name = "gst_rate", precision = 5, scale = 2)
    private BigDecimal gstRate = BigDecimal.ZERO;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tax_category_id")
    private TaxCategory taxCategory;

    // Inventory thresholds
    @Column(name = "reorder_level", nullable = false)
    private Integer reorderLevel = 10;

    @Column(name = "minimum_stock", nullable = false)
    private Integer minimumStock = 5;

    @Column(name = "maximum_stock", nullable = false)
    private Integer maximumStock = 1000;

    // Flags
    @Column(name = "is_prescription_required", nullable = false)
    private Boolean isPrescriptionRequired = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "is_discontinued", nullable = false)
    private Boolean isDiscontinued = false;

    @Column(name = "is_narcotic", nullable = false)
    private Boolean isNarcotic = false; // Schedule X drugs

    @Column(name = "is_refrigerated", nullable = false)
    private Boolean isRefrigerated = false; // Cold storage required

    // Relationships
    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL)
    @Builder.Default
    private List<InventoryBatch> inventoryBatches = new ArrayList<>();

    @OneToMany(mappedBy = "product")
    @Builder.Default
    private List<BranchInventory> branchInventories = new ArrayList<>();

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL)
    @Builder.Default
    private List<ProductPricing> pricingHistory = new ArrayList<>();
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\product\ProductPricing.java"   & echo.. 
package com.pharmacy.medlan.model.product;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "product_pricing")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductPricing extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(name = "effective_date", nullable = false)
    private LocalDate effectiveDate;

    @Column(name = "cost_price", precision = 10, scale = 2)
    private BigDecimal costPrice;

    @Column(name = "selling_price", precision = 10, scale = 2)
    private BigDecimal sellingPrice;

    @Column(name = "mrp", precision = 10, scale = 2)
    private BigDecimal mrp;

    @Column(name = "profit_margin", precision = 5, scale = 2)
    private BigDecimal profitMargin;

    @Column(name = "is_current", nullable = false)
    private Boolean isCurrent = true;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\product\SubCategory.java"   & echo.. 
package com.pharmacy.medlan.model.product;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "sub_categories")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SubCategory extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "sub_category_name", nullable = false, length = 100)
    private String subCategoryName;

    @Column(name = "sub_category_code", unique = true, length = 50)
    private String subCategoryCode;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;

    @Column(name = "description", columnDefinition = "TEXT")
    private String description;

    @Column(name = "min_code")
    private Integer minCode;

    @Column(name = "max_code")
    private Integer maxCode;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @OneToMany(mappedBy = "subCategory")
    @Builder.Default
    private List<Product> products = new ArrayList<>();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\product\TaxCategory.java"   & echo.. 
package com.pharmacy.medlan.model.product;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "tax_categories")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TaxCategory extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "tax_name", nullable = false, unique = true, length = 100)
    private String taxName; // e.g., "GST 5%", "GST 12%"

    @Column(name = "tax_rate", nullable = false, precision = 5, scale = 2)
    private BigDecimal taxRate; // e.g., 5.00, 12.00, 18.00

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\product\Unit.java"   & echo.. 
package com.pharmacy.medlan.model.product;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "units")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Unit extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "unit_name", nullable = false, unique = true, length = 50)
    private String unitName; // e.g., "Tablet", "Bottle", "Box"

    @Column(name = "unit_code", unique = true, length = 20)
    private String unitCode; // e.g., "TAB", "BTL"

    @Column(name = "description", length = 200)
    private String description;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\report\DailySalesSummary.java"   & echo.. 
package com.pharmacy.medlan.model.report;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.organization.Branch;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "daily_sales_summaries", indexes = {
        @Index(name = "idx_summary_date", columnList = "summary_date"),
        @Index(name = "idx_summary_branch", columnList = "branch_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DailySalesSummary extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "summary_date", nullable = false)
    private LocalDate summaryDate;

    @Column(name = "total_sales_count", nullable = false)
    private Integer totalSalesCount = 0;

    @Column(name = "total_sales_amount", nullable = false, precision = 15, scale = 2)
    private BigDecimal totalSalesAmount = BigDecimal.ZERO;

    @Column(name = "total_cost", precision = 15, scale = 2)
    private BigDecimal totalCost = BigDecimal.ZERO;

    @Column(name = "total_profit", precision = 15, scale = 2)
    private BigDecimal totalProfit = BigDecimal.ZERO;

    @Column(name = "total_discount", precision = 12, scale = 2)
    private BigDecimal totalDiscount = BigDecimal.ZERO;

    @Column(name = "cash_sales", precision = 12, scale = 2)
    private BigDecimal cashSales = BigDecimal.ZERO;

    @Column(name = "card_sales", precision = 12, scale = 2)
    private BigDecimal cardSales = BigDecimal.ZERO;

    @Column(name = "credit_sales", precision = 12, scale = 2)
    private BigDecimal creditSales = BigDecimal.ZERO;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\report\ExpiryAlert.java"   & echo.. 
package com.pharmacy.medlan.model.report;

import com.pharmacy.medlan.enums.AlertLevel;
import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "expiry_alerts", indexes = {
        @Index(name = "idx_expiry_product", columnList = "product_id"),
        @Index(name = "idx_expiry_date", columnList = "expiry_date")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExpiryAlert extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "inventory_batch_id", nullable = false)
    private InventoryBatch inventoryBatch;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "batch_number", length = 100)
    private String batchNumber;

    @Column(name = "expiry_date", nullable = false)
    private LocalDate expiryDate;

    @Column(name = "days_to_expiry", nullable = false)
    private Integer daysToExpiry;

    @Column(name = "quantity_available", nullable = false)
    private Integer quantityAvailable;

    @Column(name = "batch_value", precision = 12, scale = 2)
    private BigDecimal batchValue;

    @Enumerated(EnumType.STRING)
    @Column(name = "alert_level", nullable = false, length = 50)
    private AlertLevel alertLevel; // WARNING, URGENT, EXPIRED

    @Column(name = "alert_generated_at", nullable = false)
    private LocalDateTime alertGeneratedAt;

    @Column(name = "is_acknowledged", nullable = false)
    private Boolean isAcknowledged = false;

    @Column(name = "acknowledged_at")
    private LocalDateTime acknowledgedAt;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\report\LowStockAlert.java"   & echo.. 
package com.pharmacy.medlan.model.report;

import com.pharmacy.medlan.enums.AlertLevel;
import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "low_stock_alerts", indexes = {
        @Index(name = "idx_lowstock_product", columnList = "product_id"),
        @Index(name = "idx_lowstock_branch", columnList = "branch_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LowStockAlert extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "current_stock", nullable = false)
    private Integer currentStock;

    @Column(name = "reorder_level", nullable = false)
    private Integer reorderLevel;

    @Enumerated(EnumType.STRING)
    @Column(name = "alert_level", nullable = false, length = 50)
    private AlertLevel alertLevel; // LOW, CRITICAL, OUT_OF_STOCK

    @Column(name = "alert_generated_at", nullable = false)
    private LocalDateTime alertGeneratedAt;

    @Column(name = "is_acknowledged", nullable = false)
    private Boolean isAcknowledged = false;

    @Column(name = "acknowledged_at")
    private LocalDateTime acknowledgedAt;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\supplier\GoodsReceipt.java"   & echo.. 
package com.pharmacy.medlan.model.supplier;

import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "goods_receipts")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GoodsReceipt extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "receipt_number", nullable = false, unique = true, length = 50)
    private String receiptNumber; // GR-2024-00001

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "purchase_order_id")
    private PurchaseOrder purchaseOrder;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "receipt_date", nullable = false)
    private LocalDate receiptDate;

    @Column(name = "supplier_invoice_number", length = 100)
    private String supplierInvoiceNumber;

    @Column(name = "supplier_invoice_date")
    private LocalDate supplierInvoiceDate;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "received_by_user_id")
    private User receivedByUser;

    @OneToMany(mappedBy = "goodsReceipt", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<GoodsReceiptItem> items = new ArrayList<>();

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\supplier\GoodsReceiptItem.java"   & echo.. 
package com.pharmacy.medlan.model.supplier;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;

@Entity
@Table(name = "goods_receipt_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class GoodsReceiptItem extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "goods_receipt_id", nullable = false)
    private GoodsReceipt goodsReceipt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(name = "batch_number", nullable = false, length = 100)
    private String batchNumber;

    @Column(name = "expiry_date", nullable = false)
    private LocalDate expiryDate;

    @Column(name = "quantity_received", nullable = false)
    private Integer quantityReceived;

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\supplier\PurchaseOrder.java"   & echo.. 
package com.pharmacy.medlan.model.supplier;

import com.pharmacy.medlan.enums.PurchaseOrderStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "purchase_orders", indexes = {
        @Index(name = "idx_po_number", columnList = "po_number"),
        @Index(name = "idx_po_status", columnList = "status")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PurchaseOrder extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "po_number", nullable = false, unique = true, length = 50)
    private String poNumber; // PO-2024-00001

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "order_date", nullable = false)
    private LocalDate orderDate;

    @Column(name = "expected_delivery_date")
    private LocalDate expectedDeliveryDate;

    @Column(name = "actual_delivery_date")
    private LocalDate actualDeliveryDate;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "discount_amount", precision = 10, scale = 2)
    private BigDecimal discountAmount = BigDecimal.ZERO;

    @Column(name = "tax_amount", precision = 10, scale = 2)
    private BigDecimal taxAmount = BigDecimal.ZERO;

    @Column(name = "net_amount", precision = 12, scale = 2)
    private BigDecimal netAmount;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private PurchaseOrderStatus status = PurchaseOrderStatus.DRAFT;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "created_by_user_id")
    private User createdByUser;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "approved_by_user_id")
    private User approvedByUser;

    @Column(name = "approved_at")
    private LocalDateTime approvedAt;

    @OneToMany(mappedBy = "purchaseOrder", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<PurchaseOrderItem> items = new ArrayList<>();

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;

    @Column(name = "supplier_reference", length = 100)
    private String supplierReference;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\supplier\PurchaseOrderItem.java"   & echo.. 
package com.pharmacy.medlan.model.supplier;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.product.Product;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "purchase_order_items")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PurchaseOrderItem extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "purchase_order_id", nullable = false)
    private PurchaseOrder purchaseOrder;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(name = "quantity_ordered", nullable = false)
    private Integer quantityOrdered;

    @Column(name = "quantity_received", nullable = false)
    private Integer quantityReceived = 0;

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    @Column(name = "discount_percent", precision = 5, scale = 2)
    private BigDecimal discountPercent = BigDecimal.ZERO;

    @Column(name = "discount_amount", precision = 10, scale = 2)
    private BigDecimal discountAmount = BigDecimal.ZERO;

    @Column(name = "gst_rate", precision = 5, scale = 2, nullable = false)
    private BigDecimal gstRate;

    @Column(name = "gst_amount", precision = 10, scale = 2, nullable = false)
    private BigDecimal gstAmount;

    @Column(name = "total_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "remarks", length = 500)
    private String remarks;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\supplier\Supplier.java"   & echo.. 
package com.pharmacy.medlan.model.supplier;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "suppliers", indexes = {
        @Index(name = "idx_supplier_code", columnList = "supplier_code"),
        @Index(name = "idx_supplier_name", columnList = "supplier_name")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Supplier extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "supplier_code", nullable = false, unique = true, length = 50)
    private String supplierCode;

    @Column(name = "supplier_name", nullable = false, length = 200)
    private String supplierName;

    @Column(name = "contact_person", length = 100)
    private String contactPerson;

    @Column(name = "phone_number", length = 50)
    private String phoneNumber;

    @Column(name = "email", length = 100)
    private String email;

    @Column(name = "address", columnDefinition = "TEXT")
    private String address;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "state", length = 100)
    private String state;

    @Column(name = "pincode", length = 20)
    private String pincode;

    @Column(name = "gstin_number", length = 50)
    private String gstinNumber;

    @Column(name = "pan_number", length = 50)
    private String panNumber;

    @Column(name = "drug_license_number", length = 50)
    private String drugLicenseNumber;

    @Column(name = "default_discount_percent", precision = 5, scale = 2)
    private BigDecimal defaultDiscountPercent = BigDecimal.ZERO;

    @Column(name = "payment_term_days")
    private Integer paymentTermDays = 30; // Default 30 days

    @Column(name = "credit_limit", precision = 12, scale = 2)
    private BigDecimal creditLimit = BigDecimal.ZERO;

    @Column(name = "current_balance", precision = 12, scale = 2)
    private BigDecimal currentBalance = BigDecimal.ZERO;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @OneToMany(mappedBy = "supplier", cascade = CascadeType.ALL)
    @Builder.Default
    private List<PurchaseOrder> purchaseOrders = new ArrayList<>();

    @OneToMany(mappedBy = "supplier", cascade = CascadeType.ALL)
    @Builder.Default
    private List<SupplierPayment> payments = new ArrayList<>();
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\supplier\SupplierPayment.java"   & echo.. 
package com.pharmacy.medlan.model.supplier;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.user.User;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "supplier_payments")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SupplierPayment extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "payment_number", nullable = false, unique = true, length = 50)
    private String paymentNumber; // SP-2024-00001

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_id", nullable = false)
    private Supplier supplier;

    @Column(name = "payment_date", nullable = false)
    private LocalDate paymentDate;

    @Column(name = "amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal amount;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", nullable = false, length = 50)
    private PaymentMethod paymentMethod;

    @Column(name = "cheque_number", length = 100)
    private String chequeNumber;

    @Column(name = "cheque_date")
    private LocalDate chequeDate;

    @Column(name = "bank_name", length = 100)
    private String bankName;

    @Column(name = "transaction_reference", length = 100)
    private String transactionReference;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private PaymentStatus status = PaymentStatus.PAID;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "paid_by_user_id")
    private User paidByUser;

    @OneToMany(mappedBy = "supplierPayment", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private List<SupplierPaymentDetail> paymentDetails = new ArrayList<>();

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\supplier\SupplierPaymentDetail.java"   & echo.. 
package com.pharmacy.medlan.model.supplier;

import com.pharmacy.medlan.model.base.BaseEntity;
import com.pharmacy.medlan.model.inventory.GRN;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;

@Entity
@Table(name = "supplier_payment_details")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SupplierPaymentDetail extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "supplier_payment_id", nullable = false)
    private SupplierPayment supplierPayment;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "grn_id")
    private GRN grn;

    @Column(name = "invoice_number", length = 100)
    private String invoiceNumber;

    @Column(name = "invoice_amount", precision = 12, scale = 2)
    private BigDecimal invoiceAmount;

    @Column(name = "paid_amount", nullable = false, precision = 12, scale = 2)
    private BigDecimal paidAmount;

    @Column(name = "balance_amount", precision = 12, scale = 2)
    private BigDecimal balanceAmount;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\system\SystemConfig.java"   & echo.. 
package com.pharmacy.medlan.model.system;

import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "system_config",
        uniqueConstraints = @UniqueConstraint(columnNames = {"config_key"}))
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SystemConfig extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "config_key", nullable = false, unique = true, length = 100)
    private String configKey;

    @Column(name = "config_value", columnDefinition = "TEXT")
    private String configValue;

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "category", length = 100)
    private String category; // GENERAL, SALES, INVENTORY, FINANCE

    @Column(name = "data_type", length = 50)
    private String dataType; // STRING, INTEGER, BOOLEAN, DECIMAL

    @Column(name = "is_editable", nullable = false)
    private Boolean isEditable = true;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\user\BranchStaff.java"   & echo.. 
package com.pharmacy.medlan.model.user;

import com.pharmacy.medlan.enums.EmploymentType;
import com.pharmacy.medlan.model.base.AuditableEntity;
import com.pharmacy.medlan.model.organization.Branch;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;

@Entity
@Table(name = "branch_staff",
        uniqueConstraints = @UniqueConstraint(columnNames = {"user_id", "branch_id"}))
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BranchStaff extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "branch_id", nullable = false)
    private Branch branch;

    @Column(name = "designation", length = 100)
    private String designation;

    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", length = 50)
    private EmploymentType employmentType; // FULL_TIME, PART_TIME, CONTRACT

    @Column(name = "joining_date", nullable = false)
    private LocalDate joiningDate;

    @Column(name = "leaving_date")
    private LocalDate leavingDate;

    @Column(name = "is_primary_branch", nullable = false)
    private Boolean isPrimaryBranch = false;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\user\EmployeeAuthorization.java"   & echo.. 
package com.pharmacy.medlan.model.user;

import com.pharmacy.medlan.enums.AuthorizationStatus;
import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "employee_authorizations")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmployeeAuthorization extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "employee_id", nullable = false)
    private User employee;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "authorized_by")
    private User authorizedBy;

    @Column(name = "transaction_type", nullable = false, length = 100)
    private String transactionType; // DISCOUNT, CREDIT_SALE, VOID, etc.

    @Column(name = "transaction_reference_id")
    private Long transactionReferenceId;

    @Column(name = "authorization_code", unique = true, length = 50)
    private String authorizationCode;

    @Column(name = "amount", precision = 12, scale = 2)
    private BigDecimal amount;

    @Column(name = "reason", columnDefinition = "TEXT")
    private String reason;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private AuthorizationStatus status = AuthorizationStatus.PENDING;

    @Column(name = "requested_at", nullable = false)
    private LocalDateTime requestedAt;

    @Column(name = "responded_at")
    private LocalDateTime respondedAt;

    @Column(name = "remarks", columnDefinition = "TEXT")
    private String remarks;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\user\User.java"   & echo.. 
package com.pharmacy.medlan.model.user;

import com.pharmacy.medlan.enums.Role;
import com.pharmacy.medlan.model.base.AuditableEntity;
import jakarta.persistence.*;
import lombok.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "users", indexes = {
        @Index(name = "idx_username", columnList = "username"),
        @Index(name = "idx_email", columnList = "email")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "username", nullable = false, unique = true, length = 100)
    private String username;

    @Column(name = "password", nullable = false, length = 255)
    private String password; // BCrypt encoded

    @Column(name = "full_name", nullable = false, length = 200)
    private String fullName;

    @Column(name = "email", unique = true, length = 100)
    private String email;

    @Column(name = "phone_number", length = 50)
    private String phoneNumber;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 50)
    private Role role;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "last_login_date")
    private LocalDate lastLoginDate;

    @Column(name = "discount_limit", precision = 10, scale = 2)
    private BigDecimal discountLimit = BigDecimal.ZERO;

    @Column(name = "credit_transaction_limit", precision = 12, scale = 2)
    private BigDecimal creditTransactionLimit = BigDecimal.ZERO;

    @Column(name = "employee_code", unique = true, length = 50)
    private String employeeCode;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    @Builder.Default
    private List<BranchStaff> branchAssignments = new ArrayList<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    @Builder.Default
    private List<UserSession> sessions = new ArrayList<>();
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\model\user\UserSession.java"   & echo.. 
package com.pharmacy.medlan.model.user;

import com.pharmacy.medlan.model.base.BaseEntity;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "user_sessions", indexes = {
        @Index(name = "idx_session_token", columnList = "session_token"),
        @Index(name = "idx_session_user", columnList = "user_id")
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserSession extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "session_token", nullable = false, unique = true, length = 500)
    private String sessionToken;

    @Column(name = "ip_address", length = 50)
    private String ipAddress;

    @Column(name = "user_agent", length = 500)
    private String userAgent;

    @Column(name = "login_time", nullable = false)
    private LocalDateTime loginTime;

    @Column(name = "last_activity_time", nullable = false)
    private LocalDateTime lastActivityTime;

    @Column(name = "logout_time")
    private LocalDateTime logoutTime;

    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\audit\AuditLogRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.audit;

import com.pharmacy.medlan.model.audit.AuditLog;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {
    List<AuditLog> findByUserId(Long userId);
    List<AuditLog> findByAction(String action);
    List<AuditLog> findByEntityType(String entityType);
    List<AuditLog> findByEntityTypeAndEntityId(String entityType, Long entityId);
    List<AuditLog> findByTimestampBetween(LocalDateTime startDate, LocalDateTime endDate);

    @Query("SELECT al FROM AuditLog al WHERE al.user.id = :userId " +
            "AND al.timestamp BETWEEN :startDate AND :endDate ORDER BY al.timestamp DESC")
    List<AuditLog> findByUserAndDateRange(Long userId, LocalDateTime startDate, LocalDateTime endDate);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\audit\SyncLogRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.audit;

import com.pharmacy.medlan.model.audit.SyncLog;
import com.pharmacy.medlan.enums.SyncStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface SyncLogRepository extends JpaRepository<SyncLog, Long> {
    List<SyncLog> findBySyncType(String syncType);
    List<SyncLog> findByBranchId(Long branchId);
    List<SyncLog> findByStatus(SyncStatus status);
    List<SyncLog> findByStartedAtBetween(LocalDateTime startDate, LocalDateTime endDate);
    List<SyncLog> findBySyncTypeAndStatus(String syncType, SyncStatus status);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\finance\BankDataRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.finance;

import com.pharmacy.medlan.model.finance.BankData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface BankDataRepository extends JpaRepository<BankData, Long> {
    List<BankData> findByBankId(Long bankId);
    List<BankData> findByTransactionDateBetween(LocalDate startDate, LocalDate endDate);
    List<BankData> findByBankIdAndTransactionDateBetween(Long bankId, LocalDate startDate, LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\finance\BankRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.finance;

import com.pharmacy.medlan.model.finance.Bank;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Repository
public interface BankRepository extends JpaRepository<Bank, Long>, JpaSpecificationExecutor<Bank> {

    Optional<Bank> findByAccountNumber(String accountNumber);

    Optional<Bank> findByBankNameAndBranchName(String bankName, String branchName);

    List<Bank> findByIsActiveTrue();

    List<Bank> findByIsActiveFalse();

    List<Bank> findByBankName(String bankName);

    List<Bank> findByAccountType(String accountType);

    @Query("SELECT b FROM Bank b WHERE " +
            "(LOWER(b.bankName) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(b.accountNumber) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(b.branchName) LIKE LOWER(CONCAT('%', :search, '%')))")
    List<Bank> searchBanks(@Param("search") String search);

    @Query("SELECT SUM(b.currentBalance) FROM Bank b WHERE b.isActive = true")
    BigDecimal getTotalBankBalance();

    @Query("SELECT b FROM Bank b WHERE b.isActive = true AND b.currentBalance > 0 " +
            "ORDER BY b.currentBalance DESC")
    List<Bank> findBanksWithPositiveBalance();

    @Query("SELECT COUNT(b) FROM Bank b WHERE b.isActive = true")
    Long countActiveBanks();

    boolean existsByAccountNumber(String accountNumber);

    boolean existsByIfscCode(String ifscCode);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\finance\CashBookRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.finance;

import com.pharmacy.medlan.model.finance.CashBook;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface CashBookRepository extends JpaRepository<CashBook, Long> {
    List<CashBook> findByBranchId(Long branchId);
    List<CashBook> findByTransactionDateBetween(LocalDate startDate, LocalDate endDate);
    List<CashBook> findByBranchIdAndTransactionDateBetween(Long branchId, LocalDate startDate, LocalDate endDate);

    @Query("SELECT cb FROM CashBook cb WHERE cb.branch.id = :branchId " +
            "ORDER BY cb.transactionDate DESC, cb.id DESC")
    List<CashBook> findLatestByBranch(Long branchId);

    @Query("SELECT SUM(cb.debitAmount) FROM CashBook cb WHERE cb.branch.id = :branchId " +
            "AND cb.transactionDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalDebitByBranchAndDate(Long branchId, LocalDate startDate, LocalDate endDate);

    @Query("SELECT SUM(cb.creditAmount) FROM CashBook cb WHERE cb.branch.id = :branchId " +
            "AND cb.transactionDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalCreditByBranchAndDate(Long branchId, LocalDate startDate, LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\finance\IncomingChequeRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.finance;

import com.pharmacy.medlan.model.finance.IncomingCheque;
import com.pharmacy.medlan.enums.ChequeStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface IncomingChequeRepository extends JpaRepository<IncomingCheque, Long> {
    Optional<IncomingCheque> findByChequeNumber(String chequeNumber);
    List<IncomingCheque> findByStatus(ChequeStatus status);
    List<IncomingCheque> findByBankId(Long bankId);
    List<IncomingCheque> findByCustomerId(Long customerId);
    List<IncomingCheque> findBySupplierId(Long supplierId);
    List<IncomingCheque> findByChequeDateBetween(LocalDate startDate, LocalDate endDate);
    List<IncomingCheque> findByDepositDateBetween(LocalDate startDate, LocalDate endDate);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\finance\PaymentRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.finance;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.pos.Payment;

@Repository("financePaymentRepository")
public interface PaymentRepository extends JpaRepository<Payment, Long>, JpaSpecificationExecutor<Payment> {

    Optional<Payment> findByReferenceNumber(String referenceNumber);

    List<Payment> findByInvoiceId(Long invoiceId);

    List<Payment> findBySaleId(Long saleId);

    List<Payment> findByPaymentMethod(PaymentMethod paymentMethod);

    List<Payment> findByStatus(PaymentStatus status);

    List<Payment> findByPaymentDateBetween(LocalDate startDate, LocalDate endDate);

    @Query("SELECT p FROM Payment p WHERE p.invoice.id = :invoiceId ORDER BY p.paymentDate DESC")
    List<Payment> findPaymentsByInvoice(@Param("invoiceId") Long invoiceId);

    @Query("SELECT p FROM Payment p WHERE p.sale.id = :saleId ORDER BY p.paymentDate DESC")
    List<Payment> findPaymentsBySale(@Param("saleId") Long saleId);

    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.invoice.id = :invoiceId AND p.status = 'PAID'")
    BigDecimal getTotalPaidAmountByInvoice(@Param("invoiceId") Long invoiceId);

    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.sale.id = :saleId AND p.status = 'PAID'")
    BigDecimal getTotalPaidAmountBySale(@Param("saleId") Long saleId);

    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate " +
            "AND p.status = 'PAID'")
    BigDecimal getTotalPaymentsByDateRange(
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate " +
            "AND p.paymentMethod = :method AND p.status = 'PAID'")
    BigDecimal getTotalPaymentsByMethodAndDateRange(
            @Param("method") PaymentMethod method,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT COUNT(p) FROM Payment p WHERE p.paymentMethod = :method " +
            "AND p.paymentDate BETWEEN :startDate AND :endDate")
    Long countByMethodAndDateRange(
            @Param("method") PaymentMethod method,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\finance\TransactionTypeRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.finance;

import com.pharmacy.medlan.model.finance.TransactionType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface TransactionTypeRepository extends JpaRepository<TransactionType, Long> {
    Optional<TransactionType> findByTypeName(String typeName);
    List<TransactionType> findByIsIncome(Boolean isIncome);
    List<TransactionType> findByIsActiveTrue();
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\ExpiryDataRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import com.pharmacy.medlan.model.inventory.ExpiryData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface ExpiryDataRepository extends JpaRepository<ExpiryData, Long> {
    List<ExpiryData> findByProductId(Long productId);
    List<ExpiryData> findByExpiryDateBefore(LocalDate date);
    List<ExpiryData> findByExpiryDateBetween(LocalDate startDate, LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\GRNLineRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.model.inventory.GRNLine;

@Repository
public interface GRNLineRepository extends JpaRepository<GRNLine, Long> {

    List<GRNLine> findByGrnId(Long grnId);

    List<GRNLine> findByProductId(Long productId);

    Optional<GRNLine> findByGrnIdAndProductIdAndBatchNumber(Long grnId, Long productId, String batchNumber);

    @Query("SELECT gl FROM GRNLine gl WHERE gl.product.id = :productId " +
            "AND gl.batchNumber = :batchNumber")
    List<GRNLine> findByProductAndBatch(
            @Param("productId") Long productId,
            @Param("batchNumber") String batchNumber);

    @Query("SELECT gl FROM GRNLine gl WHERE gl.expiryDate < :date")
    List<GRNLine> findExpiredBatches(@Param("date") LocalDate date);

    @Query("SELECT gl FROM GRNLine gl WHERE gl.expiryDate BETWEEN :startDate AND :endDate")
    List<GRNLine> findBatchesExpiringBetween(
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(gl.totalAmount) FROM GRNLine gl WHERE gl.grn.id = :grnId")
    BigDecimal getTotalAmountByGrn(@Param("grnId") Long grnId);

    @Query("SELECT SUM(gl.quantityReceived) FROM GRNLine gl WHERE gl.product.id = :productId " +
            "AND gl.grn.receivedDate BETWEEN :startDate AND :endDate")
    Integer getTotalReceivedQuantityByProductAndDateRange(
            @Param("productId") Long productId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT DISTINCT gl.batchNumber FROM GRNLine gl WHERE gl.product.id = :productId")
    List<String> findAllBatchNumbersByProduct(@Param("productId") Long productId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\GRNRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.GRNStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.inventory.GRN;

@Repository
public interface GRNRepository extends JpaRepository<GRN, Long>, JpaSpecificationExecutor<GRN> {

    Optional<GRN> findByGrnNumber(String grnNumber);

    List<GRN> findBySupplierId(Long supplierId);

    List<GRN> findByBranchId(Long branchId);

    List<GRN> findByStatus(GRNStatus status);

    List<GRN> findByPaymentStatus(PaymentStatus paymentStatus);

    List<GRN> findByReceivedDateBetween(LocalDate startDate, LocalDate endDate);

    Optional<GRN> findByPurchaseOrderId(Long purchaseOrderId);

    List<GRN> findBySupplierIdAndStatus(Long supplierId, GRNStatus status);

    List<GRN> findByBranchIdAndStatus(Long branchId, GRNStatus status);

    @Query("SELECT g FROM GRN g WHERE g.branch.id = :branchId " +
            "AND g.receivedDate BETWEEN :startDate AND :endDate")
    List<GRN> findByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT g FROM GRN g WHERE g.supplier.id = :supplierId " +
            "AND g.paymentStatus IN ('UNPAID', 'PARTIALLY_PAID')")
    List<GRN> findUnpaidGRNsBySupplier(@Param("supplierId") Long supplierId);

    @Query("SELECT SUM(g.netAmount) FROM GRN g WHERE g.branch.id = :branchId " +
            "AND g.receivedDate BETWEEN :startDate AND :endDate " +
            "AND g.status = 'COMPLETED'")
    BigDecimal getTotalReceiptsByBranch(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(g.balanceAmount) FROM GRN g WHERE g.supplier.id = :supplierId " +
            "AND g.paymentStatus IN ('UNPAID', 'PARTIALLY_PAID')")
    BigDecimal getTotalOutstandingBySupplier(@Param("supplierId") Long supplierId);

    @Query("SELECT SUM(g.balanceAmount) FROM GRN g " +
            "WHERE g.paymentStatus IN ('UNPAID', 'PARTIALLY_PAID')")
    BigDecimal getTotalOutstandingBalance();

    @Query("SELECT COUNT(g) FROM GRN g WHERE g.status = :status")
    Long countByStatus(@Param("status") GRNStatus status);

    @Query("SELECT g FROM GRN g WHERE g.status = 'PENDING_APPROVAL'")
    List<GRN> findPendingApprovalGRNs();

    @Query("SELECT g FROM GRN g WHERE g.supplierInvoiceNumber = :invoiceNumber " +
            "AND g.supplier.id = :supplierId")
    Optional<GRN> findBySupplierInvoice(
            @Param("invoiceNumber") String invoiceNumber,
            @Param("supplierId") Long supplierId);

    boolean existsByGrnNumber(String grnNumber);

    boolean existsByPurchaseOrderId(Long purchaseOrderId);

    @Query("SELECT COUNT(g) FROM GRN g WHERE g.branch.id = :branchId " +
            "AND CAST(g.status AS string) = :status")
    int countByBranchIdAndStatus(
            @Param("branchId") Long branchId,
            @Param("status") String status);

    @Query("SELECT COUNT(g) FROM GRN g WHERE g.branch.id = :branchId " +
            "AND g.paymentStatus IN ('UNPAID', 'PARTIALLY_PAID')")
    int countOverduePayments(@Param("branchId") Long branchId);

    @Query("SELECT g FROM GRN g WHERE g.branch.id = :branchId " +
            "AND (CAST(g.paymentStatus AS string) = :status1 " +
            "OR CAST(g.paymentStatus AS string) = :status2)")
    List<GRN> findByBranchIdAndPaymentStatus(
            @Param("branchId") Long branchId,
            @Param("status1") String status1,
            @Param("status2") String status2);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\GRNTempRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import com.pharmacy.medlan.model.inventory.GRNTemp;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface GRNTempRepository extends JpaRepository<GRNTemp, Long> {

    List<GRNTemp> findByUserId(Long userId);

    List<GRNTemp> findByGrnNumber(String grnNumber);

    List<GRNTemp> findByProductId(Long productId);

    List<GRNTemp> findByStatus(Integer status);

    List<GRNTemp> findByUserIdAndStatus(Long userId, Integer status);

    List<GRNTemp> findByUserIdAndGrnNumber(Long userId, String grnNumber);

    @Query("SELECT gt FROM GRNTemp gt WHERE gt.userId = :userId AND gt.status = 0 " +
            "ORDER BY gt.id DESC")
    List<GRNTemp> findPendingByUser(@Param("userId") Long userId);

    @Modifying
    @Query("DELETE FROM GRNTemp gt WHERE gt.userId = :userId AND gt.grnNumber = :grnNumber")
    void deleteByUserAndGrnNumber(@Param("userId") Long userId, @Param("grnNumber") String grnNumber);

    @Modifying
    @Query("DELETE FROM GRNTemp gt WHERE gt.userId = :userId")
    void deleteAllByUser(@Param("userId") Long userId);

    @Modifying
    @Query("UPDATE GRNTemp gt SET gt.status = :status WHERE gt.grnNumber = :grnNumber")
    void updateStatusByGrnNumber(@Param("grnNumber") String grnNumber, @Param("status") Integer status);

    @Query("SELECT COUNT(gt) FROM GRNTemp gt WHERE gt.userId = :userId AND gt.status = 0")
    Long countPendingByUser(@Param("userId") Long userId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\InventoryTransactionRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.TransactionType;
import com.pharmacy.medlan.model.inventory.InventoryTransaction;

@Repository
public interface InventoryTransactionRepository extends JpaRepository<InventoryTransaction, Long>, JpaSpecificationExecutor<InventoryTransaction> {

    Optional<InventoryTransaction> findByTransactionNumber(String transactionNumber);

    List<InventoryTransaction> findByProductId(Long productId);

    List<InventoryTransaction> findByBranchId(Long branchId);

    List<InventoryTransaction> findByTransactionType(TransactionType transactionType);

    List<InventoryTransaction> findByIsApproved(Boolean isApproved);

    List<InventoryTransaction> findByTransactionDateBetween(LocalDateTime startDate, LocalDateTime endDate);

    List<InventoryTransaction> findByProductIdAndBranchId(Long productId, Long branchId);

    @Query("SELECT it FROM InventoryTransaction it WHERE it.product.id = :productId " +
            "AND it.branch.id = :branchId " +
            "AND it.transactionDate BETWEEN :startDate AND :endDate " +
            "ORDER BY it.transactionDate DESC")
    List<InventoryTransaction> findByProductBranchAndDateRange(
            @Param("productId") Long productId,
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT it FROM InventoryTransaction it WHERE it.branch.id = :branchId " +
            "AND it.transactionDate BETWEEN :startDate AND :endDate " +
            "ORDER BY it.transactionDate DESC")
    List<InventoryTransaction> findByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT SUM(it.quantity) FROM InventoryTransaction it " +
            "WHERE it.product.id = :productId AND it.branch.id = :branchId " +
            "AND it.transactionType IN ('SALE', 'RETURN_TO_SUPPLIER', 'TRANSFER_OUT', 'ADJUSTMENT_OUT', 'DAMAGE', 'EXPIRED')")
    Integer getTotalOutQuantity(@Param("productId") Long productId, @Param("branchId") Long branchId);

    @Query("SELECT SUM(it.quantity) FROM InventoryTransaction it " +
            "WHERE it.product.id = :productId AND it.branch.id = :branchId " +
            "AND it.transactionType IN ('PURCHASE', 'RETURN_FROM_CUSTOMER', 'TRANSFER_IN', 'ADJUSTMENT_IN', 'OPENING_STOCK')")
    Integer getTotalInQuantity(@Param("productId") Long productId, @Param("branchId") Long branchId);

    @Query("SELECT it FROM InventoryTransaction it WHERE it.isApproved = false " +
            "ORDER BY it.transactionDate DESC")
    List<InventoryTransaction> findPendingApprovalTransactions();

    @Query("SELECT COUNT(it) FROM InventoryTransaction it WHERE it.transactionType = :type " +
            "AND it.transactionDate BETWEEN :startDate AND :endDate")
    Long countByTypeAndDateRange(
            @Param("type") TransactionType type,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    boolean existsByTransactionNumber(String transactionNumber);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\ProductBinCardRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.TransactionType;
import com.pharmacy.medlan.model.inventory.ProductBinCard;

@Repository
public interface ProductBinCardRepository extends JpaRepository<ProductBinCard, Long>, JpaSpecificationExecutor<ProductBinCard> {

    List<ProductBinCard> findByProductId(Long productId);

    List<ProductBinCard> findByBranchId(Long branchId);

    List<ProductBinCard> findByProductIdAndBranchId(Long productId, Long branchId);

    List<ProductBinCard> findByTransactionType(TransactionType transactionType);

    List<ProductBinCard> findByReferenceNumber(String referenceNumber);

    List<ProductBinCard> findByTransactionDateBetween(LocalDateTime startDate, LocalDateTime endDate);

    @Query("SELECT pbc FROM ProductBinCard pbc WHERE pbc.product.id = :productId " +
            "AND pbc.branch.id = :branchId ORDER BY pbc.transactionDate DESC, pbc.id DESC")
    List<ProductBinCard> findBinCardByProductAndBranch(
            @Param("productId") Long productId,
            @Param("branchId") Long branchId);

    @Query("SELECT pbc FROM ProductBinCard pbc WHERE pbc.product.id = :productId " +
            "AND pbc.branch.id = :branchId " +
            "AND pbc.transactionDate BETWEEN :startDate AND :endDate " +
            "ORDER BY pbc.transactionDate ASC, pbc.id ASC")
    List<ProductBinCard> findBinCardByProductBranchAndDateRange(
            @Param("productId") Long productId,
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT pbc FROM ProductBinCard pbc WHERE pbc.product.id = :productId " +
            "AND pbc.branch.id = :branchId ORDER BY pbc.id DESC LIMIT 1")
    Optional<ProductBinCard> findLatestBinCardEntry(
            @Param("productId") Long productId,
            @Param("branchId") Long branchId);

    @Query("SELECT SUM(pbc.quantityIn) FROM ProductBinCard pbc WHERE pbc.product.id = :productId " +
            "AND pbc.branch.id = :branchId " +
            "AND pbc.transactionDate BETWEEN :startDate AND :endDate")
    Integer getTotalQuantityIn(
            @Param("productId") Long productId,
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT SUM(pbc.quantityOut) FROM ProductBinCard pbc WHERE pbc.product.id = :productId " +
            "AND pbc.branch.id = :branchId " +
            "AND pbc.transactionDate BETWEEN :startDate AND :endDate")
    Integer getTotalQuantityOut(
            @Param("productId") Long productId,
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT pbc FROM ProductBinCard pbc WHERE pbc.branch.id = :branchId " +
            "AND pbc.transactionDate BETWEEN :startDate AND :endDate " +
            "ORDER BY pbc.transactionDate DESC")
    List<ProductBinCard> findBinCardByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT COUNT(pbc) FROM ProductBinCard pbc WHERE pbc.product.id = :productId " +
            "AND pbc.branch.id = :branchId")
    Long countByProductAndBranch(
            @Param("productId") Long productId,
            @Param("branchId") Long branchId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\RGRNLineRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.model.inventory.RGRNLine;

@Repository
public interface RGRNLineRepository extends JpaRepository<RGRNLine, Long> {

    List<RGRNLine> findByRgrnId(Long rgrnId);

    List<RGRNLine> findByProductId(Long productId);

    Optional<RGRNLine> findByRgrnIdAndProductIdAndBatchNumber(Long rgrnId, Long productId, String batchNumber);

    @Query("SELECT rl FROM RGRNLine rl WHERE rl.product.id = :productId " +
            "AND rl.batchNumber = :batchNumber")
    List<RGRNLine> findByProductAndBatch(
            @Param("productId") Long productId,
            @Param("batchNumber") String batchNumber);

    @Query("SELECT SUM(rl.totalAmount) FROM RGRNLine rl WHERE rl.rgrn.id = :rgrnId")
    BigDecimal getTotalAmountByRgrn(@Param("rgrnId") Long rgrnId);

    @Query("SELECT SUM(rl.quantityReturned) FROM RGRNLine rl WHERE rl.product.id = :productId")
    Integer getTotalReturnedQuantityByProduct(@Param("productId") Long productId);

    @Query("SELECT rl FROM RGRNLine rl WHERE rl.rgrn.supplier.id = :supplierId")
    List<RGRNLine> findBySupplier(@Param("supplierId") Long supplierId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\RGRNRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.inventory.RGRN;

@Repository
public interface RGRNRepository extends JpaRepository<RGRN, Long>, JpaSpecificationExecutor<RGRN> {

    Optional<RGRN> findByRgrnNumber(String rgrnNumber);

    List<RGRN> findBySupplierId(Long supplierId);

    List<RGRN> findByBranchId(Long branchId);

    List<RGRN> findByOriginalGrnId(Long originalGrnId);

    List<RGRN> findByRefundStatus(PaymentStatus refundStatus);

    List<RGRN> findByReturnDateBetween(LocalDate startDate, LocalDate endDate);

    @Query("SELECT r FROM RGRN r WHERE r.supplier.id = :supplierId " +
            "AND r.refundStatus = 'PENDING'")
    List<RGRN> findPendingRefundsBySupplier(@Param("supplierId") Long supplierId);

    @Query("SELECT r FROM RGRN r WHERE r.branch.id = :branchId " +
            "AND r.returnDate BETWEEN :startDate AND :endDate")
    List<RGRN> findByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(r.totalReturnAmount) FROM RGRN r WHERE r.supplier.id = :supplierId " +
            "AND r.returnDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalReturnsBySupplierAndDateRange(
            @Param("supplierId") Long supplierId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(r.totalReturnAmount) FROM RGRN r WHERE r.branch.id = :branchId " +
            "AND r.returnDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalReturnsByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT COUNT(r) FROM RGRN r WHERE r.refundStatus = :status")
    Long countByRefundStatus(@Param("status") PaymentStatus status);

    boolean existsByRgrnNumber(String rgrnNumber);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\StockTransferItemRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import com.pharmacy.medlan.model.inventory.StockTransferItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface StockTransferItemRepository extends JpaRepository<StockTransferItem, Long> {
    List<StockTransferItem> findByStockTransferId(Long stockTransferId);
    List<StockTransferItem> findByProductId(Long productId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\inventory\StockTransferRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.inventory;

import com.pharmacy.medlan.model.inventory.StockTransfer;
import com.pharmacy.medlan.enums.StockTransferStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface StockTransferRepository extends JpaRepository<StockTransfer, Long> {
    Optional<StockTransfer> findByTransferNumber(String transferNumber);
    List<StockTransfer> findByFromBranchId(Long fromBranchId);
    List<StockTransfer> findByToBranchId(Long toBranchId);
    List<StockTransfer> findByStatus(StockTransferStatus status);

    @Query("SELECT st FROM StockTransfer st WHERE st.fromBranch.id = :branchId " +
            "OR st.toBranch.id = :branchId")
    List<StockTransfer> findByBranch(Long branchId);

    List<StockTransfer> findByTransferDateBetween(LocalDate startDate, LocalDate endDate);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\notification\NotificationRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.notification;

import com.pharmacy.medlan.model.notification.Notification;
import com.pharmacy.medlan.enums.NotificationType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, Long> {
    
    List<Notification> findByUserId(Long userId);
    
    List<Notification> findByType(NotificationType type);
    
    List<Notification> findByIsReadFalse();
    
    List<Notification> findByUserIdOrderByCreatedAtDesc(Long userId);
    
    List<Notification> findByUserIdAndIsReadFalseOrderByCreatedAtDesc(Long userId);
    
    int countByUserIdAndIsReadFalse(Long userId);

    @Query("SELECT n FROM Notification n WHERE n.user.id = :userId " +
            "AND n.isRead = false ORDER BY n.createdAt DESC")
    List<Notification> findUnreadNotificationsByUser(@Param("userId") Long userId);

    @Query("SELECT n FROM Notification n WHERE n.user.id = :userId " +
            "ORDER BY n.createdAt DESC")
    List<Notification> findAllNotificationsByUser(@Param("userId") Long userId);

    @Query("SELECT COUNT(n) FROM Notification n WHERE n.user.id = :userId AND n.isRead = false")
    Long countUnreadByUser(@Param("userId") Long userId);
    
    @Modifying
    @Query("UPDATE Notification n SET n.isRead = true, n.readAt = :readAt " +
           "WHERE n.user.id = :userId AND n.isRead = false")
    void markAllAsReadByUserId(@Param("userId") Long userId, @Param("readAt") LocalDateTime readAt);
    
    @Modifying
    @Query("DELETE FROM Notification n WHERE n.user.id = :userId")
    void deleteByUserId(@Param("userId") Long userId);
    
    @Modifying
    @Query("DELETE FROM Notification n WHERE n.isRead = true AND n.readAt < :beforeDate")
    void deleteOldReadNotifications(@Param("beforeDate") LocalDateTime beforeDate);
    
    @Query("SELECT n FROM Notification n WHERE n.user.id IN " +
           "(SELECT bs.user.id FROM BranchStaff bs WHERE bs.branch.id = :branchId) " +
           "ORDER BY n.createdAt DESC")
    List<Notification> findByBranchId(@Param("branchId") Long branchId);
    
    @Query("SELECT n FROM Notification n WHERE n.type = :type AND n.createdAt > :since " +
           "ORDER BY n.createdAt DESC")
    List<Notification> findRecentByType(@Param("type") NotificationType type, 
                                        @Param("since") LocalDateTime since);

    int countByIsRead(Boolean isRead);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\organization\BranchRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.organization;

import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.model.organization.Branch;

@Repository
public interface BranchRepository extends JpaRepository<Branch, Long>, JpaSpecificationExecutor<Branch> {

    Optional<Branch> findByBranchCode(String branchCode);

    Optional<Branch> findByBranchName(String branchName);

    List<Branch> findByIsActiveTrue();

    List<Branch> findByIsActiveFalse();

    Optional<Branch> findByIsMainBranchTrue();

    List<Branch> findByCity(String city);

    List<Branch> findByState(String state);

    Optional<Branch> findByManagerId(Long managerId);

    @Query("SELECT b FROM Branch b WHERE " +
            "(LOWER(b.branchName) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(b.branchCode) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(b.city) LIKE LOWER(CONCAT('%', :search, '%')))")
    List<Branch> searchBranches(@Param("search") String search);

    @Query("SELECT b FROM Branch b JOIN b.staff bs WHERE bs.user.id = :userId")
    List<Branch> findBranchesByStaffUser(@Param("userId") Long userId);

    @Query("SELECT COUNT(b) FROM Branch b WHERE b.isActive = true")
    Long countActiveBranches();

    @Query("SELECT b FROM Branch b WHERE b.drugLicenseNumber IS NOT NULL")
    List<Branch> findBranchesWithDrugLicense();

    @Query("SELECT b FROM Branch b WHERE b.gstinNumber IS NOT NULL")
    List<Branch> findBranchesWithGSTIN();

    boolean existsByBranchCode(String branchCode);

    boolean existsByBranchName(String branchName);

    boolean existsByEmail(String email);

    boolean existsByGstinNumber(String gstinNumber);

    boolean existsByDrugLicenseNumber(String drugLicenseNumber);
    
    /**
     * Find all active branches
     */
    @Query("SELECT b FROM Branch b WHERE b.isActive = true ORDER BY b.branchName")
    List<Branch> findAllActive();
    
    /**
     * Find branches by IDs
     */
    @Query("SELECT b FROM Branch b WHERE b.id IN :ids")
    List<Branch> findByIds(@Param("ids") List<Long> ids);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\payroll\EmployeePaymentRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.payroll;

import com.pharmacy.medlan.model.payroll.EmployeePayment;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface EmployeePaymentRepository extends JpaRepository<EmployeePayment, Long> {
    List<EmployeePayment> findByEmployeeId(Long employeeId);
    List<EmployeePayment> findByPaymentDateBetween(LocalDate startDate, LocalDate endDate);

    @Query("SELECT SUM(ep.amount) FROM EmployeePayment ep WHERE ep.employee.id = :employeeId " +
            "AND ep.paymentDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalPaymentsByEmployeeAndDate(Long employeeId, LocalDate startDate, LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\payroll\EmployeeRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.payroll;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.EmploymentType;
import com.pharmacy.medlan.model.payroll.Employee;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long>, JpaSpecificationExecutor<Employee> {

    Optional<Employee> findByEmployeeCode(String employeeCode);

    List<Employee> findByIsActiveTrue();

    List<Employee> findByIsActiveFalse();

    List<Employee> findByEmploymentType(EmploymentType employmentType);

    List<Employee> findByDesignation(String designation);

    @Query("SELECT e FROM Employee e WHERE " +
            "(LOWER(e.fullName) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(e.employeeCode) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(e.designation) LIKE LOWER(CONCAT('%', :search, '%')))")
    List<Employee> searchEmployees(@Param("search") String search);

    @Query("SELECT e FROM Employee e WHERE e.joiningDate BETWEEN :startDate AND :endDate")
    List<Employee> findByJoiningDateBetween(
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT e FROM Employee e WHERE e.leavingDate BETWEEN :startDate AND :endDate")
    List<Employee> findByLeavingDateBetween(
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(e.basicSalary) FROM Employee e WHERE e.isActive = true")
    BigDecimal getTotalBasicSalary();

    @Query("SELECT SUM(e.basicSalary + e.allowances) FROM Employee e WHERE e.isActive = true")
    BigDecimal getTotalPayroll();

    @Query("SELECT COUNT(e) FROM Employee e WHERE e.isActive = true")
    Long countActiveEmployees();

    @Query("SELECT COUNT(e) FROM Employee e WHERE e.employmentType = :type AND e.isActive = true")
    Long countByEmploymentType(@Param("type") EmploymentType type);

    @Query("SELECT DISTINCT e.designation FROM Employee e WHERE e.isActive = true")
    List<String> findAllDesignations();

    @Query("SELECT e FROM Employee e WHERE e.isActive = true " +
            "AND MONTH(e.joiningDate) = :month AND DAY(e.joiningDate) = :day")
    List<Employee> findEmployeesWithWorkAnniversary(
            @Param("month") int month,
            @Param("day") int day);

    boolean existsByEmployeeCode(String employeeCode);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\CustomerDataRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.CustomerData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface CustomerDataRepository extends JpaRepository<CustomerData, Long> {
    List<CustomerData> findByCustomerId(Long customerId);
    List<CustomerData> findByTransactionDateBetween(LocalDate startDate, LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\CustomerPrescriptionRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.CustomerPrescription;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface CustomerPrescriptionRepository extends JpaRepository<CustomerPrescription, Long> {
    List<CustomerPrescription> findByCustomerId(Long customerId);
    List<CustomerPrescription> findByProductId(Long productId);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\CustomerRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.CustomerStatus;
import com.pharmacy.medlan.model.pos.Customer;

@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long>, JpaSpecificationExecutor<Customer> {

    Optional<Customer> findByCustomerCode(String customerCode);

    Optional<Customer> findByPhoneNumber(String phoneNumber);

    Optional<Customer> findByEmail(String email);

    List<Customer> findByStatus(CustomerStatus status);

    List<Customer> findByCity(String city);

    List<Customer> findByState(String state);

    @Query("SELECT c FROM Customer c WHERE " +
            "(LOWER(c.customerName) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(c.customerCode) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(c.phoneNumber) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(c.email) LIKE LOWER(CONCAT('%', :search, '%')))")
    List<Customer> searchCustomers(@Param("search") String search);

    @Query("SELECT c FROM Customer c WHERE c.status = 'ACTIVE' " +
            "AND c.currentBalance > 0 ORDER BY c.currentBalance DESC")
    List<Customer> findCustomersWithOutstandingBalance();

    @Query("SELECT c FROM Customer c WHERE c.status = 'ACTIVE' " +
            "AND c.currentBalance >= c.creditLimit AND c.creditLimit > 0")
    List<Customer> findCustomersExceedingCreditLimit();

    @Query("SELECT SUM(c.currentBalance) FROM Customer c WHERE c.status = 'ACTIVE'")
    BigDecimal getTotalOutstandingBalance();

    @Query("SELECT COUNT(c) FROM Customer c WHERE c.status = 'ACTIVE'")
    Long countActiveCustomers();

    @Query("SELECT c FROM Customer c WHERE c.dateOfBirth = :date")
    List<Customer> findCustomersWithBirthday(@Param("date") LocalDate date);

    @Query("SELECT c FROM Customer c WHERE c.insuranceProvider IS NOT NULL " +
            "AND c.insurancePolicyNumber IS NOT NULL")
    List<Customer> findCustomersWithInsurance();

    @Query("SELECT c FROM Customer c WHERE c.allergies IS NOT NULL " +
            "AND c.allergies <> ''")
    List<Customer> findCustomersWithAllergies();

    @Query("SELECT c FROM Customer c JOIN c.sales s " +
            "WHERE s.saleDate BETWEEN :startDate AND :endDate " +
            "GROUP BY c ORDER BY COUNT(s) DESC")
    List<Customer> findTopCustomersByPurchaseFrequency(
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT c FROM Customer c JOIN c.sales s " +
            "WHERE s.saleDate BETWEEN :startDate AND :endDate " +
            "GROUP BY c ORDER BY SUM(s.totalAmount) DESC")
    List<Customer> findTopCustomersByPurchaseAmount(
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    boolean existsByCustomerCode(String customerCode);

    boolean existsByPhoneNumber(String phoneNumber);

    boolean existsByEmail(String email);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\InvoiceDataRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.InvoiceData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface InvoiceDataRepository extends JpaRepository<InvoiceData, Long> {
    List<InvoiceData> findByInvoiceId(Long invoiceId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\InvoiceRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.Invoice;
import com.pharmacy.medlan.enums.InvoiceStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface InvoiceRepository extends JpaRepository<Invoice, Long>, JpaSpecificationExecutor<Invoice> {

    Optional<Invoice> findByInvoiceNumber(String invoiceNumber);

    List<Invoice> findByCustomerId(Long customerId);

    List<Invoice> findByBranchId(Long branchId);

    List<Invoice> findByStatus(InvoiceStatus status);

    List<Invoice> findByPaymentStatus(PaymentStatus paymentStatus);

    List<Invoice> findByInvoiceDateBetween(LocalDate startDate, LocalDate endDate);

    List<Invoice> findByBranchIdAndStatus(Long branchId, InvoiceStatus status);

    List<Invoice> findByCustomerIdAndPaymentStatus(Long customerId, PaymentStatus paymentStatus);

    @Query("SELECT i FROM Invoice i WHERE i.branch.id = :branchId " +
            "AND i.invoiceDate BETWEEN :startDate AND :endDate")
    List<Invoice> findByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT i FROM Invoice i WHERE i.customer.id = :customerId " +
            "AND i.invoiceDate BETWEEN :startDate AND :endDate")
    List<Invoice> findByCustomerAndDateRange(
            @Param("customerId") Long customerId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(i.totalAmount) FROM Invoice i WHERE i.branch.id = :branchId " +
            "AND i.invoiceDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalSalesByBranchAndDate(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(i.balanceAmount) FROM Invoice i WHERE i.customer.id = :customerId " +
            "AND i.paymentStatus IN ('UNPAID', 'PARTIALLY_PAID')")
    BigDecimal getTotalOutstandingByCustomer(@Param("customerId") Long customerId);

    @Query("SELECT SUM(i.balanceAmount) FROM Invoice i WHERE i.branch.id = :branchId " +
            "AND i.paymentStatus IN ('UNPAID', 'PARTIALLY_PAID')")
    BigDecimal getTotalOutstandingByBranch(@Param("branchId") Long branchId);

    @Query("SELECT i FROM Invoice i WHERE i.paymentStatus IN ('UNPAID', 'PARTIALLY_PAID') " +
            "AND i.dueDate < :date")
    List<Invoice> findOverdueInvoices(@Param("date") LocalDate date);

    @Query("SELECT COUNT(i) FROM Invoice i WHERE i.status = :status")
    Long countByStatus(@Param("status") InvoiceStatus status);

    @Query("SELECT COUNT(i) FROM Invoice i WHERE i.branch.id = :branchId " +
            "AND i.invoiceDate BETWEEN :startDate AND :endDate")
    Long countByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT i FROM Invoice i WHERE i.doctorName = :doctorName " +
            "AND i.invoiceDate BETWEEN :startDate AND :endDate")
    List<Invoice> findByDoctorAndDateRange(
            @Param("doctorName") String doctorName,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT DISTINCT i.doctorName FROM Invoice i WHERE i.doctorName IS NOT NULL")
    List<String> findAllDoctorNames();

    boolean existsByInvoiceNumber(String invoiceNumber);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\InvoiceReturnRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.InvoiceReturn;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface InvoiceReturnRepository extends JpaRepository<InvoiceReturn, Long> {
    List<InvoiceReturn> findByInvoiceId(Long invoiceId);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\PatientNumberRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.PatientNumber;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.Optional;

@Repository
public interface PatientNumberRepository extends JpaRepository<PatientNumber, Long> {
    Optional<PatientNumber> findByToday(LocalDate today);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\PaymentRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.pos.Payment;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository("posPaymentRepository")
public interface PaymentRepository extends JpaRepository<Payment, Long>, JpaSpecificationExecutor<Payment> {

    Optional<Payment> findByReferenceNumber(String referenceNumber);

    List<Payment> findByInvoiceId(Long invoiceId);

    List<Payment> findBySaleId(Long saleId);

    List<Payment> findByPaymentMethod(PaymentMethod paymentMethod);

    List<Payment> findByStatus(PaymentStatus status);

    List<Payment> findByPaymentDateBetween(LocalDate startDate, LocalDate endDate);

    @Query("SELECT p FROM Payment p WHERE p.invoice.id = :invoiceId ORDER BY p.paymentDate DESC")
    List<Payment> findPaymentsByInvoice(@Param("invoiceId") Long invoiceId);

    @Query("SELECT p FROM Payment p WHERE p.sale.id = :saleId ORDER BY p.paymentDate DESC")
    List<Payment> findPaymentsBySale(@Param("saleId") Long saleId);

    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.invoice.id = :invoiceId AND p.status = 'PAID'")
    BigDecimal getTotalPaidAmountByInvoice(@Param("invoiceId") Long invoiceId);

    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.sale.id = :saleId AND p.status = 'PAID'")
    BigDecimal getTotalPaidAmountBySale(@Param("saleId") Long saleId);

    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate " +
            "AND p.status = 'PAID'")
    BigDecimal getTotalPaymentsByDateRange(
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(p.amount) FROM Payment p WHERE p.paymentDate BETWEEN :startDate AND :endDate " +
            "AND p.paymentMethod = :method AND p.status = 'PAID'")
    BigDecimal getTotalPaymentsByMethodAndDateRange(
            @Param("method") PaymentMethod method,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT COUNT(p) FROM Payment p WHERE p.paymentMethod = :method " +
            "AND p.paymentDate BETWEEN :startDate AND :endDate")
    Long countByMethodAndDateRange(
            @Param("method") PaymentMethod method,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\PrescriptionRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.CustomerPrescription;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PrescriptionRepository extends JpaRepository<CustomerPrescription, Long> {
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\ReturnInvoiceDataRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.ReturnInvoiceData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ReturnInvoiceDataRepository extends JpaRepository<ReturnInvoiceData, Long> {
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\SaleItemRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.SaleItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface SaleItemRepository extends JpaRepository<SaleItem, Long> {
    List<SaleItem> findBySaleId(Long saleId);
    List<SaleItem> findByProductId(Long productId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\SaleRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.Sale;
import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.SaleStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface SaleRepository extends JpaRepository<Sale, Long>, JpaSpecificationExecutor<Sale> {

    Optional<Sale> findBySaleNumber(String saleNumber);

    List<Sale> findByCustomerId(Long customerId);

    List<Sale> findByBranchId(Long branchId);

    List<Sale> findByStatus(SaleStatus status);

    List<Sale> findBySaleDateBetween(LocalDateTime startDate, LocalDateTime endDate);

    List<Sale> findByBranchIdAndStatus(Long branchId, SaleStatus status);

    List<Sale> findByCustomerIdAndStatus(Long customerId, SaleStatus status);

    @Query("SELECT s FROM Sale s WHERE s.branch.id = :branchId " +
            "AND s.saleDate BETWEEN :startDate AND :endDate")
    List<Sale> findByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT s FROM Sale s WHERE s.customer.id = :customerId " +
            "AND s.saleDate BETWEEN :startDate AND :endDate")
    List<Sale> findByCustomerAndDateRange(
            @Param("customerId") Long customerId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT s FROM Sale s WHERE s.soldBy.id = :userId " +
            "AND s.saleDate BETWEEN :startDate AND :endDate")
    List<Sale> findBySoldByAndDateRange(
            @Param("userId") Long userId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT SUM(s.totalAmount) FROM Sale s WHERE s.branch.id = :branchId " +
            "AND s.saleDate BETWEEN :startDate AND :endDate AND s.status = 'COMPLETED'")
    BigDecimal getTotalSalesByBranchAndDate(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT SUM(s.totalAmount - s.subtotal + s.discountAmount) FROM Sale s WHERE s.branch.id = :branchId " +
            "AND s.saleDate BETWEEN :startDate AND :endDate AND s.status = 'COMPLETED'")
    BigDecimal getTotalProfitByBranchAndDate(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT SUM(s.totalAmount) FROM Sale s WHERE s.customer.id = :customerId " +
            "AND s.status = 'COMPLETED'")
    BigDecimal getTotalSalesByCustomer(@Param("customerId") Long customerId);

    @Query("SELECT COUNT(s) FROM Sale s WHERE s.branch.id = :branchId " +
            "AND s.saleDate BETWEEN :startDate AND :endDate")
    Long countSalesByBranchAndDate(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT COUNT(s) FROM Sale s WHERE s.status = :status")
    Long countByStatus(@Param("status") SaleStatus status);

    @Query("SELECT s FROM Sale s WHERE s.status = 'PENDING' " +
            "AND s.branch.id = :branchId ORDER BY s.saleDate DESC")
    List<Sale> findPendingSalesByBranch(@Param("branchId") Long branchId);

    @Query("SELECT s FROM Sale s WHERE s.status = 'COMPLETED' " +
            "AND s.branch.id = :branchId " +
            "ORDER BY s.saleDate DESC")
    List<Sale> findRecentCompletedSales(@Param("branchId") Long branchId);

    @Query("SELECT AVG(s.totalAmount) FROM Sale s WHERE s.branch.id = :branchId " +
            "AND s.saleDate BETWEEN :startDate AND :endDate AND s.status = 'COMPLETED'")
    BigDecimal getAverageTransactionValue(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    boolean existsBySaleNumber(String saleNumber);

    @Query("SELECT s FROM Sale s WHERE s.branch.id = :branchId " +
            "AND s.saleDate BETWEEN :startDate AND :endDate")
    List<Sale> findByBranchIdAndSaleDateBetween(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate);

    @Query("SELECT s FROM Sale s JOIN s.saleItems si " +
            "WHERE si.product.id = :productId AND s.branch.id = :branchId " +
            "AND s.status = 'COMPLETED' ORDER BY s.saleDate DESC")
    Optional<Sale> findLastSaleForProduct(
            @Param("productId") Long productId,
            @Param("branchId") Long branchId);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\SaleReturnItemRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.SaleReturnItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface SaleReturnItemRepository extends JpaRepository<SaleReturnItem, Long> {
    List<SaleReturnItem> findBySaleReturnId(Long saleReturnId);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\pos\SaleReturnRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.pos;

import com.pharmacy.medlan.model.pos.SaleReturn;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface SaleReturnRepository extends JpaRepository<SaleReturn, Long> {
    Optional<SaleReturn> findByReturnNumber(String returnNumber);
    List<SaleReturn> findByCustomerId(Long customerId);
    List<SaleReturn> findByBranchId(Long branchId);
    List<SaleReturn> findByReturnDateBetween(LocalDate startDate, LocalDate endDate);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\product\BranchInventoryRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.product;

import com.pharmacy.medlan.model.product.BranchInventory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface BranchInventoryRepository extends JpaRepository<BranchInventory, Long> {

    Optional<BranchInventory> findByProductIdAndBranchId(Long productId, Long branchId);

    List<BranchInventory> findByBranchId(Long branchId);

    Page<BranchInventory> findByBranchId(Long branchId, Pageable pageable);

    List<BranchInventory> findByProductId(Long productId);

    @Query("SELECT bi FROM BranchInventory bi WHERE bi.branch.id = :branchId " +
            "AND bi.quantityAvailable < bi.reorderLevel")
    List<BranchInventory> findLowStockItems(@Param("branchId") Long branchId);

    @Query("SELECT bi FROM BranchInventory bi WHERE bi.branch.id = :branchId " +
            "AND bi.quantityAvailable < bi.reorderLevel AND bi.quantityAvailable > 0")
    List<BranchInventory> findLowStockByBranch(@Param("branchId") Long branchId);

    @Query("SELECT bi FROM BranchInventory bi WHERE bi.branch.id = :branchId " +
            "AND bi.quantityAvailable <= 0")
    List<BranchInventory> findOutOfStockByBranch(@Param("branchId") Long branchId);

    @Query("SELECT SUM(bi.quantityOnHand) FROM BranchInventory bi WHERE bi.product.id = :productId")
    Integer getTotalStockByProduct(@Param("productId") Long productId);

    @Query("SELECT bi FROM BranchInventory bi WHERE bi.quantityAvailable < bi.reorderLevel AND bi.quantityAvailable > 0")
    List<BranchInventory> findAllLowStock();

    @Query("SELECT bi FROM BranchInventory bi WHERE bi.quantityAvailable <= 0")
    List<BranchInventory> findAllOutOfStock();
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\product\CategoryRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.product;

import com.pharmacy.medlan.model.product.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long>, JpaSpecificationExecutor<Category> {

    Optional<Category> findByCategoryName(String categoryName);

    Optional<Category> findByCategoryCode(String categoryCode);

    List<Category> findByIsActiveTrue();

    List<Category> findByIsActiveFalse();

    @Query("SELECT c FROM Category c WHERE " +
            "(LOWER(c.categoryName) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(c.categoryCode) LIKE LOWER(CONCAT('%', :search, '%')))")
    List<Category> searchCategories(@Param("search") String search);

    @Query("SELECT c FROM Category c WHERE c.isActive = true ORDER BY c.categoryName ASC")
    List<Category> findAllActiveOrderByName();

    @Query("SELECT COUNT(c) FROM Category c WHERE c.isActive = true")
    Long countActiveCategories();

    @Query("SELECT c FROM Category c LEFT JOIN FETCH c.subCategories WHERE c.id = :id")
    Optional<Category> findByIdWithSubCategories(@Param("id") Long id);

    boolean existsByCategoryName(String categoryName);

    boolean existsByCategoryCode(String categoryCode);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\product\InventoryBatchRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.product;

import com.pharmacy.medlan.model.product.InventoryBatch;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface InventoryBatchRepository extends JpaRepository<InventoryBatch, Long> {

    /**
     * Find all batches for a branch
     */
    List<InventoryBatch> findByBranchId(Long branchId);
    
    /**
     * Find all active batches for a branch
     */
    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.branch.id = :branchId AND ib.isActive = true")
    List<InventoryBatch> findAllByBranchId(@Param("branchId") Long branchId);

    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.product.id = :productId " +
            "AND ib.branch.id = :branchId AND ib.isActive = true " +
            "AND ib.quantityAvailable > 0 ORDER BY ib.expiryDate ASC")
    List<InventoryBatch> findAvailableBatchesByProductOrderByExpiryDateAsc(
            @Param("productId") Long productId, @Param("branchId") Long branchId);

    /**
     * Alias for FEFO-sorted available batches
     */
    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.product.id = :productId " +
            "AND ib.branch.id = :branchId AND ib.isActive = true " +
            "AND ib.isExpired = false AND ib.quantityAvailable > 0 " +
            "ORDER BY ib.expiryDate ASC")
    List<InventoryBatch> findAvailableBatchesByProductAndBranch(
            @Param("productId") Long productId, @Param("branchId") Long branchId);

    /**
     * Get all batches including expired for audit/stock-taking
     */
    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.product.id = :productId " +
            "AND ib.branch.id = :branchId ORDER BY ib.expiryDate ASC")
    List<InventoryBatch> findAllByProductIdAndBranchId(
            @Param("productId") Long productId, @Param("branchId") Long branchId);

    List<InventoryBatch> findByProductIdAndBranchId(Long productId, Long branchId);

    Optional<InventoryBatch> findByProductIdAndBranchIdAndBatchNumber(
            Long productId, Long branchId, String batchNumber);

    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.expiryDate < :date " +
            "AND ib.isActive = true AND ib.quantityAvailable > 0")
    List<InventoryBatch> findExpiredBatches(@Param("date") LocalDate date);

    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.expiryDate BETWEEN :startDate AND :endDate " +
            "AND ib.isActive = true AND ib.quantityAvailable > 0")
    List<InventoryBatch> findBatchesExpiringBetween(
            @Param("startDate") LocalDate startDate, @Param("endDate") LocalDate endDate);

    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.branch.id = :branchId " +
            "AND ib.expiryDate <= :alertDate AND ib.isActive = true " +
            "AND ib.quantityAvailable > 0 ORDER BY ib.expiryDate ASC")
    List<InventoryBatch> findExpiringBatchesForAlert(
            @Param("branchId") Long branchId, @Param("alertDate") LocalDate alertDate);

    /**
     * Find batches expiring within specified days
     */
    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.branch.id = :branchId " +
            "AND ib.expiryDate BETWEEN CURRENT_DATE AND :maxDate " +
            "AND ib.isActive = true AND ib.quantityAvailable > 0 " +
            "ORDER BY ib.expiryDate ASC")
    List<InventoryBatch> findBatchesExpiringWithin(
            @Param("branchId") Long branchId, @Param("maxDate") LocalDate maxDate);

    @Query("SELECT COUNT(ib) FROM InventoryBatch ib WHERE ib.branch.id = :branchId " +
            "AND ib.expiryDate BETWEEN :startDate AND :endDate " +
            "AND ib.isActive = true AND ib.quantityAvailable > 0")
    int countByBranchIdAndExpiryDateBetween(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    /**
     * Find already expired batches by branch
     */
    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.branch.id = :branchId " +
            "AND ib.expiryDate < CURRENT_DATE AND ib.quantityAvailable > 0")
    List<InventoryBatch> findExpiredBatchesByBranch(@Param("branchId") Long branchId);

    /**
     * Count expired batches by branch
     */
    @Query("SELECT COUNT(ib) FROM InventoryBatch ib WHERE ib.branch.id = :branchId " +
            "AND ib.expiryDate < CURRENT_DATE AND ib.quantityAvailable > 0")
    Long countExpiredBatchesByBranch(@Param("branchId") Long branchId);

    /**
     * Find all expiring batches across all branches (paginated)
     */
    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.expiryDate BETWEEN CURRENT_DATE AND :alertDate " +
            "AND ib.isActive = true AND ib.quantityAvailable > 0 ORDER BY ib.expiryDate ASC")
    org.springframework.data.domain.Page<InventoryBatch> findAllExpiringBatches(
            @Param("alertDate") LocalDate alertDate, 
            org.springframework.data.domain.Pageable pageable);

    /**
     * Find all expired batches across all branches (paginated)
     */
    @Query("SELECT ib FROM InventoryBatch ib WHERE ib.expiryDate < :date " +
            "AND ib.isActive = true AND ib.quantityAvailable > 0 ORDER BY ib.expiryDate ASC")
    org.springframework.data.domain.Page<InventoryBatch> findAllExpiredBatches(
            @Param("date") LocalDate date, 
            org.springframework.data.domain.Pageable pageable);

    /**
     * Get total available quantity for a product across all branches
     */
    @Query("SELECT COALESCE(SUM(ib.quantityAvailable), 0) FROM InventoryBatch ib " +
            "WHERE ib.product.id = :productId AND ib.isActive = true AND ib.isExpired = false")
    Integer getTotalAvailableQuantity(@Param("productId") Long productId);

    /**
     * Get total available quantity for a product at a specific branch
     */
    @Query("SELECT COALESCE(SUM(ib.quantityAvailable), 0) FROM InventoryBatch ib " +
            "WHERE ib.product.id = :productId AND ib.branch.id = :branchId " +
            "AND ib.isActive = true AND ib.isExpired = false")
    Integer getTotalAvailableQuantityAtBranch(
            @Param("productId") Long productId, @Param("branchId") Long branchId);
    
    /**
     * Alias method for scheduler - sum available quantity
     */
    @Query("SELECT COALESCE(SUM(ib.quantityAvailable), 0) FROM InventoryBatch ib " +
            "WHERE ib.product.id = :productId AND ib.branch.id = :branchId " +
            "AND ib.isActive = true AND ib.isExpired = false")
    Integer sumAvailableQuantityByProductAndBranch(
            @Param("productId") Long productId, @Param("branchId") Long branchId);
    
    /**
     * Find batches expiring between dates for scheduler
     */
    List<InventoryBatch> findByExpiryDateBetweenAndIsActiveAndIsExpired(
            LocalDate startDate, LocalDate endDate, Boolean isActive, Boolean isExpired);
    
    /**
     * Find expired batches that haven't been marked yet
     */
    List<InventoryBatch> findByExpiryDateBeforeAndIsExpiredFalse(LocalDate date);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\product\ProductPricingRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.product;

import com.pharmacy.medlan.model.product.ProductPricing;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface ProductPricingRepository extends JpaRepository<ProductPricing, Long> {
    List<ProductPricing> findByProductId(Long productId);

    @Query("SELECT pp FROM ProductPricing pp WHERE pp.product.id = :productId " +
            "AND pp.isCurrent = true")
    Optional<ProductPricing> findCurrentPricingByProduct(Long productId);

    List<ProductPricing> findByProductIdAndEffectiveDateBetween(
            Long productId, LocalDate startDate, LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\product\ProductRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.product;

import com.pharmacy.medlan.model.product.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {
    Optional<Product> findByProductCode(String productCode);
    Optional<Product> findByBarcode(String barcode);
    List<Product> findByIsActiveTrue();
    List<Product> findByCategoryId(Long categoryId);
    List<Product> findBySubCategoryId(Long subCategoryId);

    @Query("SELECT p FROM Product p WHERE p.isActive = true AND " +
            "(LOWER(p.productName) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(p.genericName) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(p.productCode) LIKE LOWER(CONCAT('%', :search, '%')))")
    List<Product> searchProducts(@Param("search") String search);

    @Query("SELECT p FROM Product p JOIN p.branchInventories bi " +
            "WHERE bi.branch.id = :branchId AND bi.quantityAvailable < p.reorderLevel")
    List<Product> findLowStockProducts(@Param("branchId") Long branchId);
    
    /**
     * Find all products that have inventory in a specific branch
     */
    @Query("SELECT DISTINCT p FROM Product p JOIN p.branchInventories bi WHERE bi.branch.id = :branchId")
    List<Product> findByBranchId(@Param("branchId") Long branchId);

    boolean existsByProductCode(String productCode);
    boolean existsByBarcode(String barcode);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\product\SubCategoryRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.product;

import com.pharmacy.medlan.model.product.SubCategory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface SubCategoryRepository extends JpaRepository<SubCategory, Long> {
    Optional<SubCategory> findBySubCategoryName(String subCategoryName);
    Optional<SubCategory> findBySubCategoryCode(String subCategoryCode);
    List<SubCategory> findByCategoryId(Long categoryId);
    List<SubCategory> findByIsActiveTrue();
    boolean existsBySubCategoryName(String subCategoryName);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\product\TaxCategoryRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.product;

import com.pharmacy.medlan.model.product.TaxCategory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface TaxCategoryRepository extends JpaRepository<TaxCategory, Long> {
    Optional<TaxCategory> findByTaxName(String taxName);
    List<TaxCategory> findByIsActiveTrue();
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\product\UnitRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.product;

import com.pharmacy.medlan.model.product.Unit;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface UnitRepository extends JpaRepository<Unit, Long> {
    Optional<Unit> findByUnitName(String unitName);
    Optional<Unit> findByUnitCode(String unitCode);
    List<Unit> findByIsActiveTrue();
    boolean existsByUnitName(String unitName);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\report\DailySalesSummaryRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.report;

import com.pharmacy.medlan.model.report.DailySalesSummary;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface DailySalesSummaryRepository extends JpaRepository<DailySalesSummary, Long> {
    Optional<DailySalesSummary> findByBranchIdAndSummaryDate(Long branchId, LocalDate summaryDate);
    List<DailySalesSummary> findByBranchId(Long branchId);
    List<DailySalesSummary> findBySummaryDateBetween(LocalDate startDate, LocalDate endDate);
    List<DailySalesSummary> findByBranchIdAndSummaryDateBetween(Long branchId, LocalDate startDate, LocalDate endDate);

    @Query("SELECT SUM(dss.totalSalesAmount) FROM DailySalesSummary dss " +
            "WHERE dss.branch.id = :branchId AND dss.summaryDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalSalesByBranchAndDateRange(Long branchId, LocalDate startDate, LocalDate endDate);

    @Query("SELECT SUM(dss.totalProfit) FROM DailySalesSummary dss " +
            "WHERE dss.branch.id = :branchId AND dss.summaryDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalProfitByBranchAndDateRange(Long branchId, LocalDate startDate, LocalDate endDate);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\report\ExpiryAlertRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.report;

import com.pharmacy.medlan.model.report.ExpiryAlert;
import com.pharmacy.medlan.enums.AlertLevel;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.time.LocalDate;
import java.util.List;

@Repository
public interface ExpiryAlertRepository extends JpaRepository<ExpiryAlert, Long> {
    List<ExpiryAlert> findByProductId(Long productId);
    List<ExpiryAlert> findByBranchId(Long branchId);
    List<ExpiryAlert> findByAlertLevel(AlertLevel alertLevel);
    List<ExpiryAlert> findByIsAcknowledgedFalse();
    List<ExpiryAlert> findByExpiryDateBefore(LocalDate date);

    @Query("SELECT ea FROM ExpiryAlert ea WHERE ea.branch.id = :branchId " +
            "AND ea.isAcknowledged = false ORDER BY ea.expiryDate ASC, ea.alertLevel DESC")
    List<ExpiryAlert> findUnacknowledgedAlertsByBranch(Long branchId);

    @Query("SELECT ea FROM ExpiryAlert ea WHERE ea.branch.id = :branchId " +
            "AND ea.expiryDate BETWEEN :startDate AND :endDate")
    List<ExpiryAlert> findByBranchAndExpiryDateRange(Long branchId, LocalDate startDate, LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\report\LowStockAlertRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.report;

import com.pharmacy.medlan.model.report.LowStockAlert;
import com.pharmacy.medlan.enums.AlertLevel;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface LowStockAlertRepository extends JpaRepository<LowStockAlert, Long> {
    List<LowStockAlert> findByProductId(Long productId);
    List<LowStockAlert> findByBranchId(Long branchId);
    List<LowStockAlert> findByAlertLevel(AlertLevel alertLevel);
    List<LowStockAlert> findByIsAcknowledgedFalse();

    @Query("SELECT lsa FROM LowStockAlert lsa WHERE lsa.branch.id = :branchId " +
            "AND lsa.isAcknowledged = false ORDER BY lsa.alertLevel DESC, lsa.alertGeneratedAt ASC")
    List<LowStockAlert> findUnacknowledgedAlertsByBranch(Long branchId);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\supplier\GoodsReceiptItemRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.supplier;

import com.pharmacy.medlan.model.supplier.GoodsReceiptItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface GoodsReceiptItemRepository extends JpaRepository<GoodsReceiptItem, Long> {

    List<GoodsReceiptItem> findByGoodsReceiptId(Long goodsReceiptId);

    List<GoodsReceiptItem> findByProductId(Long productId);

    Optional<GoodsReceiptItem> findByGoodsReceiptIdAndProductIdAndBatchNumber(
            Long goodsReceiptId, Long productId, String batchNumber);

    @Query("SELECT gri FROM GoodsReceiptItem gri WHERE gri.product.id = :productId " +
            "AND gri.batchNumber = :batchNumber")
    List<GoodsReceiptItem> findByProductAndBatch(
            @Param("productId") Long productId,
            @Param("batchNumber") String batchNumber);

    @Query("SELECT gri FROM GoodsReceiptItem gri WHERE gri.expiryDate < :date")
    List<GoodsReceiptItem> findExpiredBatches(@Param("date") LocalDate date);

    @Query("SELECT gri FROM GoodsReceiptItem gri WHERE gri.expiryDate BETWEEN :startDate AND :endDate")
    List<GoodsReceiptItem> findBatchesExpiringBetween(
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(gri.totalAmount) FROM GoodsReceiptItem gri " +
            "WHERE gri.goodsReceipt.id = :receiptId")
    BigDecimal getTotalAmountByReceipt(@Param("receiptId") Long receiptId);

    @Query("SELECT SUM(gri.quantityReceived) FROM GoodsReceiptItem gri " +
            "WHERE gri.product.id = :productId " +
            "AND gri.goodsReceipt.receiptDate BETWEEN :startDate AND :endDate")
    Integer getTotalReceivedQuantityByProductAndDateRange(
            @Param("productId") Long productId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT DISTINCT gri.batchNumber FROM GoodsReceiptItem gri " +
            "WHERE gri.product.id = :productId")
    List<String> findAllBatchNumbersByProduct(@Param("productId") Long productId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\supplier\GoodsReceiptRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.supplier;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.model.supplier.GoodsReceipt;

@Repository
public interface GoodsReceiptRepository extends JpaRepository<GoodsReceipt, Long>, JpaSpecificationExecutor<GoodsReceipt> {

    Optional<GoodsReceipt> findByReceiptNumber(String receiptNumber);

    List<GoodsReceipt> findBySupplierId(Long supplierId);

    List<GoodsReceipt> findByBranchId(Long branchId);

    List<GoodsReceipt> findByPurchaseOrderId(Long purchaseOrderId);

    List<GoodsReceipt> findByReceiptDateBetween(LocalDate startDate, LocalDate endDate);

    @Query("SELECT gr FROM GoodsReceipt gr WHERE gr.supplier.id = :supplierId " +
            "AND gr.receiptDate BETWEEN :startDate AND :endDate")
    List<GoodsReceipt> findBySupplierAndDateRange(
            @Param("supplierId") Long supplierId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT gr FROM GoodsReceipt gr WHERE gr.branch.id = :branchId " +
            "AND gr.receiptDate BETWEEN :startDate AND :endDate")
    List<GoodsReceipt> findByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(gr.totalAmount) FROM GoodsReceipt gr WHERE gr.supplier.id = :supplierId " +
            "AND gr.receiptDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalReceiptsBySupplierAndDateRange(
            @Param("supplierId") Long supplierId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(gr.totalAmount) FROM GoodsReceipt gr WHERE gr.branch.id = :branchId " +
            "AND gr.receiptDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalReceiptsByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT gr FROM GoodsReceipt gr WHERE gr.supplierInvoiceNumber = :invoiceNumber " +
            "AND gr.supplier.id = :supplierId")
    Optional<GoodsReceipt> findBySupplierInvoice(
            @Param("invoiceNumber") String invoiceNumber,
            @Param("supplierId") Long supplierId);

    boolean existsByReceiptNumber(String receiptNumber);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\supplier\PurchaseOrderItemRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.supplier;

import com.pharmacy.medlan.model.supplier.PurchaseOrderItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Repository
public interface PurchaseOrderItemRepository extends JpaRepository<PurchaseOrderItem, Long> {

    List<PurchaseOrderItem> findByPurchaseOrderId(Long purchaseOrderId);

    List<PurchaseOrderItem> findByProductId(Long productId);

    Optional<PurchaseOrderItem> findByPurchaseOrderIdAndProductId(Long purchaseOrderId, Long productId);

    @Query("SELECT poi FROM PurchaseOrderItem poi WHERE poi.purchaseOrder.id = :purchaseOrderId " +
            "AND poi.quantityOrdered > poi.quantityReceived")
    List<PurchaseOrderItem> findPendingReceiptItems(@Param("purchaseOrderId") Long purchaseOrderId);

    @Query("SELECT SUM(poi.totalAmount) FROM PurchaseOrderItem poi " +
            "WHERE poi.purchaseOrder.id = :purchaseOrderId")
    BigDecimal getTotalAmountByPurchaseOrder(@Param("purchaseOrderId") Long purchaseOrderId);

    @Query("SELECT SUM(poi.quantityOrdered) FROM PurchaseOrderItem poi " +
            "WHERE poi.product.id = :productId " +
            "AND poi.purchaseOrder.status = 'APPROVED'")
    Integer getTotalOrderedQuantityByProduct(@Param("productId") Long productId);

    @Query("SELECT poi FROM PurchaseOrderItem poi " +
            "WHERE poi.purchaseOrder.supplier.id = :supplierId " +
            "AND poi.purchaseOrder.status = 'APPROVED' " +
            "AND poi.quantityOrdered > poi.quantityReceived")
    List<PurchaseOrderItem> findPendingItemsBySupplier(@Param("supplierId") Long supplierId);

    @Query("SELECT SUM(poi.quantityOrdered - poi.quantityReceived) FROM PurchaseOrderItem poi " +
            "WHERE poi.product.id = :productId " +
            "AND poi.purchaseOrder.status IN ('APPROVED', 'PARTIALLY_RECEIVED')")
    Integer getPendingQuantityByProduct(@Param("productId") Long productId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\supplier\PurchaseOrderRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.supplier;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.PurchaseOrderStatus;
import com.pharmacy.medlan.model.supplier.PurchaseOrder;

@Repository
public interface PurchaseOrderRepository extends JpaRepository<PurchaseOrder, Long>, JpaSpecificationExecutor<PurchaseOrder> {

    Optional<PurchaseOrder> findByPoNumber(String poNumber);

    List<PurchaseOrder> findBySupplierId(Long supplierId);

    List<PurchaseOrder> findByBranchId(Long branchId);

    List<PurchaseOrder> findByStatus(PurchaseOrderStatus status);

    List<PurchaseOrder> findByOrderDateBetween(LocalDate startDate, LocalDate endDate);

    List<PurchaseOrder> findBySupplierIdAndStatus(Long supplierId, PurchaseOrderStatus status);

    List<PurchaseOrder> findByBranchIdAndStatus(Long branchId, PurchaseOrderStatus status);

    @Query("SELECT po FROM PurchaseOrder po WHERE po.status = :status " +
            "AND po.expectedDeliveryDate < :date")
    List<PurchaseOrder> findOverduePurchaseOrders(
            @Param("status") PurchaseOrderStatus status,
            @Param("date") LocalDate date);

    @Query("SELECT po FROM PurchaseOrder po WHERE po.branch.id = :branchId " +
            "AND po.orderDate BETWEEN :startDate AND :endDate")
    List<PurchaseOrder> findByBranchAndDateRange(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(po.totalAmount) FROM PurchaseOrder po WHERE po.supplier.id = :supplierId " +
            "AND po.orderDate BETWEEN :startDate AND :endDate")
    BigDecimal getTotalOrderAmountBySupplier(
            @Param("supplierId") Long supplierId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(po.totalAmount) FROM PurchaseOrder po WHERE po.branch.id = :branchId " +
            "AND po.orderDate BETWEEN :startDate AND :endDate " +
            "AND po.status IN ('APPROVED', 'PARTIALLY_RECEIVED', 'COMPLETED')")
    BigDecimal getTotalPurchasesByBranch(
            @Param("branchId") Long branchId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT COUNT(po) FROM PurchaseOrder po WHERE po.status = :status")
    Long countByStatus(@Param("status") PurchaseOrderStatus status);

    @Query("SELECT po FROM PurchaseOrder po WHERE po.status = 'DRAFT' " +
            "AND po.createdByUser.id = :userId")
    List<PurchaseOrder> findDraftOrdersByUser(@Param("userId") Long userId);

    @Query("SELECT po FROM PurchaseOrder po WHERE po.status = 'PENDING_APPROVAL'")
    List<PurchaseOrder> findPendingApprovalOrders();

    boolean existsByPoNumber(String poNumber);

    @Query("SELECT COUNT(po) FROM PurchaseOrder po WHERE po.branch.id = :branchId " +
            "AND CAST(po.status AS string) = :status")
    int countByBranchIdAndStatus(
            @Param("branchId") Long branchId,
            @Param("status") String status);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\supplier\SupplierPaymentDetailRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.supplier;

import com.pharmacy.medlan.model.supplier.SupplierPaymentDetail;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

@Repository
public interface SupplierPaymentDetailRepository extends JpaRepository<SupplierPaymentDetail, Long> {

    List<SupplierPaymentDetail> findBySupplierPaymentId(Long supplierPaymentId);

    List<SupplierPaymentDetail> findByGrnId(Long grnId);

    Optional<SupplierPaymentDetail> findBySupplierPaymentIdAndGrnId(Long supplierPaymentId, Long grnId);

    @Query("SELECT spd FROM SupplierPaymentDetail spd WHERE spd.invoiceNumber = :invoiceNumber")
    List<SupplierPaymentDetail> findByInvoiceNumber(@Param("invoiceNumber") String invoiceNumber);

    @Query("SELECT SUM(spd.paidAmount) FROM SupplierPaymentDetail spd " +
            "WHERE spd.grn.id = :grnId")
    BigDecimal getTotalPaidAmountByGrn(@Param("grnId") Long grnId);

    @Query("SELECT SUM(spd.paidAmount) FROM SupplierPaymentDetail spd " +
            "WHERE spd.supplierPayment.id = :paymentId")
    BigDecimal getTotalPaidAmountByPayment(@Param("paymentId") Long paymentId);

    @Query("SELECT spd FROM SupplierPaymentDetail spd " +
            "WHERE spd.supplierPayment.supplier.id = :supplierId")
    List<SupplierPaymentDetail> findBySupplier(@Param("supplierId") Long supplierId);

    @Query("SELECT spd FROM SupplierPaymentDetail spd " +
            "WHERE spd.balanceAmount > 0")
    List<SupplierPaymentDetail> findWithPendingBalance();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\supplier\SupplierPaymentRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.supplier;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.enums.PaymentMethod;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.model.supplier.SupplierPayment;

@Repository
public interface SupplierPaymentRepository extends JpaRepository<SupplierPayment, Long>, JpaSpecificationExecutor<SupplierPayment> {

    Optional<SupplierPayment> findByPaymentNumber(String paymentNumber);

    List<SupplierPayment> findBySupplierId(Long supplierId);

    List<SupplierPayment> findByPaymentMethod(PaymentMethod paymentMethod);

    List<SupplierPayment> findByStatus(PaymentStatus status);

    List<SupplierPayment> findByPaymentDateBetween(LocalDate startDate, LocalDate endDate);

    List<SupplierPayment> findBySupplierIdAndPaymentDateBetween(
            Long supplierId, LocalDate startDate, LocalDate endDate);

    @Query("SELECT sp FROM SupplierPayment sp WHERE sp.supplier.id = :supplierId " +
            "ORDER BY sp.paymentDate DESC")
    List<SupplierPayment> findPaymentsBySupplier(@Param("supplierId") Long supplierId);

    @Query("SELECT SUM(sp.amount) FROM SupplierPayment sp WHERE sp.supplier.id = :supplierId " +
            "AND sp.status = 'PAID'")
    BigDecimal getTotalPaymentsBySupplier(@Param("supplierId") Long supplierId);

    @Query("SELECT SUM(sp.amount) FROM SupplierPayment sp WHERE sp.paymentDate BETWEEN :startDate AND :endDate " +
            "AND sp.status = 'PAID'")
    BigDecimal getTotalPaymentsByDateRange(
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT SUM(sp.amount) FROM SupplierPayment sp WHERE sp.supplier.id = :supplierId " +
            "AND sp.paymentDate BETWEEN :startDate AND :endDate AND sp.status = 'PAID'")
    BigDecimal getTotalPaymentsBySupplierAndDateRange(
            @Param("supplierId") Long supplierId,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    @Query("SELECT sp FROM SupplierPayment sp WHERE sp.chequeNumber = :chequeNumber")
    Optional<SupplierPayment> findByChequeNumber(@Param("chequeNumber") String chequeNumber);

    @Query("SELECT sp FROM SupplierPayment sp WHERE sp.status = 'PENDING'")
    List<SupplierPayment> findPendingPayments();

    @Query("SELECT COUNT(sp) FROM SupplierPayment sp WHERE sp.paymentMethod = :method " +
            "AND sp.paymentDate BETWEEN :startDate AND :endDate")
    Long countByMethodAndDateRange(
            @Param("method") PaymentMethod method,
            @Param("startDate") LocalDate startDate,
            @Param("endDate") LocalDate endDate);

    boolean existsByPaymentNumber(String paymentNumber);

    boolean existsByChequeNumber(String chequeNumber);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\supplier\SupplierRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.supplier;

import java.math.BigDecimal;
import java.util.List;
import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import com.pharmacy.medlan.model.supplier.Supplier;

@Repository
public interface SupplierRepository extends JpaRepository<Supplier, Long>, JpaSpecificationExecutor<Supplier> {

    Optional<Supplier> findBySupplierCode(String supplierCode);

    Optional<Supplier> findBySupplierName(String supplierName);

    Optional<Supplier> findByEmail(String email);

    Optional<Supplier> findByGstinNumber(String gstinNumber);

    Optional<Supplier> findByDrugLicenseNumber(String drugLicenseNumber);

    List<Supplier> findByIsActiveTrue();

    List<Supplier> findByIsActiveFalse();

    List<Supplier> findByCity(String city);

    List<Supplier> findByState(String state);

    @Query("SELECT s FROM Supplier s WHERE " +
            "(LOWER(s.supplierName) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(s.supplierCode) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(s.contactPerson) LIKE LOWER(CONCAT('%', :search, '%')) OR " +
            "LOWER(s.email) LIKE LOWER(CONCAT('%', :search, '%')))")
    List<Supplier> searchSuppliers(@Param("search") String search);

    @Query("SELECT s FROM Supplier s WHERE s.isActive = true AND " +
            "s.currentBalance > 0 ORDER BY s.currentBalance DESC")
    List<Supplier> findSuppliersWithOutstandingBalance();

    @Query("SELECT s FROM Supplier s WHERE s.isActive = true AND " +
            "s.currentBalance >= s.creditLimit")
    List<Supplier> findSuppliersExceedingCreditLimit();

    @Query("SELECT SUM(s.currentBalance) FROM Supplier s WHERE s.isActive = true")
    BigDecimal getTotalOutstandingBalance();

    @Query("SELECT COUNT(s) FROM Supplier s WHERE s.isActive = true")
    Long countActiveSuppliers();

    boolean existsBySupplierCode(String supplierCode);

    boolean existsByEmail(String email);

    boolean existsByGstinNumber(String gstinNumber);

    boolean existsByDrugLicenseNumber(String drugLicenseNumber);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\system\SystemConfigRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.system;

import com.pharmacy.medlan.model.system.SystemConfig;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface SystemConfigRepository extends JpaRepository<SystemConfig, Long> {
    Optional<SystemConfig> findByConfigKey(String configKey);
    List<SystemConfig> findByCategory(String category);
    List<SystemConfig> findByIsEditableTrue();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\user\BranchStaffRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.user;

import com.pharmacy.medlan.model.user.BranchStaff;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface BranchStaffRepository extends JpaRepository<BranchStaff, Long> {
    List<BranchStaff> findByUserId(Long userId);
    List<BranchStaff> findByBranchId(Long branchId);
    List<BranchStaff> findByUserIdAndIsActiveTrue(Long userId);
    Optional<BranchStaff> findByUserIdAndBranchId(Long userId, Long branchId);
    Optional<BranchStaff> findByUserIdAndIsPrimaryBranchTrue(Long userId);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\user\EmployeeAuthorizationRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.user;

import com.pharmacy.medlan.model.user.EmployeeAuthorization;
import com.pharmacy.medlan.enums.AuthorizationStatus;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface EmployeeAuthorizationRepository extends JpaRepository<EmployeeAuthorization, Long> {
    List<EmployeeAuthorization> findByEmployeeId(Long employeeId);
    List<EmployeeAuthorization> findByStatus(AuthorizationStatus status);
    Optional<EmployeeAuthorization> findByAuthorizationCode(String authorizationCode);
    List<EmployeeAuthorization> findByEmployeeIdAndStatus(Long employeeId, AuthorizationStatus status);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\user\UserRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.user;

import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.enums.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    Optional<User> findByEmployeeCode(String employeeCode);
    List<User> findByRole(Role role);
    List<User> findByIsActiveTrue();

    @Query("SELECT u FROM User u JOIN u.branchAssignments bs WHERE bs.branch.id = :branchId")
    List<User> findUsersByBranch(@Param("branchId") Long branchId);
    
    /**
     * Find users by branch ID
     */
    @Query("SELECT u FROM User u JOIN u.branchAssignments ba WHERE ba.branch.id = :branchId AND u.isActive = true")
    List<User> findByBranchId(@Param("branchId") Long branchId);
    
    /**
     * Find users by branch ID and role
     */
    @Query("SELECT u FROM User u JOIN u.branchAssignments ba " +
           "WHERE ba.branch.id = :branchId AND u.role = :role AND u.isActive = true")
    List<User> findByBranchIdAndRole(@Param("branchId") Long branchId, @Param("role") String role);
    
    /**
     * Find users by branch ID and role enum
     */
    @Query("SELECT u FROM User u JOIN u.branchAssignments ba " +
           "WHERE ba.branch.id = :branchId AND u.role = :role AND u.isActive = true")
    List<User> findByBranchIdAndRoleEnum(@Param("branchId") Long branchId, @Param("role") Role role);
    
    /**
     * Find all managers
     */
    @Query("SELECT u FROM User u WHERE u.role IN ('ADMIN', 'OWNER', 'MANAGER') AND u.isActive = true")
    List<User> findAllManagers();
    
    /**
     * Count users by role
     */
    @Query("SELECT COUNT(u) FROM User u WHERE u.role = :role AND u.isActive = true")
    Long countByRole(@Param("role") Role role);
    
    /**
     * Find users by branch and multiple roles (for notifications)
     */
    @Query("SELECT DISTINCT u FROM User u JOIN u.branchAssignments ba " +
           "WHERE ba.branch.id = :branchId AND u.role IN :roles AND u.isActive = true")
    List<User> findByBranchIdAndRoleIn(@Param("branchId") Long branchId, @Param("roles") List<String> roles);

    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
    boolean existsByEmployeeCode(String employeeCode);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\repository\user\UserSessionRepository.java"   & echo.. 
package com.pharmacy.medlan.repository.user;

import com.pharmacy.medlan.model.user.UserSession;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface UserSessionRepository extends JpaRepository<UserSession, Long> {
    Optional<UserSession> findBySessionToken(String sessionToken);
    List<UserSession> findByUserIdAndIsActiveTrue(Long userId);

    @Query("SELECT us FROM UserSession us WHERE us.expiresAt < :now AND us.isActive = true")
    List<UserSession> findExpiredSessions(LocalDateTime now);

    void deleteByUserId(Long userId);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\scheduler\ExpiryAlertScheduler.java"   & echo.. 
package com.pharmacy.medlan.scheduler;

import com.pharmacy.medlan.enums.AlertLevel;
import com.pharmacy.medlan.enums.NotificationType;
import com.pharmacy.medlan.model.notification.Notification;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.notification.NotificationRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;

/**
 * Scheduler for monitoring and alerting about expiring inventory batches
 * Runs daily at 6 AM as configured in application.properties
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class ExpiryAlertScheduler {

    private final InventoryBatchRepository inventoryBatchRepository;
    private final NotificationRepository notificationRepository;
    private final UserRepository userRepository;

    /**
     * Daily expiry check - runs at 6 AM
     * Checks all active batches and creates alerts based on days to expiry:
     * - CRITICAL: 0-30 days (RED)
     * - HIGH: 31-60 days (ORANGE)  
     * - MEDIUM: 61-90 days (YELLOW)
     */
    @Scheduled(cron = "${scheduler.expiry.cron:0 0 6 * * ?}")
    @Transactional
    public void checkExpiringBatches() {
        log.info("=== Starting Expiry Alert Check ===");
        
        LocalDate today = LocalDate.now();
        LocalDate ninetyDaysFromNow = today.plusDays(90);
        
        // Get all active, non-expired batches expiring in next 90 days
        List<InventoryBatch> expiringBatches = inventoryBatchRepository
                .findByExpiryDateBetweenAndIsActiveAndIsExpired(
                        today, ninetyDaysFromNow, true, false);
        
        log.info("Found {} batches expiring in next 90 days", expiringBatches.size());
        
        int criticalCount = 0;
        int highCount = 0;
        int mediumCount = 0;
        
        for (InventoryBatch batch : expiringBatches) {
            long daysToExpiry = ChronoUnit.DAYS.between(today, batch.getExpiryDate());
            
            AlertLevel alertLevel;
            String alertMessage;
            
            if (daysToExpiry <= 30) {
                alertLevel = AlertLevel.CRITICAL;
                alertMessage = String.format(
                        "URGENT: Batch %s of %s expires in %d days! Quantity: %d",
                        batch.getBatchNumber(),
                        batch.getProduct().getProductName(),
                        daysToExpiry,
                        batch.getQuantityAvailable()
                );
                criticalCount++;
            } else if (daysToExpiry <= 60) {
                alertLevel = AlertLevel.URGENT;
                alertMessage = String.format(
                        "HIGH PRIORITY: Batch %s of %s expires in %d days. Quantity: %d - Consider discount/return",
                        batch.getBatchNumber(),
                        batch.getProduct().getProductName(),
                        daysToExpiry,
                        batch.getQuantityAvailable()
                );
                highCount++;
            } else {
                alertLevel = AlertLevel.WARNING;
                alertMessage = String.format(
                        "Batch %s of %s expires in %d days. Quantity: %d - Plan usage",
                        batch.getBatchNumber(),
                        batch.getProduct().getProductName(),
                        daysToExpiry,
                        batch.getQuantityAvailable()
                );
                mediumCount++;
            }
            
            // Create notification for branch managers and pharmacists
            createExpiryNotification(batch, alertLevel, alertMessage);
        }
        
        log.info("Expiry Alert Summary - Critical: {}, High: {}, Medium: {}",
                criticalCount, highCount, mediumCount);
        log.info("=== Expiry Alert Check Complete ===");
    }

    /**
     * Updates batch expiry status - marks expired batches
     * Runs daily at 1 AM as configured in application.properties
     */
    @Scheduled(cron = "${scheduler.update-expiry-status.cron:0 0 1 * * ?}")
    @Transactional
    public void updateExpiredBatches() {
        log.info("=== Updating Expired Batch Status ===");
        
        LocalDate today = LocalDate.now();
        
        // Find all active batches that have expired
        List<InventoryBatch> expiredBatches = inventoryBatchRepository
                .findByExpiryDateBeforeAndIsExpiredFalse(today);
        
        log.info("Found {} newly expired batches", expiredBatches.size());
        
        for (InventoryBatch batch : expiredBatches) {
            batch.setIsExpired(true);
            batch.setIsActive(false); // Block from sales
            
            String message = String.format(
                    "EXPIRED: Batch %s of %s has expired. Quantity: %d - Remove from inventory immediately!",
                    batch.getBatchNumber(),
                    batch.getProduct().getProductName(),
                    batch.getQuantityAvailable()
            );
            
            createExpiryNotification(batch, AlertLevel.CRITICAL, message);
            
            log.warn("Batch {} of product {} marked as EXPIRED", 
                    batch.getBatchNumber(), batch.getProduct().getProductCode());
        }
        
        inventoryBatchRepository.saveAll(expiredBatches);
        
        log.info("=== Expired Batch Status Update Complete ===");
    }

    private void createExpiryNotification(InventoryBatch batch, AlertLevel alertLevel, String message) {
        // Get all admins, branch managers, and pharmacists for the branch
        List<User> recipientUsers = userRepository
                .findByBranchIdAndRoleIn(
                        batch.getBranch().getId(),
                        List.of("ADMIN", "BRANCH_MANAGER", "PHARMACIST", "INVENTORY_MANAGER")
                );
        
        for (User user : recipientUsers) {
            Notification notification = Notification.builder()
                    .user(user)
                    .type(NotificationType.EXPIRY_ALERT)
                    .title("Product Expiry Alert")
                    .message(message)
                    .priority(alertLevel.name())
                    .referenceType("INVENTORY_BATCH")
                    .referenceId(batch.getId())
                    .isRead(false)
                    .build();
            
            notificationRepository.save(notification);
        }
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\scheduler\LowStockAlertScheduler.java"   & echo.. 
package com.pharmacy.medlan.scheduler;

import com.pharmacy.medlan.enums.AlertLevel;
import com.pharmacy.medlan.enums.NotificationType;
import com.pharmacy.medlan.model.notification.Notification;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.notification.NotificationRepository;
import com.pharmacy.medlan.repository.organization.BranchRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Scheduler for monitoring and alerting about low stock levels
 * Runs daily at 7 AM as configured in application.properties
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class LowStockAlertScheduler {

    private final ProductRepository productRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final BranchRepository branchRepository;
    private final NotificationRepository notificationRepository;
    private final UserRepository userRepository;

    /**
     * Daily low stock check - runs at 7 AM
     * Checks stock levels for all products in all branches
     * Creates alerts when stock falls below reorder level or minimum stock
     */
    @Scheduled(cron = "${scheduler.low-stock.cron:0 0 7 * * ?}")
    @Transactional
    public void checkLowStockLevels() {
        log.info("=== Starting Low Stock Alert Check ===");
        
        List<Branch> branches = branchRepository.findAll();
        List<Product> allProducts = productRepository.findByIsActiveTrue();
        
        int criticalCount = 0;
        int lowStockCount = 0;
        int outOfStockCount = 0;
        
        for (Branch branch : branches) {
            log.info("Checking stock levels for branch: {}", branch.getBranchName());
            
            for (Product product : allProducts) {
                // Calculate total available quantity for this product in this branch
                Integer totalQuantity = inventoryBatchRepository
                        .sumAvailableQuantityByProductAndBranch(product.getId(), branch.getId());
                
                if (totalQuantity == null) {
                    totalQuantity = 0;
                }
                
                AlertLevel alertLevel = null;
                String alertMessage = null;
                
                // OUT OF STOCK - No inventory at all
                if (totalQuantity == 0) {
                    alertLevel = AlertLevel.CRITICAL;
                    alertMessage = String.format(
                            "OUT OF STOCK: %s (Code: %s) - No stock available in %s. Order immediately!",
                            product.getProductName(),
                            product.getProductCode(),
                            branch.getBranchName()
                    );
                    outOfStockCount++;
                }
                // CRITICAL STOCK - Below minimum stock level
                else if (totalQuantity <= product.getMinimumStock()) {
                    alertLevel = AlertLevel.CRITICAL;
                    alertMessage = String.format(
                            "CRITICAL STOCK: %s (Code: %s) - Only %d units left in %s. Minimum required: %d. Order urgently!",
                            product.getProductName(),
                            product.getProductCode(),
                            totalQuantity,
                            branch.getBranchName(),
                            product.getMinimumStock()
                    );
                    criticalCount++;
                }
                // LOW STOCK - Below reorder level
                else if (totalQuantity <= product.getReorderLevel()) {
                    alertLevel = AlertLevel.URGENT;
                    alertMessage = String.format(
                            "LOW STOCK: %s (Code: %s) - %d units left in %s. Reorder level: %d. Please reorder soon.",
                            product.getProductName(),
                            product.getProductCode(),
                            totalQuantity,
                            branch.getBranchName(),
                            product.getReorderLevel()
                    );
                    lowStockCount++;
                }
                
                // Create notification if stock is low
                if (alertLevel != null) {
                    createLowStockNotification(branch, product, alertLevel, alertMessage, totalQuantity);
                }
            }
        }
        
        log.info("Low Stock Alert Summary - Out of Stock: {}, Critical: {}, Low Stock: {}",
                outOfStockCount, criticalCount, lowStockCount);
        log.info("=== Low Stock Alert Check Complete ===");
    }

    /**
     * Generate auto-reorder suggestions for products below reorder level
     * Suggests optimal order quantity based on:
     * - Current stock
     * - Maximum stock capacity
     * - Average consumption (if available)
     */
    @Scheduled(cron = "0 0 8 * * ?") // Daily at 8 AM
    @Transactional
    public void generateReorderSuggestions() {
        log.info("=== Generating Auto-Reorder Suggestions ===");
        
        List<Branch> branches = branchRepository.findAll();
        
        for (Branch branch : branches) {
            Map<Product, Integer> reorderSuggestions = new HashMap<>();
            
            List<Product> lowStockProducts = productRepository.findByIsActiveTrue();
            
            for (Product product : lowStockProducts) {
                Integer currentStock = inventoryBatchRepository
                        .sumAvailableQuantityByProductAndBranch(product.getId(), branch.getId());
                
                if (currentStock == null) {
                    currentStock = 0;
                }
                
                // If stock is at or below reorder level, suggest order
                if (currentStock <= product.getReorderLevel()) {
                    // Calculate suggested order quantity
                    // Formula: (Maximum Stock - Current Stock) + Safety Buffer (20% of max)
                    int suggestedQuantity = (product.getMaximumStock() - currentStock) + 
                            (int) (product.getMaximumStock() * 0.2);
                    
                    reorderSuggestions.put(product, suggestedQuantity);
                }
            }
            
            // Create consolidated reorder notification
            if (!reorderSuggestions.isEmpty()) {
                createReorderSuggestionNotification(branch, reorderSuggestions);
            }
        }
        
        log.info("=== Auto-Reorder Suggestions Generated ===");
    }

    private void createLowStockNotification(Branch branch, Product product, 
                                           AlertLevel alertLevel, String message, int currentStock) {
        // Get procurement managers, inventory managers, and branch managers
        List<User> recipientUsers = userRepository
                .findByBranchIdAndRoleIn(
                        branch.getId(),
                        List.of("ADMIN", "BRANCH_MANAGER", "INVENTORY_MANAGER")
                );
        
        for (User user : recipientUsers) {
            Notification notification = Notification.builder()
                    .user(user)
                    .type(NotificationType.LOW_STOCK_ALERT)
                    .title("Low Stock Alert")
                    .message(message)
                    .priority(alertLevel.name())
                    .referenceType("PRODUCT")
                    .referenceId(product.getId())
                    .isRead(false)
                    .build();
            
            notificationRepository.save(notification);
        }
    }

    private void createReorderSuggestionNotification(Branch branch, 
                                                     Map<Product, Integer> suggestions) {
        StringBuilder message = new StringBuilder();
        message.append(String.format("Auto-Reorder Suggestions for %s:\n\n", branch.getBranchName()));
        
        suggestions.forEach((product, quantity) -> {
            message.append(String.format(" %s (Code: %s) - Order %d units\n",
                    product.getProductName(),
                    product.getProductCode(),
                    quantity));
        });
        
        message.append("\nPlease review and create purchase orders accordingly.");
        
        List<User> recipientUsers = userRepository
                .findByBranchIdAndRoleIn(
                        branch.getId(),
                        List.of("ADMIN", "BRANCH_MANAGER", "INVENTORY_MANAGER")
                );
        
        for (User user : recipientUsers) {
            Notification notification = Notification.builder()
                    .user(user)
                    .type(NotificationType.REORDER_SUGGESTION)
                    .title("Auto-Reorder Suggestions")
                    .message(message.toString())
                    .priority(AlertLevel.WARNING.name())
                    .referenceType("BRANCH")
                    .referenceId(branch.getId())
                    .isRead(false)
                    .build();
            
            notificationRepository.save(notification);
        }
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\scheduler\ReportGenerationScheduler.java"   & echo.. 
package com.pharmacy.medlan.scheduler;

public class ReportGenerationScheduler {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\scheduler\SessionCleanupScheduler.java"   & echo.. 
package com.pharmacy.medlan.scheduler;

public class SessionCleanupScheduler {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\scheduler\SyncScheduler.java"   & echo.. 
package com.pharmacy.medlan.scheduler;

public class SyncScheduler {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\security\AuthorizationAspect.java"   & echo.. 
package com.pharmacy.medlan.security;

public class AuthorizationAspect {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\security\CustomerUserDetails.java"   & echo.. 
package com.pharmacy.medlan.security;

public class CustomerUserDetails {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\security\JwtAuthenticationFilter.java"   & echo.. 
package com.pharmacy.medlan.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) && jwtTokenProvider.validateToken(jwt)) {
                String username = jwtTokenProvider.getUsernameFromToken(jwt);
                String authorities = jwtTokenProvider.getAuthoritiesFromToken(jwt);

                List<SimpleGrantedAuthority> grantedAuthorities = Arrays.stream(authorities.split(","))
                        .filter(StringUtils::hasText)
                        .map(SimpleGrantedAuthority::new)
                        .collect(Collectors.toList());

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(username, null, grantedAuthorities);
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
                log.debug("Set authentication for user: {}", username);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\security\JwtTokenProvider.java"   & echo.. 
package com.pharmacy.medlan.security;

import com.pharmacy.medlan.config.JwtConfig;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtTokenProvider {

    private final JwtConfig jwtConfig;
    private SecretKey key;

    @PostConstruct
    public void init() {
        this.key = Keys.hmacShaKeyFor(jwtConfig.getSecret().getBytes(StandardCharsets.UTF_8));
    }

    public String generateToken(Authentication authentication) {
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtConfig.getExpiration());

        String authorities = userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));

        return Jwts.builder()
                .subject(userDetails.getUsername())
                .claim("authorities", authorities)
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(key, Jwts.SIG.HS256)
                .compact();
    }

    public String generateTokenFromUsername(String username, String authorities) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtConfig.getExpiration());

        return Jwts.builder()
                .subject(username)
                .claim("authorities", authorities)
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(key, Jwts.SIG.HS256)
                .compact();
    }

    public String generateRefreshToken(String username) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtConfig.getRefreshExpiration());

        return Jwts.builder()
                .subject(username)
                .claim("type", "refresh")
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(key, Jwts.SIG.HS256)
                .compact();
    }

    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
        return claims.getSubject();
    }

    public String getAuthoritiesFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
        return claims.get("authorities", String.class);
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(key)
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (MalformedJwtException ex) {
            log.error("Invalid JWT token");
        } catch (ExpiredJwtException ex) {
            log.error("Expired JWT token");
        } catch (UnsupportedJwtException ex) {
            log.error("Unsupported JWT token");
        } catch (IllegalArgumentException ex) {
            log.error("JWT claims string is empty");
        } catch (SecurityException ex) {
            log.error("JWT signature validation failed");
        }
        return false;
    }

    public Long getExpirationTime() {
        return jwtConfig.getExpiration();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\security\SecurityUtils.java"   & echo.. 
package com.pharmacy.medlan.security;

import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.user.UserRepository;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.Optional;

public class SecurityUtils {

    /**
     * Get the login of the current user.
     *
     * @return the login of the current user.
     */
    public static Optional<String> getCurrentUserLogin() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            return Optional.empty();
        }
        String principal = authentication.getName();
        return Optional.ofNullable(principal);
    }

    /**
     * Get the current authenticated user entity.
     *
     * @param userRepository the user repository to use
     * @return the current user entity or null if not found
     */
    public static User getCurrentUser(UserRepository userRepository) {
        return getCurrentUserLogin()
                .flatMap(userRepository::findByUsername)
                .orElse(null);
    }

    /**
     * Check if the current user is authenticated.
     *
     * @return true if authenticated, false otherwise
     */
    public static boolean isAuthenticated() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null && authentication.isAuthenticated();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\security\UserDetailsServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.security;

import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.user.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

        if (!user.getIsActive()) {
            throw new UsernameNotFoundException("User account is disabled: " + username);
        }

        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(),
                user.getIsActive(),
                true,
                true,
                true,
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + user.getRole().name()))
        );
    }

    @Transactional(readOnly = true)
    public User loadUserEntityByUsername(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\audit\AuditService.java"   & echo.. 
package com.pharmacy.medlan.service.audit;

public interface AuditService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\audit\AuditServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.audit;

public class AuditServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\barcode\BarcodeService.java"   & echo.. 
package com.pharmacy.medlan.service.barcode;

import com.pharmacy.medlan.dto.response.barcode.BarcodeResponse;
import com.pharmacy.medlan.dto.response.barcode.QRCodeResponse;
import com.pharmacy.medlan.enums.BarcodeFormat;

import java.util.List;
import java.util.Map;

/**
 * Service for generating and reading barcodes and QR codes.
 * Supports multiple barcode formats for pharmacy inventory management.
 */
public interface BarcodeService {

    /**
     * Generate a barcode image for a product
     * @param productCode The product code to encode
     * @param format The barcode format (EAN-13, CODE-128, etc.)
     * @param width Width of the barcode image
     * @param height Height of the barcode image
     * @return BarcodeResponse containing the base64 encoded image
     */
    BarcodeResponse generateBarcode(String productCode, BarcodeFormat format, int width, int height);

    /**
     * Generate a QR code for a product with detailed information
     * @param data The data to encode (can be JSON with product details)
     * @param size The size of the QR code (width = height)
     * @return QRCodeResponse containing the base64 encoded image
     */
    QRCodeResponse generateQRCode(String data, int size);

    /**
     * Generate QR code for product with all details embedded
     * @param productId The product ID
     * @param includeBatchInfo Include batch information in QR
     * @param size Size of the QR code
     * @return QRCodeResponse
     */
    QRCodeResponse generateProductQRCode(Long productId, boolean includeBatchInfo, int size);

    /**
     * Generate QR code for inventory batch with traceability info
     * @param batchId The batch ID
     * @param size Size of the QR code
     * @return QRCodeResponse
     */
    QRCodeResponse generateBatchQRCode(Long batchId, int size);

    /**
     * Generate shelf label with barcode for printing
     * @param productId Product ID
     * @param format Barcode format
     * @return BarcodeResponse with print-ready image
     */
    BarcodeResponse generateShelfLabel(Long productId, BarcodeFormat format);

    /**
     * Bulk generate barcodes for multiple products
     * @param productIds List of product IDs
     * @param format Barcode format
     * @return Map of product ID to BarcodeResponse
     */
    Map<Long, BarcodeResponse> generateBulkBarcodes(List<Long> productIds, BarcodeFormat format);

    /**
     * Read/decode a barcode from base64 image
     * @param base64Image The base64 encoded barcode image
     * @return Decoded barcode content
     */
    String readBarcode(String base64Image);

    /**
     * Read/decode a QR code from base64 image
     * @param base64Image The base64 encoded QR code image
     * @return Decoded QR code content
     */
    String readQRCode(String base64Image);

    /**
     * Validate barcode format
     * @param barcode The barcode string to validate
     * @param format Expected barcode format
     * @return true if valid
     */
    boolean validateBarcodeFormat(String barcode, BarcodeFormat format);

    /**
     * Generate unique barcode for new product
     * @param prefix Optional prefix for the barcode
     * @return Generated unique barcode
     */
    String generateUniqueBarcode(String prefix);

    /**
     * Generate EAN-13 compliant barcode with check digit
     * @param baseNumber 12-digit base number
     * @return Complete EAN-13 barcode with check digit
     */
    String generateEAN13(String baseNumber);

    /**
     * Generate invoice QR code for GST compliance
     * @param invoiceId Invoice ID
     * @return QRCodeResponse for invoice
     */
    QRCodeResponse generateInvoiceQRCode(Long invoiceId);

    /**
     * Generate prescription QR code
     * @param prescriptionId Prescription ID
     * @return QRCodeResponse
     */
    QRCodeResponse generatePrescriptionQRCode(Long prescriptionId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\barcode\BarcodeServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.barcode;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.zxing.*;
import com.google.zxing.client.j2se.BufferedImageLuminanceSource;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.common.HybridBinarizer;
import com.google.zxing.qrcode.QRCodeWriter;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import com.pharmacy.medlan.dto.response.barcode.BarcodeResponse;
import com.pharmacy.medlan.dto.response.barcode.QRCodeResponse;
import com.pharmacy.medlan.enums.BarcodeFormat;
import com.pharmacy.medlan.exception.BusinessRuleViolationException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.model.pos.Invoice;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.pos.InvoiceRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

@Service
@RequiredArgsConstructor
@Slf4j
public class BarcodeServiceImpl implements BarcodeService {

    private final ProductRepository productRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final InvoiceRepository invoiceRepository;
    private final ObjectMapper objectMapper;

    private static final String MIME_TYPE_PNG = "image/png";
    private static final int DEFAULT_BARCODE_WIDTH = 300;
    private static final int DEFAULT_BARCODE_HEIGHT = 100;
    private static final int DEFAULT_QR_SIZE = 250;

    // Thread-safe counter for unique barcode generation
    private final AtomicLong barcodeCounter = new AtomicLong(System.currentTimeMillis() % 1000000000L);

    @Override
    public BarcodeResponse generateBarcode(String content, BarcodeFormat format, int width, int height) {
        log.debug("Generating barcode for content: {} with format: {}", content, format);

        try {
            // Validate content for fixed-length formats
            validateContentForFormat(content, format);

            BitMatrix bitMatrix = new MultiFormatWriter().encode(
                    content,
                    format.toZxingFormat(),
                    width > 0 ? width : DEFAULT_BARCODE_WIDTH,
                    height > 0 ? height : DEFAULT_BARCODE_HEIGHT,
                    getEncodingHints()
            );

            String base64Image = matrixToBase64(bitMatrix);

            return BarcodeResponse.builder()
                    .content(content)
                    .imageBase64(base64Image)
                    .mimeType(MIME_TYPE_PNG)
                    .format(format)
                    .width(bitMatrix.getWidth())
                    .height(bitMatrix.getHeight())
                    .generatedAt(LocalDateTime.now())
                    .build();

        } catch (WriterException e) {
            log.error("Error generating barcode: {}", e.getMessage());
            throw new BusinessRuleViolationException("Failed to generate barcode: " + e.getMessage());
        }
    }

    @Override
    public QRCodeResponse generateQRCode(String data, int size) {
        log.debug("Generating QR code for data length: {}", data.length());

        try {
            int qrSize = size > 0 ? size : DEFAULT_QR_SIZE;

            Map<EncodeHintType, Object> hints = new EnumMap<>(EncodeHintType.class);
            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
            hints.put(EncodeHintType.CHARACTER_SET, "UTF-8");
            hints.put(EncodeHintType.MARGIN, 2);

            QRCodeWriter qrCodeWriter = new QRCodeWriter();
            BitMatrix bitMatrix = qrCodeWriter.encode(data, com.google.zxing.BarcodeFormat.QR_CODE, qrSize, qrSize, hints);

            String base64Image = matrixToBase64(bitMatrix);

            return QRCodeResponse.builder()
                    .content(data)
                    .imageBase64(base64Image)
                    .mimeType(MIME_TYPE_PNG)
                    .size(qrSize)
                    .errorCorrectionLevel("H")
                    .generatedAt(LocalDateTime.now())
                    .build();

        } catch (WriterException e) {
            log.error("Error generating QR code: {}", e.getMessage());
            throw new BusinessRuleViolationException("Failed to generate QR code: " + e.getMessage());
        }
    }

    @Override
    @Cacheable(value = "productQRCodes", key = "#productId + '_' + #includeBatchInfo + '_' + #size")
    public QRCodeResponse generateProductQRCode(Long productId, boolean includeBatchInfo, int size) {
        log.info("Generating product QR code for product ID: {}", productId);

        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with ID: " + productId));

        Map<String, Object> qrData = new LinkedHashMap<>();
        qrData.put("type", "PRODUCT");
        qrData.put("id", product.getId());
        qrData.put("code", product.getProductCode());
        qrData.put("name", product.getProductName());
        qrData.put("genericName", product.getGenericName());
        qrData.put("barcode", product.getBarcode());
        qrData.put("manufacturer", product.getManufacturer());
        qrData.put("mrp", product.getMrp());
        qrData.put("sellingPrice", product.getSellingPrice());

        if (product.getDrugSchedule() != null) {
            qrData.put("drugSchedule", product.getDrugSchedule().name());
        }
        if (product.getDosageForm() != null) {
            qrData.put("dosageForm", product.getDosageForm().name());
        }
        qrData.put("strength", product.getStrength());
        qrData.put("prescriptionRequired", product.getIsPrescriptionRequired());
        qrData.put("isNarcotic", product.getIsNarcotic());

        if (includeBatchInfo) {
            List<Map<String, Object>> batches = new ArrayList<>();
            product.getInventoryBatches().stream()
                    .filter(b -> b.getIsActive() && !b.getIsExpired() && b.getQuantityAvailable() > 0)
                    .limit(5) // Limit to keep QR size manageable
                    .forEach(batch -> {
                        Map<String, Object> batchData = new HashMap<>();
                        batchData.put("batchNo", batch.getBatchNumber());
                        batchData.put("expiry", batch.getExpiryDate().toString());
                        batchData.put("available", batch.getQuantityAvailable());
                        batches.add(batchData);
                    });
            qrData.put("batches", batches);
        }

        qrData.put("generatedAt", LocalDateTime.now().toString());

        try {
            String jsonData = objectMapper.writeValueAsString(qrData);
            QRCodeResponse response = generateQRCode(jsonData, size);
            response.setQrType("PRODUCT");
            response.setEntityId(productId);
            response.setEntityReference(product.getProductCode());
            response.setMetadata(qrData);
            return response;
        } catch (JsonProcessingException e) {
            throw new BusinessRuleViolationException("Failed to serialize product data for QR code");
        }
    }

    @Override
    @Cacheable(value = "batchQRCodes", key = "#batchId + '_' + #size")
    public QRCodeResponse generateBatchQRCode(Long batchId, int size) {
        log.info("Generating batch QR code for batch ID: {}", batchId);

        InventoryBatch batch = inventoryBatchRepository.findById(batchId)
                .orElseThrow(() -> new ResourceNotFoundException("Batch not found with ID: " + batchId));

        Map<String, Object> qrData = new LinkedHashMap<>();
        qrData.put("type", "BATCH");
        qrData.put("batchId", batch.getId());
        qrData.put("batchNumber", batch.getBatchNumber());
        qrData.put("productId", batch.getProduct().getId());
        qrData.put("productCode", batch.getProduct().getProductCode());
        qrData.put("productName", batch.getProduct().getProductName());
        qrData.put("branchId", batch.getBranch().getId());
        qrData.put("branchName", batch.getBranch().getBranchName());
        qrData.put("manufacturingDate", batch.getManufacturingDate().toString());
        qrData.put("expiryDate", batch.getExpiryDate().toString());
        qrData.put("quantityReceived", batch.getQuantityReceived());
        qrData.put("quantityAvailable", batch.getQuantityAvailable());
        qrData.put("quantitySold", batch.getQuantitySold());
        qrData.put("purchasePrice", batch.getPurchasePrice());
        qrData.put("mrp", batch.getMrp());
        qrData.put("sellingPrice", batch.getSellingPrice());
        qrData.put("rackLocation", batch.getRackLocation());
        qrData.put("isExpired", batch.getIsExpired());
        qrData.put("daysToExpiry", calculateDaysToExpiry(batch.getExpiryDate()));
        qrData.put("generatedAt", LocalDateTime.now().toString());

        try {
            String jsonData = objectMapper.writeValueAsString(qrData);
            QRCodeResponse response = generateQRCode(jsonData, size);
            response.setQrType("BATCH");
            response.setEntityId(batchId);
            response.setEntityReference(batch.getBatchNumber());
            response.setMetadata(qrData);
            return response;
        } catch (JsonProcessingException e) {
            throw new BusinessRuleViolationException("Failed to serialize batch data for QR code");
        }
    }

    @Override
    public BarcodeResponse generateShelfLabel(Long productId, BarcodeFormat format) {
        log.info("Generating shelf label for product ID: {}", productId);

        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with ID: " + productId));

        String barcodeContent = product.getBarcode() != null ? product.getBarcode() : product.getProductCode();

        BarcodeResponse response = generateBarcode(barcodeContent, format, 200, 80);
        response.setProductId(product.getId());
        response.setProductName(product.getProductName());
        response.setProductCode(product.getProductCode());

        if (product.getSellingPrice() != null) {
            response.setPrice("" + product.getSellingPrice().setScale(2).toPlainString());
        }
        if (product.getMrp() != null) {
            response.setMrp("MRP: " + product.getMrp().setScale(2).toPlainString());
        }

        return response;
    }

    @Override
    public Map<Long, BarcodeResponse> generateBulkBarcodes(List<Long> productIds, BarcodeFormat format) {
        log.info("Generating bulk barcodes for {} products", productIds.size());

        Map<Long, BarcodeResponse> results = new ConcurrentHashMap<>();

        productIds.parallelStream().forEach(productId -> {
            try {
                BarcodeResponse response = generateShelfLabel(productId, format);
                results.put(productId, response);
            } catch (Exception e) {
                log.error("Failed to generate barcode for product {}: {}", productId, e.getMessage());
            }
        });

        return results;
    }

    @Override
    public String readBarcode(String base64Image) {
        log.debug("Reading barcode from image");

        try {
            BufferedImage image = decodeBase64ToImage(base64Image);
            LuminanceSource source = new BufferedImageLuminanceSource(image);
            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));

            Result result = new MultiFormatReader().decode(bitmap);
            return result.getText();

        } catch (NotFoundException e) {
            log.error("No barcode found in image");
            throw new BusinessRuleViolationException("No barcode found in the provided image");
        }
    }

    @Override
    public String readQRCode(String base64Image) {
        log.debug("Reading QR code from image");

        try {
            BufferedImage image = decodeBase64ToImage(base64Image);
            LuminanceSource source = new BufferedImageLuminanceSource(image);
            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));

            Map<DecodeHintType, Object> hints = new EnumMap<>(DecodeHintType.class);
            hints.put(DecodeHintType.POSSIBLE_FORMATS, Collections.singletonList(com.google.zxing.BarcodeFormat.QR_CODE));

            Result result = new MultiFormatReader().decode(bitmap, hints);
            return result.getText();

        } catch (NotFoundException e) {
            log.error("No QR code found in image");
            throw new BusinessRuleViolationException("No QR code found in the provided image");
        }
    }

    @Override
    public boolean validateBarcodeFormat(String barcode, BarcodeFormat format) {
        if (barcode == null || barcode.isEmpty()) {
            return false;
        }

        return switch (format) {
            case EAN_13 -> validateEAN13(barcode);
            case EAN_8 -> validateEAN8(barcode);
            case UPC_A -> validateUPCA(barcode);
            case CODE_128, CODE_39 -> barcode.length() > 0 && barcode.length() <= 80;
            case ITF_14 -> barcode.length() == 14 && barcode.matches("\\d+");
            default -> true;
        };
    }

    @Override
    public String generateUniqueBarcode(String prefix) {
        String basePrefix = (prefix != null && !prefix.isEmpty()) ? prefix : "MED";
        long counter = barcodeCounter.incrementAndGet();
        String timestamp = String.valueOf(System.currentTimeMillis() % 100000000L);

        // Format: PREFIX + Counter (padded to 6 digits)
        String base = basePrefix + String.format("%06d", counter % 1000000);

        // If needed, make it EAN-13 compatible
        if (base.length() < 12) {
            base = String.format("%-12s", base).replace(' ', '0');
        }

        return base.substring(0, 12);
    }

    @Override
    public String generateEAN13(String baseNumber) {
        if (baseNumber == null || baseNumber.length() != 12) {
            throw new BusinessRuleViolationException("EAN-13 base number must be exactly 12 digits");
        }

        if (!baseNumber.matches("\\d+")) {
            throw new BusinessRuleViolationException("EAN-13 base number must contain only digits");
        }

        int sum = 0;
        for (int i = 0; i < 12; i++) {
            int digit = Character.getNumericValue(baseNumber.charAt(i));
            sum += (i % 2 == 0) ? digit : digit * 3;
        }

        int checkDigit = (10 - (sum % 10)) % 10;
        return baseNumber + checkDigit;
    }

    @Override
    @Cacheable(value = "invoiceQRCodes", key = "#invoiceId")
    public QRCodeResponse generateInvoiceQRCode(Long invoiceId) {
        log.info("Generating invoice QR code for invoice ID: {}", invoiceId);

        Invoice invoice = invoiceRepository.findById(invoiceId)
                .orElseThrow(() -> new ResourceNotFoundException("Invoice not found with ID: " + invoiceId));

        // GST Invoice QR Code format (simplified for Indian GST compliance)
        Map<String, Object> qrData = new LinkedHashMap<>();
        qrData.put("type", "INVOICE");
        qrData.put("invoiceNo", invoice.getInvoiceNumber());
        qrData.put("invoiceDate", invoice.getInvoiceDate().toString());
        qrData.put("customerId", invoice.getCustomer() != null ? invoice.getCustomer().getId() : null);
        qrData.put("customerName", invoice.getCustomer() != null ? invoice.getCustomer().getCustomerName() : "Walk-in");
        qrData.put("branchId", invoice.getBranch().getId());
        qrData.put("branchName", invoice.getBranch().getBranchName());
        qrData.put("subtotal", invoice.getSubtotal());
        qrData.put("discount", invoice.getDiscount());
        qrData.put("totalAmount", invoice.getTotalAmount());
        qrData.put("paidAmount", invoice.getPaidAmount());
        qrData.put("balanceAmount", invoice.getBalanceAmount());
        qrData.put("status", invoice.getStatus().name());
        qrData.put("generatedAt", LocalDateTime.now().toString());

        try {
            String jsonData = objectMapper.writeValueAsString(qrData);
            QRCodeResponse response = generateQRCode(jsonData, DEFAULT_QR_SIZE);
            response.setQrType("INVOICE");
            response.setEntityId(invoiceId);
            response.setEntityReference(invoice.getInvoiceNumber());
            response.setMetadata(qrData);
            return response;
        } catch (JsonProcessingException e) {
            throw new BusinessRuleViolationException("Failed to serialize invoice data for QR code");
        }
    }

    @Override
    public QRCodeResponse generatePrescriptionQRCode(Long prescriptionId) {
        // Prescription QR code implementation
        Map<String, Object> qrData = new LinkedHashMap<>();
        qrData.put("type", "PRESCRIPTION");
        qrData.put("prescriptionId", prescriptionId);
        qrData.put("generatedAt", LocalDateTime.now().toString());

        try {
            String jsonData = objectMapper.writeValueAsString(qrData);
            QRCodeResponse response = generateQRCode(jsonData, DEFAULT_QR_SIZE);
            response.setQrType("PRESCRIPTION");
            response.setEntityId(prescriptionId);
            return response;
        } catch (JsonProcessingException e) {
            throw new BusinessRuleViolationException("Failed to serialize prescription data for QR code");
        }
    }

    // ==================== Private Helper Methods ====================

    private String matrixToBase64(BitMatrix bitMatrix) {
        try {
            BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix);
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            ImageIO.write(image, "PNG", outputStream);
            return Base64.getEncoder().encodeToString(outputStream.toByteArray());
        } catch (IOException e) {
            throw new BusinessRuleViolationException("Failed to convert barcode to image");
        }
    }

    private BufferedImage decodeBase64ToImage(String base64Image) {
        try {
            // Remove data URL prefix if present
            String base64Data = base64Image;
            if (base64Image.contains(",")) {
                base64Data = base64Image.split(",")[1];
            }

            byte[] imageBytes = Base64.getDecoder().decode(base64Data);
            return ImageIO.read(new ByteArrayInputStream(imageBytes));
        } catch (IOException e) {
            throw new BusinessRuleViolationException("Failed to decode base64 image");
        }
    }

    private Map<EncodeHintType, Object> getEncodingHints() {
        Map<EncodeHintType, Object> hints = new EnumMap<>(EncodeHintType.class);
        hints.put(EncodeHintType.CHARACTER_SET, "UTF-8");
        hints.put(EncodeHintType.MARGIN, 1);
        return hints;
    }

    private void validateContentForFormat(String content, BarcodeFormat format) {
        if (format.isFixedLength() && content.length() != format.getFixedLength()) {
            // For EAN-13, allow 12 digits (we'll add check digit) or 13 digits
            if (format == BarcodeFormat.EAN_13 && (content.length() == 12 || content.length() == 13)) {
                return;
            }
            throw new BusinessRuleViolationException(
                    String.format("Content must be %d characters for %s format", format.getFixedLength(), format.getDisplayName())
            );
        }
    }

    private boolean validateEAN13(String barcode) {
        if (barcode.length() != 13 || !barcode.matches("\\d+")) {
            return false;
        }

        int sum = 0;
        for (int i = 0; i < 12; i++) {
            int digit = Character.getNumericValue(barcode.charAt(i));
            sum += (i % 2 == 0) ? digit : digit * 3;
        }

        int calculatedCheckDigit = (10 - (sum % 10)) % 10;
        int actualCheckDigit = Character.getNumericValue(barcode.charAt(12));

        return calculatedCheckDigit == actualCheckDigit;
    }

    private boolean validateEAN8(String barcode) {
        if (barcode.length() != 8 || !barcode.matches("\\d+")) {
            return false;
        }

        int sum = 0;
        for (int i = 0; i < 7; i++) {
            int digit = Character.getNumericValue(barcode.charAt(i));
            sum += (i % 2 == 0) ? digit * 3 : digit;
        }

        int calculatedCheckDigit = (10 - (sum % 10)) % 10;
        int actualCheckDigit = Character.getNumericValue(barcode.charAt(7));

        return calculatedCheckDigit == actualCheckDigit;
    }

    private boolean validateUPCA(String barcode) {
        if (barcode.length() != 12 || !barcode.matches("\\d+")) {
            return false;
        }

        int sum = 0;
        for (int i = 0; i < 11; i++) {
            int digit = Character.getNumericValue(barcode.charAt(i));
            sum += (i % 2 == 0) ? digit * 3 : digit;
        }

        int calculatedCheckDigit = (10 - (sum % 10)) % 10;
        int actualCheckDigit = Character.getNumericValue(barcode.charAt(11));

        return calculatedCheckDigit == actualCheckDigit;
    }

    private long calculateDaysToExpiry(LocalDate expiryDate) {
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDate.now(), expiryDate);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\branch\BranchService.java"   & echo.. 
package com.pharmacy.medlan.service.branch;

import com.pharmacy.medlan.model.organization.Branch;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import java.util.List;
import java.util.Optional;

public interface BranchService {

    // CRUD Operations
    Branch createBranch(Branch branch);

    Branch updateBranch(Long id, Branch branch);

    Optional<Branch> getBranchById(Long id);

    Branch getBranchByCode(String branchCode);

    List<Branch> getAllBranches();

    Page<Branch> getAllBranches(Pageable pageable);

    List<Branch> getActiveBranches();

    void deleteBranch(Long id);

    void softDeleteBranch(Long id);

    // Status Management
    void activateBranch(Long id);

    void deactivateBranch(Long id);

    // Search Operations
    List<Branch> searchBranches(String search);

    List<Branch> getBranchesByCity(String city);

    List<Branch> getBranchesByState(String state);

    // Validation
    boolean existsByBranchCode(String branchCode);

    boolean existsByEmail(String email);

    // Main Branch Operations
    Branch getMainBranch();

    void setAsMainBranch(Long id);

    // Count Operations
    long countActiveBranches();

    long countTotalBranches();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\branch\BranchServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.branch;

import com.pharmacy.medlan.exception.DuplicationResourceException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.repository.organization.BranchRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class BranchServiceImpl implements BranchService {

    private final BranchRepository branchRepository;

    @Override
    @Transactional
    public Branch createBranch(Branch branch) {
        log.info("Creating branch: {}", branch.getBranchName());

        if (branchRepository.existsByBranchCode(branch.getBranchCode())) {
            throw new DuplicationResourceException("Branch code already exists: " + branch.getBranchCode());
        }

        if (branch.getEmail() != null && branchRepository.existsByEmail(branch.getEmail())) {
            throw new DuplicationResourceException("Email already exists: " + branch.getEmail());
        }

        branch.setIsActive(true);
        Branch saved = branchRepository.save(branch);
        log.info("Branch created with code: {}", saved.getBranchCode());
        return saved;
    }

    @Override
    @Transactional
    public Branch updateBranch(Long id, Branch branch) {
        log.info("Updating branch: {}", id);

        Branch existing = branchRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found with id: " + id));

        // Update fields
        if (branch.getBranchName() != null) {
            existing.setBranchName(branch.getBranchName());
        }
        if (branch.getAddress() != null) {
            existing.setAddress(branch.getAddress());
        }
        if (branch.getCity() != null) {
            existing.setCity(branch.getCity());
        }
        if (branch.getState() != null) {
            existing.setState(branch.getState());
        }
        if (branch.getPincode() != null) {
            existing.setPincode(branch.getPincode());
        }
        if (branch.getPhoneNumber() != null) {
            existing.setPhoneNumber(branch.getPhoneNumber());
        }
        if (branch.getEmail() != null) {
            existing.setEmail(branch.getEmail());
        }
        if (branch.getGstinNumber() != null) {
            existing.setGstinNumber(branch.getGstinNumber());
        }
        if (branch.getDrugLicenseNumber() != null) {
            existing.setDrugLicenseNumber(branch.getDrugLicenseNumber());
        }
        if (branch.getManager() != null) {
            existing.setManager(branch.getManager());
        }

        return branchRepository.save(existing);
    }

    @Override
    public Optional<Branch> getBranchById(Long id) {
        return branchRepository.findById(id);
    }

    @Override
    public Branch getBranchByCode(String branchCode) {
        return branchRepository.findByBranchCode(branchCode)
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found with code: " + branchCode));
    }

    @Override
    public List<Branch> getAllBranches() {
        return branchRepository.findAll();
    }

    @Override
    public Page<Branch> getAllBranches(Pageable pageable) {
        return branchRepository.findAll(pageable);
    }

    @Override
    public List<Branch> getActiveBranches() {
        return branchRepository.findByIsActiveTrue();
    }

    @Override
    @Transactional
    public void deleteBranch(Long id) {
        log.info("Deleting branch: {}", id);

        if (!branchRepository.existsById(id)) {
            throw new ResourceNotFoundException("Branch not found with id: " + id);
        }

        branchRepository.deleteById(id);
        log.info("Branch deleted: {}", id);
    }

    @Override
    @Transactional
    public void softDeleteBranch(Long id) {
        log.info("Soft deleting branch: {}", id);

        Branch branch = branchRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found with id: " + id));

        branch.setDeleted(true);
        branch.setIsActive(false);
        branchRepository.save(branch);
        log.info("Branch soft deleted: {}", id);
    }

    @Override
    @Transactional
    public void activateBranch(Long id) {
        log.info("Activating branch: {}", id);

        Branch branch = branchRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found with id: " + id));

        branch.setIsActive(true);
        branchRepository.save(branch);
        log.info("Branch activated: {}", id);
    }

    @Override
    @Transactional
    public void deactivateBranch(Long id) {
        log.info("Deactivating branch: {}", id);

        Branch branch = branchRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found with id: " + id));

        branch.setIsActive(false);
        branchRepository.save(branch);
        log.info("Branch deactivated: {}", id);
    }

    @Override
    public List<Branch> searchBranches(String search) {
        return branchRepository.searchBranches(search);
    }

    @Override
    public List<Branch> getBranchesByCity(String city) {
        return branchRepository.findByCity(city);
    }

    @Override
    public List<Branch> getBranchesByState(String state) {
        return branchRepository.findByState(state);
    }

    @Override
    public boolean existsByBranchCode(String branchCode) {
        return branchRepository.existsByBranchCode(branchCode);
    }

    @Override
    public boolean existsByEmail(String email) {
        return branchRepository.existsByEmail(email);
    }

    @Override
    public Branch getMainBranch() {
        return branchRepository.findByIsMainBranchTrue()
                .orElseThrow(() -> new ResourceNotFoundException("No main branch configured"));
    }

    @Override
    @Transactional
    public void setAsMainBranch(Long id) {
        log.info("Setting branch {} as main branch", id);

        Branch newMainBranch = branchRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found with id: " + id));

        // Remove main branch flag from current main branch
        branchRepository.findByIsMainBranchTrue().ifPresent(currentMain -> {
            currentMain.setIsMainBranch(false);
            branchRepository.save(currentMain);
        });

        // Set new main branch
        newMainBranch.setIsMainBranch(true);
        branchRepository.save(newMainBranch);
        log.info("Branch {} is now the main branch", id);
    }

    @Override
    public long countActiveBranches() {
        return branchRepository.countActiveBranches();
    }

    @Override
    public long countTotalBranches() {
        return branchRepository.count();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\branch\BranchStaffService.java"   & echo.. 
package com.pharmacy.medlan.service.branch;

public interface BranchStaffService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\branch\BranchStaffServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.branch;

public class BranchStaffServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\dashboard\DashboardService.java"   & echo.. 
package com.pharmacy.medlan.service.dashboard;

import com.pharmacy.medlan.dto.response.dashboard.DashboardSummaryResponse;
import com.pharmacy.medlan.dto.response.dashboard.SalesAnalyticsResponse;
import com.pharmacy.medlan.dto.response.dashboard.InventoryAnalyticsResponse;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;

/**
 * Service interface for dashboard analytics and summaries
 */
public interface DashboardService {
    
    /**
     * Get complete dashboard summary for a branch
     */
    DashboardSummaryResponse getDashboardSummary(Long branchId);
    
    /**
     * Get today's sales summary
     */
    Map<String, Object> getTodaySales(Long branchId);
    
    /**
     * Get sales analytics for a date range
     */
    SalesAnalyticsResponse getSalesAnalytics(Long branchId, LocalDate startDate, LocalDate endDate);
    
    /**
     * Get inventory analytics
     */
    InventoryAnalyticsResponse getInventoryAnalytics(Long branchId);
    
    /**
     * Get top selling products
     */
    List<Map<String, Object>> getTopSellingProducts(Long branchId, int limit);
    
    /**
     * Get slow moving products
     */
    List<Map<String, Object>> getSlowMovingProducts(Long branchId, int daysSinceLastSale);
    
    /**
     * Get revenue trends
     */
    Map<String, Object> getRevenueTrends(Long branchId, int days);
    
    /**
     * Get staff performance
     */
    List<Map<String, Object>> getStaffPerformance(Long branchId, LocalDate startDate, LocalDate endDate);
    
    /**
     * Get customer insights
     */
    Map<String, Object> getCustomerInsights(Long branchId);
    
    /**
     * Get real-time alerts count
     */
    Map<String, Integer> getAlertCounts(Long branchId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\dashboard\DashboardServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.dashboard;

import com.pharmacy.medlan.dto.response.dashboard.DashboardSummaryResponse;
import com.pharmacy.medlan.dto.response.dashboard.SalesAnalyticsResponse;
import com.pharmacy.medlan.dto.response.dashboard.InventoryAnalyticsResponse;
import com.pharmacy.medlan.enums.SaleStatus;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.inventory.GRNRepository;
import com.pharmacy.medlan.repository.notification.NotificationRepository;
import com.pharmacy.medlan.repository.pos.CustomerRepository;
import com.pharmacy.medlan.repository.pos.SaleRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import com.pharmacy.medlan.repository.supplier.PurchaseOrderRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Advanced Dashboard Service Implementation
 * Provides comprehensive real-time analytics and KPIs
 */
@Service
@Slf4j
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class DashboardServiceImpl implements DashboardService {

    private final SaleRepository saleRepository;
    private final ProductRepository productRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final GRNRepository grnRepository;
    private final PurchaseOrderRepository purchaseOrderRepository;
    private final CustomerRepository customerRepository;
    private final NotificationRepository notificationRepository;

    @Override
    public DashboardSummaryResponse getDashboardSummary(Long branchId) {
        log.info("Generating dashboard summary for branch: {}", branchId);
        
        LocalDate today = LocalDate.now();
        LocalDateTime todayStart = today.atStartOfDay();
        LocalDateTime todayEnd = today.atTime(LocalTime.MAX);
        
        // Get today's sales
        var todaySales = saleRepository.findByBranchIdAndSaleDateBetween(
                branchId, todayStart, todayEnd);
        
        BigDecimal todayTotal = todaySales.stream()
                .filter(s -> s.getStatus() == SaleStatus.COMPLETED)
                .map(s -> s.getTotalAmount())
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        long todayCount = todaySales.stream()
                .filter(s -> s.getStatus() == SaleStatus.COMPLETED)
                .count();
        
        // Get inventory alerts
        var alerts = getAlertCounts(branchId);
        
        return DashboardSummaryResponse.builder()
                .todaySummary(DashboardSummaryResponse.TodaySummary.builder()
                        .totalSales(todayTotal)
                        .salesCount(todayCount)
                        .totalPurchases(BigDecimal.ZERO)
                        .purchasesCount(0L)
                        .profit(BigDecimal.ZERO)
                        .newCustomers(0L)
                        .build())
                .monthlySummary(DashboardSummaryResponse.MonthlySummary.builder()
                        .totalSales(BigDecimal.ZERO)
                        .salesCount(0L)
                        .totalPurchases(BigDecimal.ZERO)
                        .totalProfit(BigDecimal.ZERO)
                        .averageDailySales(BigDecimal.ZERO)
                        .build())
                .inventoryAlerts(DashboardSummaryResponse.InventoryAlerts.builder()
                        .lowStockCount((long) alerts.get("lowStockCount"))
                        .outOfStockCount(0L)
                        .expiringCount((long) alerts.get("nearExpiryCount"))
                        .expiredCount(0L)
                        .build())
                .recentSales(new ArrayList<>())
                .topSellingProducts(new ArrayList<>())
                .build();
    }

    @Override
    public Map<String, Object> getTodaySales(Long branchId) {
        LocalDate today = LocalDate.now();
        LocalDateTime todayStart = today.atStartOfDay();
        LocalDateTime todayEnd = today.atTime(LocalTime.MAX);
        
        var todaySales = saleRepository.findByBranchIdAndSaleDateBetween(
                branchId, todayStart, todayEnd);
        
        BigDecimal totalAmount = BigDecimal.ZERO;
        BigDecimal totalDiscount = BigDecimal.ZERO;
        BigDecimal totalTax = BigDecimal.ZERO;
        BigDecimal totalProfit = BigDecimal.ZERO;
        int billCount = 0;
        
        Map<String, BigDecimal> paymentMethodBreakdown = new HashMap<>();
        paymentMethodBreakdown.put("CASH", BigDecimal.ZERO);
        paymentMethodBreakdown.put("CARD", BigDecimal.ZERO);
        paymentMethodBreakdown.put("UPI", BigDecimal.ZERO);
        paymentMethodBreakdown.put("CREDIT", BigDecimal.ZERO);
        
        for (var sale : todaySales) {
            if (sale.getStatus() == SaleStatus.COMPLETED) {
                totalAmount = totalAmount.add(sale.getTotalAmount());
                totalDiscount = totalDiscount.add(sale.getDiscountAmount());
                totalTax = totalTax.add(sale.getTaxAmount());
                billCount++;
                
                // Calculate profit
                BigDecimal saleCost = sale.getSaleItems().stream()
                        .map(item -> {
                            var batch = item.getInventoryBatch();
                            if (batch != null) {
                                return batch.getPurchasePrice()
                                        .multiply(BigDecimal.valueOf(item.getQuantity()));
                            }
                            return BigDecimal.ZERO;
                        })
                        .reduce(BigDecimal.ZERO, BigDecimal::add);
                
                BigDecimal saleProfit = sale.getTotalAmount().subtract(saleCost);
                totalProfit = totalProfit.add(saleProfit);
                
                // Payment method breakdown
                String paymentMethod = sale.getPaymentMethod().name();
                paymentMethodBreakdown.merge(paymentMethod, 
                        sale.getTotalAmount(), BigDecimal::add);
            }
        }
        
        BigDecimal averageBillValue = billCount > 0 
                ? totalAmount.divide(BigDecimal.valueOf(billCount), 2, RoundingMode.HALF_UP)
                : BigDecimal.ZERO;
        
        BigDecimal profitMargin = totalAmount.compareTo(BigDecimal.ZERO) > 0
                ? totalProfit.divide(totalAmount, 4, RoundingMode.HALF_UP)
                        .multiply(BigDecimal.valueOf(100))
                : BigDecimal.ZERO;
        
        Map<String, Object> result = new HashMap<>();
        result.put("totalAmount", totalAmount);
        result.put("billCount", billCount);
        result.put("averageBillValue", averageBillValue);
        result.put("totalDiscount", totalDiscount);
        result.put("totalTax", totalTax);
        result.put("profit", totalProfit);
        result.put("profitMargin", profitMargin);
        result.put("paymentMethodBreakdown", paymentMethodBreakdown);
        
        // Compare with yesterday
        LocalDateTime yesterdayStart = today.minusDays(1).atStartOfDay();
        LocalDateTime yesterdayEnd = today.minusDays(1).atTime(LocalTime.MAX);
        
        BigDecimal yesterdayTotal = saleRepository
                .findByBranchIdAndSaleDateBetween(branchId, yesterdayStart, yesterdayEnd)
                .stream()
                .filter(s -> s.getStatus() == SaleStatus.COMPLETED)
                .map(s -> s.getTotalAmount())
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal changePercent = yesterdayTotal.compareTo(BigDecimal.ZERO) > 0
                ? totalAmount.subtract(yesterdayTotal)
                        .divide(yesterdayTotal, 4, RoundingMode.HALF_UP)
                        .multiply(BigDecimal.valueOf(100))
                : BigDecimal.ZERO;
        
        result.put("changeFromYesterday", changePercent);
        
        return result;
    }

    @Override
    public SalesAnalyticsResponse getSalesAnalytics(Long branchId, LocalDate startDate, LocalDate endDate) {
        LocalDateTime start = startDate.atStartOfDay();
        LocalDateTime end = endDate.atTime(LocalTime.MAX);
        
        var sales = saleRepository.findByBranchIdAndSaleDateBetween(branchId, start, end);
        
        BigDecimal totalRevenue = BigDecimal.ZERO;
        BigDecimal totalDiscount = BigDecimal.ZERO;
        int totalBills = 0;
        Map<LocalDate, BigDecimal> dailyRevenue = new TreeMap<>();
        
        for (var sale : sales) {
            if (sale.getStatus() == SaleStatus.COMPLETED) {
                totalRevenue = totalRevenue.add(sale.getTotalAmount());
                totalDiscount = totalDiscount.add(sale.getDiscountAmount());
                totalBills++;
                
                LocalDate saleDate = sale.getSaleDate().toLocalDate();
                dailyRevenue.merge(saleDate, sale.getTotalAmount(), BigDecimal::add);
            }
        }
        
        BigDecimal averageDailySales = totalBills > 0
                ? totalRevenue.divide(BigDecimal.valueOf(
                        startDate.until(endDate).getDays() + 1), 2, RoundingMode.HALF_UP)
                : BigDecimal.ZERO;
        
        return SalesAnalyticsResponse.builder()
                .startDate(startDate)
                .endDate(endDate)
                .totalSales(totalRevenue)
                .totalTransactions(totalBills)
                .averageOrderValue(totalBills > 0 ? 
                        totalRevenue.divide(BigDecimal.valueOf(totalBills), 2, RoundingMode.HALF_UP) 
                        : BigDecimal.ZERO)
                .build();
    }

    @Override
    public InventoryAnalyticsResponse getInventoryAnalytics(Long branchId) {
        List<Product> allProducts = productRepository.findByIsActiveTrue();
        
        int totalProducts = allProducts.size();
        int productsInStock = 0;
        int lowStockCount = 0;
        int outOfStockCount = 0;
        BigDecimal totalInventoryValue = BigDecimal.ZERO;
        
        for (var product : allProducts) {
            Integer stock = inventoryBatchRepository
                    .sumAvailableQuantityByProductAndBranch(product.getId(), branchId);
            
            if (stock == null || stock == 0) {
                outOfStockCount++;
            } else {
                productsInStock++;
                
                if (stock <= product.getReorderLevel()) {
                    lowStockCount++;
                }
                
                // Calculate inventory value
                List<InventoryBatch> batches = inventoryBatchRepository
                        .findAvailableBatchesByProductAndBranch(product.getId(), branchId);
                
                for (InventoryBatch batch : batches) {
                    BigDecimal batchValue = batch.getPurchasePrice()
                            .multiply(BigDecimal.valueOf(batch.getQuantityAvailable()));
                    totalInventoryValue = totalInventoryValue.add(batchValue);
                }
            }
        }
        
        // Expiry analytics
        LocalDate today = LocalDate.now();
        LocalDate thirtyDaysFromNow = today.plusDays(30);
        
        int nearExpiryCount = inventoryBatchRepository
                .findByExpiryDateBetweenAndIsActiveAndIsExpired(
                        today, thirtyDaysFromNow, true, false)
                .size();
        
        int expiredCount = inventoryBatchRepository
                .findByExpiryDateBeforeAndIsExpiredFalse(today)
                .size();
        
        return InventoryAnalyticsResponse.builder()
                .branchId(branchId)
                .totalProducts(totalProducts)
                .inStockCount(productsInStock)
                .lowStockCount(lowStockCount)
                .outOfStockCount(outOfStockCount)
                .expiringIn30Days(nearExpiryCount)
                .expiredCount(expiredCount)
                .totalStockValue(totalInventoryValue)
                .inventoryTurnoverRatio(calculateInventoryTurnover(branchId))
                .build();
    }

    @Override
    public List<Map<String, Object>> getTopSellingProducts(Long branchId, int limit) {
        log.info("Fetching top {} selling products for branch: {}", limit, branchId);
        
        // Get sales from last 30 days
        LocalDateTime startDate = LocalDateTime.now().minusDays(30);
        LocalDateTime endDate = LocalDateTime.now();
        
        var sales = saleRepository.findByBranchIdAndSaleDateBetween(branchId, startDate, endDate);
        
        // Aggregate quantities sold by product
        Map<Long, ProductSalesData> productSalesMap = new HashMap<>();
        
        for (var sale : sales) {
            if (sale.getStatus() == SaleStatus.COMPLETED) {
                for (var item : sale.getSaleItems()) {
                    Long productId = item.getProduct().getId();
                    ProductSalesData data = productSalesMap.computeIfAbsent(productId, 
                            k -> new ProductSalesData(item.getProduct()));
                    
                    data.addSale(item.getQuantity(), 
                            item.getUnitPrice().multiply(BigDecimal.valueOf(item.getQuantity())));
                }
            }
        }
        
        // Sort by quantity sold and get top N
        return productSalesMap.values().stream()
                .sorted((a, b) -> Integer.compare(b.getQuantitySold(), a.getQuantitySold()))
                .limit(limit)
                .map(data -> {
                    Map<String, Object> result = new HashMap<>();
                    result.put("productId", data.getProduct().getId());
                    result.put("productCode", data.getProduct().getProductCode());
                    result.put("productName", data.getProduct().getProductName());
                    result.put("quantitySold", data.getQuantitySold());
                    result.put("revenue", data.getRevenue());
                    result.put("category", data.getProduct().getCategory() != null ? 
                            data.getProduct().getCategory().getCategoryName() : "N/A");
                    return result;
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<Map<String, Object>> getSlowMovingProducts(Long branchId, int daysSinceLastSale) {
        log.info("Fetching slow moving products (no sale in {} days) for branch: {}", 
                daysSinceLastSale, branchId);
        
        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(daysSinceLastSale);
        List<Map<String, Object>> slowMovingProducts = new ArrayList<>();
        
        var allProducts = productRepository.findByIsActiveTrue();
        
        for (var product : allProducts) {
            // Check if product has stock at this branch
            Integer stock = inventoryBatchRepository
                    .sumAvailableQuantityByProductAndBranch(product.getId(), branchId);
            
            if (stock != null && stock > 0) {
                // Check last sale date
                var lastSale = saleRepository.findLastSaleForProduct(product.getId(), branchId);
                
                boolean isSlowMoving = false;
                Long daysSinceLastSold = null;
                
                if (lastSale.isEmpty()) {
                    // Never sold
                    isSlowMoving = true;
                } else {
                    LocalDateTime lastSaleDate = lastSale.get().getSaleDate();
                    if (lastSaleDate.isBefore(cutoffDate)) {
                        isSlowMoving = true;
                        daysSinceLastSold = ChronoUnit.DAYS.between(lastSaleDate.toLocalDate(), 
                                LocalDate.now());
                    }
                }
                
                if (isSlowMoving) {
                    // Calculate inventory value
                    var batches = inventoryBatchRepository
                            .findAvailableBatchesByProductAndBranch(product.getId(), branchId);
                    BigDecimal inventoryValue = batches.stream()
                            .map(b -> b.getPurchasePrice()
                                    .multiply(BigDecimal.valueOf(b.getQuantityAvailable())))
                            .reduce(BigDecimal.ZERO, BigDecimal::add);
                    
                    Map<String, Object> slowProduct = new HashMap<>();
                    slowProduct.put("productId", product.getId());
                    slowProduct.put("productCode", product.getProductCode());
                    slowProduct.put("productName", product.getProductName());
                    slowProduct.put("quantityInStock", stock);
                    slowProduct.put("inventoryValue", inventoryValue);
                    slowProduct.put("daysSinceLastSale", daysSinceLastSold);
                    slowProduct.put("neverSold", lastSale.isEmpty());
                    slowProduct.put("category", product.getCategory() != null ? 
                            product.getCategory().getCategoryName() : "N/A");
                    
                    slowMovingProducts.add(slowProduct);
                }
            }
        }
        
        // Sort by days since last sale (descending) or value (for never sold items)
        slowMovingProducts.sort((a, b) -> {
            Boolean aNeverSold = (Boolean) a.get("neverSold");
            Boolean bNeverSold = (Boolean) b.get("neverSold");
            
            if (aNeverSold && bNeverSold) {
                return ((BigDecimal) b.get("inventoryValue"))
                        .compareTo((BigDecimal) a.get("inventoryValue"));
            } else if (aNeverSold) {
                return -1;
            } else if (bNeverSold) {
                return 1;
            } else {
                return ((Long) b.get("daysSinceLastSale"))
                        .compareTo((Long) a.get("daysSinceLastSale"));
            }
        });
        
        return slowMovingProducts;
    }

    @Override
    public Map<String, Object> getRevenueTrends(Long branchId, int days) {
        LocalDate endDate = LocalDate.now();
        LocalDate startDate = endDate.minusDays(days);
        
        SalesAnalyticsResponse analytics = getSalesAnalytics(branchId, startDate, endDate);
        Map<String, Object> trends = new HashMap<>();
        trends.put("totalSales", analytics.getTotalSales());
        trends.put("totalTransactions", analytics.getTotalTransactions());
        trends.put("averageOrderValue", analytics.getAverageOrderValue());
        return trends;
    }

    @Override
    public List<Map<String, Object>> getStaffPerformance(Long branchId, LocalDate startDate, LocalDate endDate) {
        log.info("Fetching staff performance for branch: {} from {} to {}", 
                branchId, startDate, endDate);
        
        LocalDateTime start = startDate.atStartOfDay();
        LocalDateTime end = endDate.atTime(LocalTime.MAX);
        
        var sales = saleRepository.findByBranchIdAndSaleDateBetween(branchId, start, end);
        
        // Aggregate by staff member
        Map<Long, StaffPerformanceData> staffPerformanceMap = new HashMap<>();
        
        for (var sale : sales) {
            if (sale.getStatus() == SaleStatus.COMPLETED && sale.getSoldBy() != null) {
                Long userId = sale.getSoldBy().getId();
                StaffPerformanceData data = staffPerformanceMap.computeIfAbsent(userId,
                        k -> new StaffPerformanceData(sale.getSoldBy()));
                
                data.addSale(sale.getTotalAmount(), sale.getDiscountAmount());
            }
        }
        
        // Convert to list and sort by revenue
        return staffPerformanceMap.values().stream()
                .sorted((a, b) -> b.getTotalRevenue().compareTo(a.getTotalRevenue()))
                .map(data -> {
                    Map<String, Object> result = new HashMap<>();
                    result.put("userId", data.getUser().getId());
                    result.put("username", data.getUser().getUsername());
                    result.put("fullName", data.getUser().getFullName());
                    result.put("role", data.getUser().getRole().name());
                    result.put("totalSales", data.getSalesCount());
                    result.put("totalRevenue", data.getTotalRevenue());
                    result.put("averageSaleValue", data.getAverageSaleValue());
                    result.put("totalDiscount", data.getTotalDiscount());
                    result.put("discountPercentage", data.getDiscountPercentage());
                    return result;
                })
                .collect(Collectors.toList());
    }

    @Override
    public Map<String, Object> getCustomerInsights(Long branchId) {
        log.info("Fetching customer insights for branch: {}", branchId);
        Map<String, Object> insights = new HashMap<>();
        
        // Basic customer counts
        Long totalCustomers = customerRepository.count();
        
        // Get customers with recent purchases (last 30 days)
        LocalDateTime thirtyDaysAgo = LocalDateTime.now().minusDays(30);
        var recentSales = saleRepository.findByBranchIdAndSaleDateBetween(
                branchId, thirtyDaysAgo, LocalDateTime.now());
        
        Set<Long> activeCustomerIds = recentSales.stream()
                .filter(s -> s.getCustomer() != null)
                .map(s -> s.getCustomer().getId())
                .collect(Collectors.toSet());
        
        Long activeCustomers = (long) activeCustomerIds.size();
        
        // Get repeat customers (more than 5 purchases)
        Map<Long, Long> customerPurchaseCount = new HashMap<>();
        var allSales = saleRepository.findByBranchId(branchId);
        
        for (var sale : allSales) {
            if (sale.getCustomer() != null) {
                customerPurchaseCount.merge(sale.getCustomer().getId(), 1L, Long::sum);
            }
        }
        
        Long repeatCustomers = customerPurchaseCount.values().stream()
                .filter(count -> count > 5)
                .count();
        
        // Calculate walk-in vs registered sales
        long walkInSales = recentSales.stream()
                .filter(s -> s.getCustomer() == null)
                .count();
        long registeredSales = recentSales.stream()
                .filter(s -> s.getCustomer() != null)
                .count();
        
        // Average purchase value for registered customers
        BigDecimal registeredCustomerAvg = recentSales.stream()
                .filter(s -> s.getCustomer() != null)
                .map(s -> s.getTotalAmount())
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        if (registeredSales > 0) {
            registeredCustomerAvg = registeredCustomerAvg.divide(
                    BigDecimal.valueOf(registeredSales), 2, RoundingMode.HALF_UP);
        }
        
        insights.put("totalCustomers", totalCustomers);
        insights.put("activeCustomers", activeCustomers);
        insights.put("repeatCustomers", repeatCustomers);
        insights.put("walkInSales", walkInSales);
        insights.put("registeredSales", registeredSales);
        insights.put("registeredCustomerPercentage", 
                recentSales.size() > 0 ? 
                        (registeredSales * 100.0) / recentSales.size() : 0.0);
        insights.put("averagePurchaseValue", registeredCustomerAvg);
        
        return insights;
    }

    @Override
    public Map<String, Integer> getAlertCounts(Long branchId) {
        log.info("Fetching alert counts for branch: {}", branchId);
        Map<String, Integer> alerts = new HashMap<>();
        
        // Count pending PO approvals
        int pendingPOs = purchaseOrderRepository
                .countByBranchIdAndStatus(branchId, "PENDING_APPROVAL");
        alerts.put("pendingPOApprovals", pendingPOs);
        
        // Count pending GRN approvals
        int pendingGRNs = grnRepository
                .countByBranchIdAndStatus(branchId, "PENDING_APPROVAL");
        alerts.put("pendingGRNApprovals", pendingGRNs);
        
        // Count overdue GRN payments
        int overduePayments = grnRepository
                .countOverduePayments(branchId);
        alerts.put("overduePayments", overduePayments);
        
        // Count unread notifications for branch users
        int unreadNotifications = notificationRepository
                .countByIsRead(false);
        alerts.put("unreadNotifications", unreadNotifications);
        
        // Low stock products
        int lowStockCount = 0;
        var products = productRepository.findByIsActiveTrue();
        for (var product : products) {
            Integer stock = inventoryBatchRepository
                    .sumAvailableQuantityByProductAndBranch(product.getId(), branchId);
            if (stock != null && stock <= product.getReorderLevel()) {
                lowStockCount++;
            }
        }
        alerts.put("lowStockCount", lowStockCount);
        
        // Near expiry items (30 days)
        LocalDate today = LocalDate.now();
        LocalDate thirtyDaysFromNow = today.plusDays(30);
        int nearExpiryCount = inventoryBatchRepository
                .countByBranchIdAndExpiryDateBetween(branchId, today, thirtyDaysFromNow);
        alerts.put("nearExpiryCount", nearExpiryCount);
        
        return alerts;
    }

    private Map<String, Object> calculateFinancialMetrics(Long branchId) {
        log.info("Calculating financial metrics for branch: {}", branchId);
        Map<String, Object> metrics = new HashMap<>();
        
        // Calculate pending credit from credit sales
        LocalDateTime last30Days = LocalDateTime.now().minusDays(30);
        var creditSales = saleRepository.findByBranchIdAndSaleDateBetween(
                branchId, last30Days, LocalDateTime.now());
        
        BigDecimal pendingCredit = creditSales.stream()
                .filter(s -> s.getPaymentMethod().name().equals("CREDIT") && 
                             s.getStatus() == SaleStatus.COMPLETED)
                .map(s -> s.getTotalAmount().subtract(s.getPaidAmount()))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        metrics.put("pendingCredit", pendingCredit);
        
        // Calculate accounts payable from GRNs
        var pendingGRNs = grnRepository.findByBranchIdAndPaymentStatus(
                branchId, "UNPAID", "PARTIALLY_PAID");
        
        BigDecimal accountsPayable = pendingGRNs.stream()
                .map(grn -> grn.getBalanceAmount())
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        metrics.put("accountsPayable", accountsPayable);
        
        // Calculate today's cash collection
        LocalDate today = LocalDate.now();
        var todaySales = saleRepository.findByBranchIdAndSaleDateBetween(
                branchId, today.atStartOfDay(), today.atTime(LocalTime.MAX));
        
        BigDecimal cashInHand = todaySales.stream()
                .filter(s -> s.getPaymentMethod().name().equals("CASH") && 
                             s.getStatus() == SaleStatus.COMPLETED)
                .map(s -> s.getPaidAmount())
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        metrics.put("cashInHand", cashInHand);
        
        // Calculate this month's revenue
        LocalDate firstDayOfMonth = today.withDayOfMonth(1);
        var monthlySales = saleRepository.findByBranchIdAndSaleDateBetween(
                branchId, firstDayOfMonth.atStartOfDay(), LocalDateTime.now());
        
        BigDecimal monthlyRevenue = monthlySales.stream()
                .filter(s -> s.getStatus() == SaleStatus.COMPLETED)
                .map(s -> s.getTotalAmount())
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        metrics.put("monthlyRevenue", monthlyRevenue);
        
        return metrics;
    }

    private BigDecimal calculateInventoryTurnover(Long branchId) {
        log.info("Calculating inventory turnover for branch: {}", branchId);
        
        // Calculate for last 30 days
        LocalDateTime startDate = LocalDateTime.now().minusDays(30);
        LocalDateTime endDate = LocalDateTime.now();
        
        // Calculate Cost of Goods Sold (COGS)
        var sales = saleRepository.findByBranchIdAndSaleDateBetween(branchId, startDate, endDate);
        
        BigDecimal cogs = BigDecimal.ZERO;
        for (var sale : sales) {
            if (sale.getStatus() == SaleStatus.COMPLETED) {
                for (var item : sale.getSaleItems()) {
                    if (item.getInventoryBatch() != null) {
                        BigDecimal itemCost = item.getInventoryBatch().getPurchasePrice()
                                .multiply(BigDecimal.valueOf(item.getQuantity()));
                        cogs = cogs.add(itemCost);
                    }
                }
            }
        }
        
        // Calculate current inventory value
        var allProducts = productRepository.findByIsActiveTrue();
        BigDecimal currentInventoryValue = BigDecimal.ZERO;
        
        for (var product : allProducts) {
            var batches = inventoryBatchRepository
                    .findAvailableBatchesByProductAndBranch(product.getId(), branchId);
            
            for (var batch : batches) {
                BigDecimal batchValue = batch.getPurchasePrice()
                        .multiply(BigDecimal.valueOf(batch.getQuantityAvailable()));
                currentInventoryValue = currentInventoryValue.add(batchValue);
            }
        }
        
        // Inventory Turnover = COGS / Average Inventory
        // Using current inventory as approximation for average
        if (currentInventoryValue.compareTo(BigDecimal.ZERO) > 0) {
            return cogs.divide(currentInventoryValue, 2, RoundingMode.HALF_UP);
        }
        
        return BigDecimal.ZERO;
    }
    
    // Inner classes for data aggregation
    private static class ProductSalesData {
        private final Product product;
        private int quantitySold = 0;
        private BigDecimal revenue = BigDecimal.ZERO;
        
        public ProductSalesData(Product product) {
            this.product = product;
        }
        
        public void addSale(int quantity, BigDecimal amount) {
            this.quantitySold += quantity;
            this.revenue = this.revenue.add(amount);
        }
        
        public Product getProduct() { return product; }
        public int getQuantitySold() { return quantitySold; }
        public BigDecimal getRevenue() { return revenue; }
    }
    
    private static class StaffPerformanceData {
        private final User user;
        private int salesCount = 0;
        private BigDecimal totalRevenue = BigDecimal.ZERO;
        private BigDecimal totalDiscount = BigDecimal.ZERO;
        
        public StaffPerformanceData(User user) {
            this.user = user;
        }
        
        public void addSale(BigDecimal amount, BigDecimal discount) {
            this.salesCount++;
            this.totalRevenue = this.totalRevenue.add(amount);
            this.totalDiscount = this.totalDiscount.add(discount);
        }
        
        public User getUser() { return user; }
        public int getSalesCount() { return salesCount; }
        public BigDecimal getTotalRevenue() { return totalRevenue; }
        public BigDecimal getTotalDiscount() { return totalDiscount; }
        
        public BigDecimal getAverageSaleValue() {
            return salesCount > 0 ? 
                    totalRevenue.divide(BigDecimal.valueOf(salesCount), 2, RoundingMode.HALF_UP) :
                    BigDecimal.ZERO;
        }
        
        public BigDecimal getDiscountPercentage() {
            return totalRevenue.compareTo(BigDecimal.ZERO) > 0 ?
                    totalDiscount.divide(totalRevenue, 4, RoundingMode.HALF_UP)
                            .multiply(BigDecimal.valueOf(100)) :
                    BigDecimal.ZERO;
        }
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\finance\BankService.java"   & echo.. 
package com.pharmacy.medlan.service.finance;

public interface BankService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\finance\BankServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.finance;

public class BankServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\finance\CashBookService.java"   & echo.. 
package com.pharmacy.medlan.service.finance;

public interface CashBookService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\finance\CashBookServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.finance;

public class CashBookServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\finance\ChequeService.java"   & echo.. 
package com.pharmacy.medlan.service.finance;

public interface ChequeService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\finance\ChequeServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.finance;

public class ChequeServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\finance\TransactionTypeService.java"   & echo.. 
package com.pharmacy.medlan.service.finance;

public interface TransactionTypeService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\finance\TransactionTypeServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.finance;

public class TransactionTypeServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\ExpiryManagementService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

public interface ExpiryManagementService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\ExpiryManagementServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

public class ExpiryManagementServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\GRNService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.request.inventory.CreateGRNRequest;
import com.pharmacy.medlan.dto.response.inventory.GRNResponse;
import com.pharmacy.medlan.enums.GRNStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

public interface GRNService {

    GRNResponse createGRN(CreateGRNRequest request);

    GRNResponse updateGRN(Long id, CreateGRNRequest request);

    GRNResponse getGRNById(Long id);

    GRNResponse getGRNByNumber(String grnNumber);

    Page<GRNResponse> getAllGRNs(Pageable pageable);

    Page<GRNResponse> getGRNsByBranch(Long branchId, Pageable pageable);

    Page<GRNResponse> getGRNsBySupplier(Long supplierId, Pageable pageable);

    List<GRNResponse> getGRNsByDateRange(LocalDate startDate, LocalDate endDate);

    Page<GRNResponse> getGRNsByStatus(GRNStatus status, Pageable pageable);

    GRNResponse approveGRN(Long id);

    GRNResponse rejectGRN(Long id, String reason);

    GRNResponse cancelGRN(Long id, String reason);

    String generateGRNNumber();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\GRNServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.request.inventory.CreateGRNRequest;
import com.pharmacy.medlan.dto.response.inventory.GRNResponse;
import com.pharmacy.medlan.enums.GRNStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.exception.BusinessRuleViolationException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.GRNMapper;
import com.pharmacy.medlan.model.inventory.GRN;
import com.pharmacy.medlan.model.inventory.GRNLine;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.supplier.PurchaseOrder;
import com.pharmacy.medlan.model.supplier.Supplier;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.inventory.GRNRepository;
import com.pharmacy.medlan.repository.organization.BranchRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import com.pharmacy.medlan.repository.supplier.PurchaseOrderRepository;
import com.pharmacy.medlan.repository.supplier.SupplierRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import com.pharmacy.medlan.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional
public class GRNServiceImpl implements GRNService {

    private final GRNRepository grnRepository;
    private final SupplierRepository supplierRepository;
    private final BranchRepository branchRepository;
    private final ProductRepository productRepository;
    private final PurchaseOrderRepository purchaseOrderRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final UserRepository userRepository;
    private final GRNMapper grnMapper;

    @Override
    public GRNResponse createGRN(CreateGRNRequest request) {
        log.info("Creating new GRN for supplier: {}", request.getSupplierId());

        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        Supplier supplier = supplierRepository.findById(request.getSupplierId())
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found with id: " + request.getSupplierId()));

        Branch branch = branchRepository.findById(request.getBranchId())
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found with id: " + request.getBranchId()));

        PurchaseOrder purchaseOrder = null;
        if (request.getPurchaseOrderId() != null) {
            purchaseOrder = purchaseOrderRepository.findById(request.getPurchaseOrderId())
                    .orElseThrow(() -> new ResourceNotFoundException("PurchaseOrder not found with id: " + request.getPurchaseOrderId()));
        }

        GRN grn = GRN.builder()
                .grnNumber(generateGRNNumber())
                .purchaseOrder(purchaseOrder)
                .supplier(supplier)
                .branch(branch)
                .receivedDate(request.getReceivedDate())
                .supplierInvoiceNumber(request.getSupplierInvoiceNumber())
                .supplierInvoiceDate(request.getSupplierInvoiceDate())
                .status(GRNStatus.DRAFT)
                .paymentStatus(PaymentStatus.UNPAID)
                .remarks(request.getRemarks())
                .receivedBy(currentUser)
                .grnLines(new ArrayList<>())
                .totalAmount(BigDecimal.ZERO)
                .discountAmount(BigDecimal.ZERO)
                .taxAmount(BigDecimal.ZERO)
                .netAmount(BigDecimal.ZERO)
                .paidAmount(BigDecimal.ZERO)
                .balanceAmount(BigDecimal.ZERO)
                .build();

        BigDecimal totalAmount = BigDecimal.ZERO;
        BigDecimal totalDiscount = BigDecimal.ZERO;

        for (CreateGRNRequest.GRNLineRequest lineRequest : request.getItems()) {
            Product product = productRepository.findById(lineRequest.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + lineRequest.getProductId()));

            BigDecimal lineTotal = lineRequest.getCostPrice()
                    .multiply(BigDecimal.valueOf(lineRequest.getQuantity()));
            BigDecimal lineDiscount = lineRequest.getDiscountAmount() != null ? 
                    lineRequest.getDiscountAmount() : BigDecimal.ZERO;

            GRNLine grnLine = GRNLine.builder()
                    .grn(grn)
                    .product(product)
                    .batchNumber(lineRequest.getBatchNumber())
                    .manufacturingDate(lineRequest.getManufacturingDate())
                    .expiryDate(lineRequest.getExpiryDate())
                    .quantityReceived(lineRequest.getQuantity())
                    .freeQuantity(0)
                    .unitPrice(lineRequest.getCostPrice())
                    .discountAmount(lineDiscount)
                    .discountPercent(BigDecimal.ZERO)
                    .gstRate(BigDecimal.ZERO)
                    .gstAmount(BigDecimal.ZERO)
                    .totalAmount(lineTotal.subtract(lineDiscount))
                    .sellingPrice(lineRequest.getSellingPrice())
                    .mrp(lineRequest.getMrp())
                    .build();

            grn.getGrnLines().add(grnLine);
            totalAmount = totalAmount.add(lineTotal);
            totalDiscount = totalDiscount.add(lineDiscount);
        }

        grn.setTotalAmount(totalAmount);
        grn.setDiscountAmount(totalDiscount);
        grn.setNetAmount(totalAmount.subtract(totalDiscount));
        grn.setBalanceAmount(totalAmount.subtract(totalDiscount));

        GRN savedGRN = grnRepository.save(grn);
        log.info("GRN created successfully with number: {}", savedGRN.getGrnNumber());

        return grnMapper.toResponse(savedGRN);
    }

    @Override
    public GRNResponse updateGRN(Long id, CreateGRNRequest request) {
        log.info("Updating GRN with id: {}", id);

        GRN grn = grnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("GRN not found with id: " + id));

        // Only allow updating DRAFT, PENDING, or RECEIVED status GRNs
        if (grn.getStatus() != GRNStatus.DRAFT && 
            grn.getStatus() != GRNStatus.PENDING_APPROVAL && 
            grn.getStatus() != GRNStatus.RECEIVED) {
            throw new BusinessRuleViolationException("Only DRAFT, PENDING_APPROVAL, or RECEIVED GRN can be updated");
        }

        // Update basic fields
        grn.setReceivedDate(request.getReceivedDate());
        grn.setSupplierInvoiceNumber(request.getSupplierInvoiceNumber());
        grn.setSupplierInvoiceDate(request.getSupplierInvoiceDate());
        grn.setRemarks(request.getRemarks());

        // Clear existing lines
        grn.getGrnLines().clear();

        BigDecimal totalAmount = BigDecimal.ZERO;
        BigDecimal totalDiscount = BigDecimal.ZERO;

        // Add updated lines
        for (CreateGRNRequest.GRNLineRequest lineRequest : request.getItems()) {
            Product product = productRepository.findById(lineRequest.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + lineRequest.getProductId()));

            BigDecimal lineTotal = lineRequest.getCostPrice()
                    .multiply(BigDecimal.valueOf(lineRequest.getQuantity()));
            BigDecimal lineDiscount = lineRequest.getDiscountAmount() != null ? 
                    lineRequest.getDiscountAmount() : BigDecimal.ZERO;

            GRNLine grnLine = GRNLine.builder()
                    .grn(grn)
                    .product(product)
                    .batchNumber(lineRequest.getBatchNumber())
                    .manufacturingDate(lineRequest.getManufacturingDate())
                    .expiryDate(lineRequest.getExpiryDate())
                    .quantityReceived(lineRequest.getQuantity())
                    .freeQuantity(0)
                    .unitPrice(lineRequest.getCostPrice())
                    .discountAmount(lineDiscount)
                    .discountPercent(BigDecimal.ZERO)
                    .gstRate(BigDecimal.ZERO)
                    .gstAmount(BigDecimal.ZERO)
                    .totalAmount(lineTotal.subtract(lineDiscount))
                    .sellingPrice(lineRequest.getSellingPrice())
                    .mrp(lineRequest.getMrp())
                    .build();

            grn.getGrnLines().add(grnLine);
            totalAmount = totalAmount.add(lineTotal);
            totalDiscount = totalDiscount.add(lineDiscount);
        }

        grn.setTotalAmount(totalAmount);
        grn.setDiscountAmount(totalDiscount);
        grn.setNetAmount(totalAmount.subtract(totalDiscount));
        grn.setBalanceAmount(totalAmount.subtract(totalDiscount));

        GRN updatedGRN = grnRepository.save(grn);
        log.info("GRN {} updated successfully", updatedGRN.getGrnNumber());

        return grnMapper.toResponse(updatedGRN);
    }

    @Override
    @Transactional(readOnly = true)
    public GRNResponse getGRNById(Long id) {
        GRN grn = grnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("GRN not found with id: " + id));
        return grnMapper.toResponse(grn);
    }

    @Override
    @Transactional(readOnly = true)
    public GRNResponse getGRNByNumber(String grnNumber) {
        GRN grn = grnRepository.findByGrnNumber(grnNumber)
                .orElseThrow(() -> new ResourceNotFoundException("GRN not found with number: " + grnNumber));
        return grnMapper.toResponse(grn);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<GRNResponse> getAllGRNs(Pageable pageable) {
        return grnRepository.findAll(pageable).map(grnMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<GRNResponse> getGRNsByBranch(Long branchId, Pageable pageable) {
        return grnRepository.findAll(pageable).map(grnMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<GRNResponse> getGRNsBySupplier(Long supplierId, Pageable pageable) {
        return grnRepository.findAll(pageable).map(grnMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public List<GRNResponse> getGRNsByDateRange(LocalDate startDate, LocalDate endDate) {
        return grnMapper.toResponseList(grnRepository.findByReceivedDateBetween(startDate, endDate));
    }

    @Override
    @Transactional(readOnly = true)
    public Page<GRNResponse> getGRNsByStatus(GRNStatus status, Pageable pageable) {
        return grnRepository.findAll(pageable).map(grnMapper::toResponse);
    }

    @Override
    public GRNResponse approveGRN(Long id) {
        GRN grn = grnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("GRN not found with id: " + id));

        if (grn.getStatus() != GRNStatus.DRAFT && grn.getStatus() != GRNStatus.PENDING_APPROVAL) {
            throw new BusinessRuleViolationException("Only DRAFT or PENDING_APPROVAL GRN can be approved");
        }

        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        // Create inventory batches
        for (GRNLine line : grn.getGrnLines()) {
            InventoryBatch batch = InventoryBatch.builder()
                    .product(line.getProduct())
                    .branch(grn.getBranch())
                    .batchNumber(line.getBatchNumber())
                    .manufacturingDate(line.getManufacturingDate())
                    .expiryDate(line.getExpiryDate())
                    .quantityReceived(line.getQuantityReceived())
                    .quantityAvailable(line.getQuantityReceived())
                    .quantitySold(0)
                    .quantityDamaged(0)
                    .quantityReturned(0)
                    .purchasePrice(line.getUnitPrice())
                    .sellingPrice(line.getSellingPrice())
                    .mrp(line.getMrp())
                    .isActive(true)
                    .isExpired(false)
                    .grnLine(line)
                    .build();
            inventoryBatchRepository.save(batch);
        }

        grn.setStatus(GRNStatus.RECEIVED);
        grn.setApprovedBy(currentUser);
        grn.setApprovedAt(LocalDateTime.now());

        log.info("GRN {} approved by {}", grn.getGrnNumber(), currentUser != null ? currentUser.getUsername() : "system");
        return grnMapper.toResponse(grnRepository.save(grn));
    }

    @Override
    public GRNResponse rejectGRN(Long id, String reason) {
        GRN grn = grnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("GRN not found with id: " + id));

        if (grn.getStatus() != GRNStatus.DRAFT && grn.getStatus() != GRNStatus.PENDING_APPROVAL) {
            throw new BusinessRuleViolationException("Only DRAFT or PENDING_APPROVAL GRN can be rejected");
        }

        grn.setStatus(GRNStatus.REJECTED);
        grn.setRemarks((grn.getRemarks() != null ? grn.getRemarks() + "\n" : "") + "Rejected: " + reason);

        return grnMapper.toResponse(grnRepository.save(grn));
    }

    @Override
    public GRNResponse cancelGRN(Long id, String reason) {
        GRN grn = grnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("GRN not found with id: " + id));

        if (grn.getStatus() == GRNStatus.RECEIVED) {
            throw new BusinessRuleViolationException("Cannot cancel received GRN. Use Return GRN instead.");
        }

        grn.setStatus(GRNStatus.CANCELLED);
        grn.setRemarks((grn.getRemarks() != null ? grn.getRemarks() + "\n" : "") + "Cancelled: " + reason);

        return grnMapper.toResponse(grnRepository.save(grn));
    }

    @Override
    public String generateGRNNumber() {
        String prefix = "GRN-" + LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy")) + "-";
        Long count = grnRepository.count() + 1;
        return prefix + String.format("%05d", count);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\InventoryBatchService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

public interface InventoryBatchService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\InventoryBatchServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

public class InventoryBatchServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\InventoryScanService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.request.inventory.BarcodeScanRequest;
import com.pharmacy.medlan.dto.response.inventory.ScanResultResponse;
import com.pharmacy.medlan.enums.ScanContext;

import java.util.List;

/**
 * Service for handling barcode/QR code scanning operations in inventory management.
 * Provides context-aware scanning for different use cases like POS, receiving, stock-taking, etc.
 */
public interface InventoryScanService {

    /**
     * Process a barcode scan and return product/batch information
     * @param request The scan request containing barcode and context
     * @return Detailed scan result with product info
     */
    ScanResultResponse processScan(BarcodeScanRequest request);

    /**
     * Quick lookup by barcode for POS operations
     * @param barcode The scanned barcode
     * @param branchId The branch where scan is performed
     * @return Product details optimized for POS
     */
    ScanResultResponse quickLookupForPOS(String barcode, Long branchId);

    /**
     * Batch lookup for receiving goods (GRN)
     * @param barcode The scanned barcode
     * @param branchId The branch
     * @return Product with purchase history and supplier info
     */
    ScanResultResponse lookupForReceiving(String barcode, Long branchId);

    /**
     * Scan for stock-taking/audit
     * @param barcode The scanned barcode
     * @param branchId The branch
     * @return Product with all batch details for verification
     */
    ScanResultResponse lookupForStockTaking(String barcode, Long branchId);

    /**
     * Verify product authenticity via QR code
     * @param qrData The decoded QR code data
     * @return Verification result
     */
    ScanResultResponse verifyProduct(String qrData);

    /**
     * Process batch-level QR code scan
     * @param qrData Decoded QR data containing batch info
     * @param branchId Branch ID
     * @return Batch-specific information
     */
    ScanResultResponse processBatchQRScan(String qrData, Long branchId);

    /**
     * Bulk scan processing for inventory operations
     * @param barcodes List of barcodes to process
     * @param branchId Branch ID
     * @param context The scanning context
     * @return List of scan results
     */
    List<ScanResultResponse> processBulkScans(List<String> barcodes, Long branchId, ScanContext context);

    /**
     * Get scan history for audit trail
     * @param branchId Branch ID
     * @param userId User who performed scans
     * @param limit Number of records to retrieve
     * @return Recent scan history
     */
    List<ScanResultResponse> getScanHistory(Long branchId, Long userId, int limit);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\InventoryScanServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.pharmacy.medlan.dto.request.inventory.BarcodeScanRequest;
import com.pharmacy.medlan.dto.response.inventory.ScanResultResponse;
import com.pharmacy.medlan.enums.AlertLevel;
import com.pharmacy.medlan.enums.ScanContext;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.repository.product.BranchInventoryRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class InventoryScanServiceImpl implements InventoryScanService {

    private final ProductRepository productRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final BranchInventoryRepository branchInventoryRepository;
    private final ObjectMapper objectMapper;

    @Override
    public ScanResultResponse processScan(BarcodeScanRequest request) {
        log.info("Processing scan: {} for context: {}", request.getScanData(), request.getContext());

        if (request.isQrCode()) {
            return processQRCodeScan(request);
        }

        return switch (request.getContext()) {
            case POS -> quickLookupForPOS(request.getScanData(), request.getBranchId());
            case GRN -> lookupForReceiving(request.getScanData(), request.getBranchId());
            case STOCK_TAKING -> lookupForStockTaking(request.getScanData(), request.getBranchId());
            case EXPIRY_CHECK -> lookupForExpiryCheck(request.getScanData(), request.getBranchId());
            case PRICE_CHECK -> lookupForPriceCheck(request.getScanData(), request.getBranchId());
            default -> quickLookupForPOS(request.getScanData(), request.getBranchId());
        };
    }

    @Override
    @Cacheable(value = "productScans", key = "#barcode + '_' + #branchId")
    public ScanResultResponse quickLookupForPOS(String barcode, Long branchId) {
        log.debug("Quick lookup for POS: barcode={}, branch={}", barcode, branchId);

        try {
            Product product = findProductByBarcode(barcode);
            
            ScanResultResponse response = buildBasicResponse(product, barcode, ScanContext.POS);
            
            // Get branch-specific stock
            Optional<BranchInventory> branchInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(product.getId(), branchId);
            
            int stockAtBranch = branchInventory.map(BranchInventory::getQuantityAvailable).orElse(0);
            response.setStockAtBranch(stockAtBranch);
            response.setStockStatus(getStockStatus(stockAtBranch, product.getReorderLevel(), product.getMinimumStock()));

            // Get available batches (FEFO sorted)
            List<InventoryBatch> batches = inventoryBatchRepository
                    .findAvailableBatchesByProductAndBranch(product.getId(), branchId);
            
            List<ScanResultResponse.BatchInfo> batchInfos = batches.stream()
                    .map(this::toBatchInfo)
                    .collect(Collectors.toList());
            response.setAvailableBatches(batchInfos);

            // Set suggested batch (first expiring with stock)
            if (!batchInfos.isEmpty()) {
                response.setSuggestedBatch(batchInfos.get(0));
            }

            // Check if can add to cart
            validateForPOS(response, product, stockAtBranch);

            // Add alerts
            response.setAlerts(generateAlerts(product, batches, stockAtBranch));

            return response;

        } catch (ResourceNotFoundException e) {
            return ScanResultResponse.error(barcode, "Product not found for barcode: " + barcode);
        }
    }

    @Override
    public ScanResultResponse lookupForReceiving(String barcode, Long branchId) {
        log.debug("Lookup for receiving: barcode={}, branch={}", barcode, branchId);

        try {
            Product product = findProductByBarcode(barcode);
            
            ScanResultResponse response = buildBasicResponse(product, barcode, ScanContext.GRN);
            
            // Add supplier information
            Map<String, Object> additionalData = new HashMap<>();
            additionalData.put("preferredSupplier", product.getSupplier());
            additionalData.put("lastPurchasePrice", product.getCostPrice());
            additionalData.put("reorderLevel", product.getReorderLevel());
            additionalData.put("maximumStock", product.getMaximumStock());
            
            // Get current stock for suggested order quantity
            Optional<BranchInventory> branchInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(product.getId(), branchId);
            int currentStock = branchInventory.map(BranchInventory::getQuantityAvailable).orElse(0);
            
            int suggestedOrderQty = Math.max(0, product.getMaximumStock() - currentStock);
            additionalData.put("currentStock", currentStock);
            additionalData.put("suggestedOrderQuantity", suggestedOrderQty);
            
            response.setAdditionalData(additionalData);
            response.setStockAtBranch(currentStock);

            return response;

        } catch (ResourceNotFoundException e) {
            return ScanResultResponse.error(barcode, "Product not found for barcode: " + barcode);
        }
    }

    @Override
    public ScanResultResponse lookupForStockTaking(String barcode, Long branchId) {
        log.debug("Lookup for stock taking: barcode={}, branch={}", barcode, branchId);

        try {
            Product product = findProductByBarcode(barcode);
            
            ScanResultResponse response = buildBasicResponse(product, barcode, ScanContext.STOCK_TAKING);
            
            // Get ALL batches for verification (including expired for audit)
            List<InventoryBatch> allBatches = inventoryBatchRepository
                    .findAllByProductIdAndBranchId(product.getId(), branchId);
            
            List<ScanResultResponse.BatchInfo> batchInfos = allBatches.stream()
                    .map(this::toBatchInfo)
                    .collect(Collectors.toList());
            response.setAvailableBatches(batchInfos);
            
            // Calculate totals
            int totalSystem = allBatches.stream()
                    .filter(b -> !b.getIsExpired())
                    .mapToInt(InventoryBatch::getQuantityAvailable)
                    .sum();
            
            response.setStockAtBranch(totalSystem);
            
            Map<String, Object> additionalData = new HashMap<>();
            additionalData.put("systemStock", totalSystem);
            additionalData.put("totalBatches", allBatches.size());
            additionalData.put("activeBatches", allBatches.stream().filter(b -> b.getIsActive() && !b.getIsExpired()).count());
            additionalData.put("expiredBatches", allBatches.stream().filter(InventoryBatch::getIsExpired).count());
            response.setAdditionalData(additionalData);

            return response;

        } catch (ResourceNotFoundException e) {
            return ScanResultResponse.error(barcode, "Product not found for barcode: " + barcode);
        }
    }

    @Override
    public ScanResultResponse verifyProduct(String qrData) {
        log.debug("Verifying product via QR: {}", qrData);

        try {
            Map<String, Object> qrContent = objectMapper.readValue(qrData, Map.class);
            
            String type = (String) qrContent.get("type");
            
            if ("PRODUCT".equals(type)) {
                Long productId = Long.valueOf(qrContent.get("id").toString());
                String code = (String) qrContent.get("code");
                
                Product product = productRepository.findById(productId)
                        .orElse(null);
                
                ScanResultResponse response = ScanResultResponse.success(
                        UUID.randomUUID().toString(),
                        qrData,
                        ScanContext.VERIFICATION
                );
                
                boolean verified = product != null && product.getProductCode().equals(code);
                
                Map<String, Object> additionalData = new HashMap<>();
                additionalData.put("verified", verified);
                additionalData.put("verificationStatus", verified ? "AUTHENTIC" : "MISMATCH");
                additionalData.put("qrProductCode", code);
                additionalData.put("systemProductCode", product != null ? product.getProductCode() : "NOT_FOUND");
                response.setAdditionalData(additionalData);
                
                if (verified && product != null) {
                    response.setProductId(product.getId());
                    response.setProductCode(product.getProductCode());
                    response.setProductName(product.getProductName());
                }
                
                return response;
            }
            
            return ScanResultResponse.error(qrData, "Invalid QR code type for verification");
            
        } catch (JsonProcessingException e) {
            return ScanResultResponse.error(qrData, "Invalid QR code format");
        }
    }

    @Override
    public ScanResultResponse processBatchQRScan(String qrData, Long branchId) {
        log.debug("Processing batch QR: {} for branch: {}", qrData, branchId);

        try {
            Map<String, Object> qrContent = objectMapper.readValue(qrData, Map.class);
            
            if (!"BATCH".equals(qrContent.get("type"))) {
                return ScanResultResponse.error(qrData, "Not a batch QR code");
            }
            
            Long batchId = Long.valueOf(qrContent.get("batchId").toString());
            
            InventoryBatch batch = inventoryBatchRepository.findById(batchId)
                    .orElseThrow(() -> new ResourceNotFoundException("Batch not found"));
            
            Product product = batch.getProduct();
            
            ScanResultResponse response = buildBasicResponse(product, qrData, ScanContext.GRN);
            response.setSuggestedBatch(toBatchInfo(batch));
            response.setStockAtBranch(batch.getQuantityAvailable());
            
            return response;
            
        } catch (JsonProcessingException e) {
            return ScanResultResponse.error(qrData, "Invalid batch QR code format");
        }
    }

    @Override
    public List<ScanResultResponse> processBulkScans(List<String> barcodes, Long branchId, ScanContext context) {
        log.info("Processing bulk scans: {} barcodes for context: {}", barcodes.size(), context);
        
        return barcodes.stream()
                .map(barcode -> {
                    BarcodeScanRequest request = BarcodeScanRequest.builder()
                            .scanData(barcode)
                            .branchId(branchId)
                            .context(context)
                            .build();
                    return processScan(request);
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<ScanResultResponse> getScanHistory(Long branchId, Long userId, int limit) {
        // This would typically query a scan_history table
        // For now, return empty list as placeholder
        return Collections.emptyList();
    }

    // ==================== Private Helper Methods ====================

    private Product findProductByBarcode(String barcode) {
        // Try barcode first
        Optional<Product> byBarcode = productRepository.findByBarcode(barcode);
        if (byBarcode.isPresent()) {
            return byBarcode.get();
        }
        
        // Try product code
        Optional<Product> byCode = productRepository.findByProductCode(barcode);
        if (byCode.isPresent()) {
            return byCode.get();
        }
        
        throw new ResourceNotFoundException("Product not found for barcode/code: " + barcode);
    }

    private ScanResultResponse buildBasicResponse(Product product, String scannedData, ScanContext context) {
        return ScanResultResponse.builder()
                .scanId(UUID.randomUUID().toString())
                .scannedData(scannedData)
                .context(context)
                .scannedAt(LocalDateTime.now())
                .success(true)
                .productId(product.getId())
                .productCode(product.getProductCode())
                .productName(product.getProductName())
                .genericName(product.getGenericName())
                .barcode(product.getBarcode())
                .manufacturer(product.getManufacturer())
                .categoryName(product.getCategory() != null ? product.getCategory().getCategoryName() : null)
                .subCategoryName(product.getSubCategory() != null ? product.getSubCategory().getSubCategoryName() : null)
                .unitName(product.getUnit() != null ? product.getUnit().getUnitName() : null)
                .dosageForm(product.getDosageForm())
                .strength(product.getStrength())
                .drugSchedule(product.getDrugSchedule())
                .prescriptionRequired(Boolean.TRUE.equals(product.getIsPrescriptionRequired()))
                .isNarcotic(Boolean.TRUE.equals(product.getIsNarcotic()))
                .isRefrigerated(Boolean.TRUE.equals(product.getIsRefrigerated()))
                .mrp(product.getMrp())
                .sellingPrice(product.getSellingPrice())
                .costPrice(product.getCostPrice())
                .gstRate(product.getGstRate())
                .build();
    }

    private ScanResultResponse.BatchInfo toBatchInfo(InventoryBatch batch) {
        long daysToExpiry = ChronoUnit.DAYS.between(LocalDate.now(), batch.getExpiryDate());
        
        return ScanResultResponse.BatchInfo.builder()
                .batchId(batch.getId())
                .batchNumber(batch.getBatchNumber())
                .expiryDate(batch.getExpiryDate())
                .daysToExpiry((int) daysToExpiry)
                .quantityAvailable(batch.getQuantityAvailable())
                .purchasePrice(batch.getPurchasePrice())
                .mrp(batch.getMrp())
                .sellingPrice(batch.getSellingPrice())
                .rackLocation(batch.getRackLocation())
                .isExpired(batch.getIsExpired() || daysToExpiry < 0)
                .isExpiringSoon(daysToExpiry >= 0 && daysToExpiry <= 90)
                .build();
    }

    private String getStockStatus(int stock, int reorderLevel, int minimumStock) {
        if (stock == 0) return "OUT_OF_STOCK";
        if (stock < minimumStock) return "CRITICAL";
        if (stock < reorderLevel) return "LOW_STOCK";
        return "IN_STOCK";
    }

    private void validateForPOS(ScanResultResponse response, Product product, int stock) {
        List<String> blockReasons = new ArrayList<>();
        
        if (stock == 0) {
            blockReasons.add("Out of stock");
        }
        
        if (Boolean.TRUE.equals(product.getIsDiscontinued())) {
            blockReasons.add("Product discontinued");
        }
        
        if (Boolean.FALSE.equals(product.getIsActive())) {
            blockReasons.add("Product not active");
        }
        
        if (Boolean.TRUE.equals(product.getIsPrescriptionRequired())) {
            // This is just a warning, not blocking
            response.setAlerts(List.of(ScanResultResponse.AlertInfo.builder()
                    .level(AlertLevel.WARNING)
                    .alertType("PRESCRIPTION_REQUIRED")
                    .message("This product requires a prescription")
                    .action("Verify prescription before dispensing")
                    .build()));
        }
        
        response.setCanAddToCart(blockReasons.isEmpty());
        if (!blockReasons.isEmpty()) {
            response.setAddToCartBlockReason(String.join("; ", blockReasons));
        }
    }

    private List<ScanResultResponse.AlertInfo> generateAlerts(Product product, List<InventoryBatch> batches, int stock) {
        List<ScanResultResponse.AlertInfo> alerts = new ArrayList<>();
        
        // Stock alerts
        if (stock == 0) {
            alerts.add(ScanResultResponse.AlertInfo.builder()
                    .level(AlertLevel.CRITICAL)
                    .alertType("OUT_OF_STOCK")
                    .message("Product is out of stock")
                    .action("Urgent reorder required")
                    .build());
        } else if (stock < product.getMinimumStock()) {
            alerts.add(ScanResultResponse.AlertInfo.builder()
                    .level(AlertLevel.URGENT)
                    .alertType("BELOW_MINIMUM")
                    .message("Stock below minimum level")
                    .action("Immediate reorder recommended")
                    .build());
        } else if (stock < product.getReorderLevel()) {
            alerts.add(ScanResultResponse.AlertInfo.builder()
                    .level(AlertLevel.WARNING)
                    .alertType("LOW_STOCK")
                    .message("Stock below reorder level")
                    .action("Consider placing reorder")
                    .build());
        }
        
        // Expiry alerts
        for (InventoryBatch batch : batches) {
            long daysToExpiry = ChronoUnit.DAYS.between(LocalDate.now(), batch.getExpiryDate());
            
            if (daysToExpiry < 0) {
                alerts.add(ScanResultResponse.AlertInfo.builder()
                        .level(AlertLevel.CRITICAL)
                        .alertType("EXPIRED")
                        .message("Batch " + batch.getBatchNumber() + " has expired")
                        .action("Remove from sale immediately")
                        .build());
            } else if (daysToExpiry <= 30) {
                alerts.add(ScanResultResponse.AlertInfo.builder()
                        .level(AlertLevel.URGENT)
                        .alertType("EXPIRING_SOON")
                        .message("Batch " + batch.getBatchNumber() + " expires in " + daysToExpiry + " days")
                        .action("Prioritize for sale or return")
                        .build());
            }
        }
        
        // Drug schedule alerts
        if (Boolean.TRUE.equals(product.getIsNarcotic())) {
            alerts.add(ScanResultResponse.AlertInfo.builder()
                    .level(AlertLevel.WARNING)
                    .alertType("NARCOTIC")
                    .message("Schedule X drug - Strict dispensing controls apply")
                    .action("Verify prescription and maintain register")
                    .build());
        }
        
        return alerts;
    }

    private ScanResultResponse lookupForExpiryCheck(String barcode, Long branchId) {
        try {
            Product product = findProductByBarcode(barcode);
            ScanResultResponse response = buildBasicResponse(product, barcode, ScanContext.EXPIRY_CHECK);
            
            List<InventoryBatch> batches = inventoryBatchRepository
                    .findAllByProductIdAndBranchId(product.getId(), branchId);
            
            List<ScanResultResponse.BatchInfo> batchInfos = batches.stream()
                    .map(this::toBatchInfo)
                    .sorted(Comparator.comparing(ScanResultResponse.BatchInfo::getExpiryDate))
                    .collect(Collectors.toList());
            
            response.setAvailableBatches(batchInfos);
            response.setAlerts(generateAlerts(product, batches, 
                    batches.stream().mapToInt(InventoryBatch::getQuantityAvailable).sum()));
            
            return response;
        } catch (ResourceNotFoundException e) {
            return ScanResultResponse.error(barcode, "Product not found");
        }
    }

    private ScanResultResponse lookupForPriceCheck(String barcode, Long branchId) {
        try {
            Product product = findProductByBarcode(barcode);
            ScanResultResponse response = buildBasicResponse(product, barcode, ScanContext.PRICE_CHECK);
            
            Map<String, Object> additionalData = new HashMap<>();
            additionalData.put("mrp", product.getMrp());
            additionalData.put("sellingPrice", product.getSellingPrice());
            additionalData.put("discount", calculateDiscount(product.getMrp(), product.getSellingPrice()));
            additionalData.put("gstRate", product.getGstRate());
            response.setAdditionalData(additionalData);
            
            return response;
        } catch (ResourceNotFoundException e) {
            return ScanResultResponse.error(barcode, "Product not found");
        }
    }

    private BigDecimal calculateDiscount(BigDecimal mrp, BigDecimal sellingPrice) {
        if (mrp == null || sellingPrice == null || mrp.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO;
        }
        return mrp.subtract(sellingPrice)
                .divide(mrp, 4, java.math.RoundingMode.HALF_UP)
                .multiply(BigDecimal.valueOf(100));
    }

    private ScanResultResponse processQRCodeScan(BarcodeScanRequest request) {
        String qrData = request.getScanData();
        
        try {
            Map<String, Object> qrContent = objectMapper.readValue(qrData, Map.class);
            String type = (String) qrContent.get("type");
            
            return switch (type) {
                case "PRODUCT" -> verifyProduct(qrData);
                case "BATCH" -> processBatchQRScan(qrData, request.getBranchId());
                case "INVOICE" -> processInvoiceQRScan(qrData);
                default -> ScanResultResponse.error(qrData, "Unknown QR code type: " + type);
            };
        } catch (JsonProcessingException e) {
            // Not JSON - might be a simple barcode in QR format
            return processScan(BarcodeScanRequest.builder()
                    .scanData(qrData)
                    .branchId(request.getBranchId())
                    .context(request.getContext())
                    .qrCode(false)
                    .build());
        }
    }

    private ScanResultResponse processInvoiceQRScan(String qrData) {
        try {
            Map<String, Object> qrContent = objectMapper.readValue(qrData, Map.class);
            
            ScanResultResponse response = ScanResultResponse.success(
                    UUID.randomUUID().toString(),
                    qrData,
                    ScanContext.SALE_RETURN
            );
            response.setAdditionalData(qrContent);
            
            return response;
        } catch (JsonProcessingException e) {
            return ScanResultResponse.error(qrData, "Invalid invoice QR code");
        }
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\InventoryService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.response.inventory.InventoryBatchResponse;
import com.pharmacy.medlan.dto.response.inventory.InventoryResponse;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

public interface InventoryService {

    InventoryResponse getInventoryByProductAndBranch(Long productId, Long branchId);

    Page<InventoryResponse> getInventoryByBranch(Long branchId, Pageable pageable);

    List<InventoryResponse> getAllLowStockInventory();

    List<InventoryResponse> getAllOutOfStockInventory();

    List<InventoryResponse> getLowStockInventory(Long branchId);

    List<InventoryResponse> getOutOfStockInventory(Long branchId);

    List<InventoryBatchResponse> getBatchesByProduct(Long productId, Long branchId);

    List<InventoryBatchResponse> getExpiringBatches(Long branchId, LocalDate alertDate);

    List<InventoryBatchResponse> getExpiredBatches(Long branchId);

    Integer getAvailableQuantity(Long productId, Long branchId);

    Page<InventoryBatchResponse> getAllExpiringBatches(int days, Pageable pageable);

    Page<InventoryBatchResponse> getAllExpiredBatches(Pageable pageable);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\InventoryServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.response.inventory.InventoryBatchResponse;
import com.pharmacy.medlan.dto.response.inventory.InventoryResponse;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.InventoryMapper;
import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.repository.product.BranchInventoryRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class InventoryServiceImpl implements InventoryService {

    private final BranchInventoryRepository branchInventoryRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final InventoryMapper inventoryMapper;

    @Override
    public InventoryResponse getInventoryByProductAndBranch(Long productId, Long branchId) {
        BranchInventory inventory = branchInventoryRepository
                .findByProductIdAndBranchId(productId, branchId)
                .orElseThrow(() -> new ResourceNotFoundException("Inventory not found for product and branch"));

        List<InventoryBatch> batches = inventoryBatchRepository
                .findByProductIdAndBranchId(productId, branchId);

        return inventoryMapper.toInventoryResponse(inventory, batches);
    }

    @Override
    public Page<InventoryResponse> getInventoryByBranch(Long branchId, Pageable pageable) {
        Page<BranchInventory> inventoryPage = branchInventoryRepository.findByBranchId(branchId, pageable);

        List<InventoryResponse> responses = inventoryPage.getContent().stream()
                .map(inv -> {
                    List<InventoryBatch> batches = inventoryBatchRepository
                            .findByProductIdAndBranchId(inv.getProduct().getId(), branchId);
                    return inventoryMapper.toInventoryResponse(inv, batches);
                })
                .collect(Collectors.toList());

        return new PageImpl<>(responses, pageable, inventoryPage.getTotalElements());
    }

    @Override
    public List<InventoryResponse> getAllLowStockInventory() {
        List<BranchInventory> allLowStock = branchInventoryRepository.findAllLowStock();

        return allLowStock.stream()
                .map(inv -> {
                    List<InventoryBatch> batches = inventoryBatchRepository
                            .findByProductIdAndBranchId(inv.getProduct().getId(), inv.getBranch().getId());
                    return inventoryMapper.toInventoryResponse(inv, batches);
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<InventoryResponse> getAllOutOfStockInventory() {
        List<BranchInventory> allOutOfStock = branchInventoryRepository.findAllOutOfStock();

        return allOutOfStock.stream()
                .map(inv -> {
                    List<InventoryBatch> batches = inventoryBatchRepository
                            .findByProductIdAndBranchId(inv.getProduct().getId(), inv.getBranch().getId());
                    return inventoryMapper.toInventoryResponse(inv, batches);
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<InventoryResponse> getLowStockInventory(Long branchId) {
        List<BranchInventory> lowStock = branchInventoryRepository.findLowStockByBranch(branchId);

        return lowStock.stream()
                .map(inv -> {
                    List<InventoryBatch> batches = inventoryBatchRepository
                            .findByProductIdAndBranchId(inv.getProduct().getId(), branchId);
                    return inventoryMapper.toInventoryResponse(inv, batches);
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<InventoryResponse> getOutOfStockInventory(Long branchId) {
        List<BranchInventory> outOfStock = branchInventoryRepository.findOutOfStockByBranch(branchId);

        return outOfStock.stream()
                .map(inv -> {
                    List<InventoryBatch> batches = inventoryBatchRepository
                            .findByProductIdAndBranchId(inv.getProduct().getId(), branchId);
                    return inventoryMapper.toInventoryResponse(inv, batches);
                })
                .collect(Collectors.toList());
    }

    @Override
    public List<InventoryBatchResponse> getBatchesByProduct(Long productId, Long branchId) {
        List<InventoryBatch> batches = inventoryBatchRepository
                .findByProductIdAndBranchId(productId, branchId);
        return inventoryMapper.toBatchResponseList(batches);
    }

    @Override
    public List<InventoryBatchResponse> getExpiringBatches(Long branchId, LocalDate alertDate) {
        List<InventoryBatch> batches = inventoryBatchRepository
                .findExpiringBatchesForAlert(branchId, alertDate);
        return inventoryMapper.toBatchResponseList(batches);
    }

    @Override
    public List<InventoryBatchResponse> getExpiredBatches(Long branchId) {
        List<InventoryBatch> batches = inventoryBatchRepository.findExpiredBatches(LocalDate.now());
        return inventoryMapper.toBatchResponseList(
                batches.stream()
                        .filter(b -> b.getBranch().getId().equals(branchId))
                        .collect(Collectors.toList())
        );
    }

    @Override
    public Integer getAvailableQuantity(Long productId, Long branchId) {
        return branchInventoryRepository.findByProductIdAndBranchId(productId, branchId)
                .map(BranchInventory::getQuantityAvailable)
                .orElse(0);
    }

    @Override
    public Page<InventoryBatchResponse> getAllExpiringBatches(int days, Pageable pageable) {
        LocalDate alertDate = LocalDate.now().plusDays(days);
        Page<InventoryBatch> batchesPage = inventoryBatchRepository
                .findAllExpiringBatches(alertDate, pageable);
        
        List<InventoryBatchResponse> responses = inventoryMapper.toBatchResponseList(
                batchesPage.getContent());
        
        return new PageImpl<>(responses, pageable, batchesPage.getTotalElements());
    }

    @Override
    public Page<InventoryBatchResponse> getAllExpiredBatches(Pageable pageable) {
        Page<InventoryBatch> batchesPage = inventoryBatchRepository
                .findAllExpiredBatches(LocalDate.now(), pageable);
        
        List<InventoryBatchResponse> responses = inventoryMapper.toBatchResponseList(
                batchesPage.getContent());
        
        return new PageImpl<>(responses, pageable, batchesPage.getTotalElements());
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\InventoryTransactionService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

public interface InventoryTransactionService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\InventoryTransactionServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

public class InventoryTransactionServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\ProductBinCardService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

public interface ProductBinCardService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\ProductBinCardServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

public class ProductBinCardServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\RGRNService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.request.inventory.CreateRGRNRequest;
import com.pharmacy.medlan.dto.response.inventory.RGRNResponse;
import com.pharmacy.medlan.enums.PaymentStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

public interface RGRNService {
    
    RGRNResponse createRGRN(CreateRGRNRequest request);
    
    RGRNResponse getById(Long id);
    
    RGRNResponse getByRgrnNumber(String rgrnNumber);
    
    Page<RGRNResponse> getAllRGRNs(Pageable pageable);
    
    List<RGRNResponse> getBySupplier(Long supplierId);
    
    List<RGRNResponse> getByBranch(Long branchId);
    
    List<RGRNResponse> getByOriginalGrn(Long originalGrnId);
    
    List<RGRNResponse> getByRefundStatus(PaymentStatus refundStatus);
    
    List<RGRNResponse> getByDateRange(LocalDate startDate, LocalDate endDate);
    
    RGRNResponse updateRefundStatus(Long id, PaymentStatus refundStatus);
    
    void deleteRGRN(Long id);
    
    String generateRgrnNumber();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\RGRNServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.request.inventory.CreateRGRNRequest;
import com.pharmacy.medlan.dto.response.inventory.RGRNResponse;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.RGRNMapper;
import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.inventory.GRN;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.inventory.RGRN;
import com.pharmacy.medlan.model.inventory.RGRNLine;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.supplier.Supplier;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.product.BranchInventoryRepository;
import com.pharmacy.medlan.repository.inventory.GRNRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.inventory.RGRNRepository;
import com.pharmacy.medlan.repository.organization.BranchRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import com.pharmacy.medlan.repository.supplier.SupplierRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import com.pharmacy.medlan.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.Year;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional
public class RGRNServiceImpl implements RGRNService {

    private final RGRNRepository rgrnRepository;
    private final GRNRepository grnRepository;
    private final SupplierRepository supplierRepository;
    private final BranchRepository branchRepository;
    private final ProductRepository productRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final BranchInventoryRepository branchInventoryRepository;
    private final UserRepository userRepository;
    private final RGRNMapper rgrnMapper;

    @Override
    public RGRNResponse createRGRN(CreateRGRNRequest request) {
        Supplier supplier = supplierRepository.findById(request.getSupplierId())
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found"));
        Branch branch = branchRepository.findById(request.getBranchId())
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found"));
        
        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        RGRN rgrn = RGRN.builder()
                .rgrnNumber(generateRgrnNumber())
                .supplier(supplier)
                .branch(branch)
                .returnDate(LocalDate.now())
                .returnReason(request.getReturnReason())
                .refundStatus(PaymentStatus.PENDING)
                .returnedBy(currentUser)
                .remarks(request.getRemarks())
                .build();

        if (request.getOriginalGrnId() != null) {
            GRN originalGrn = grnRepository.findById(request.getOriginalGrnId())
                    .orElseThrow(() -> new ResourceNotFoundException("Original GRN not found"));
            rgrn.setOriginalGrn(originalGrn);
        }

        BigDecimal totalReturnAmount = BigDecimal.ZERO;

        for (CreateRGRNRequest.RGRNLineRequest lineRequest : request.getLines()) {
            Product product = productRepository.findById(lineRequest.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found: " + lineRequest.getProductId()));

            BigDecimal lineTotal = lineRequest.getUnitPrice()
                    .multiply(BigDecimal.valueOf(lineRequest.getQuantityReturned()));

            RGRNLine line = RGRNLine.builder()
                    .rgrn(rgrn)
                    .product(product)
                    .productName(product.getProductName())
                    .batchNumber(lineRequest.getBatchNumber())
                    .quantityReturned(lineRequest.getQuantityReturned())
                    .unitPrice(lineRequest.getUnitPrice())
                    .totalAmount(lineTotal)
                    .returnReason(lineRequest.getReturnReason())
                    .build();

            if (lineRequest.getInventoryBatchId() != null) {
                InventoryBatch batch = inventoryBatchRepository.findById(lineRequest.getInventoryBatchId())
                        .orElseThrow(() -> new ResourceNotFoundException("Inventory batch not found"));
                line.setInventoryBatch(batch);
            }

            // Deduct from inventory
            BranchInventory branchInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(product.getId(), branch.getId())
                    .orElseThrow(() -> new ResourceNotFoundException(
                            "Branch inventory not found for product: " + product.getProductName()));

            if (branchInventory.getQuantityAvailable() < lineRequest.getQuantityReturned()) {
                throw new IllegalStateException("Insufficient stock for return: " + product.getProductName());
            }

            branchInventory.setQuantityAvailable(branchInventory.getQuantityAvailable() - lineRequest.getQuantityReturned());
            branchInventory.setQuantityOnHand(branchInventory.getQuantityOnHand() - lineRequest.getQuantityReturned());
            branchInventoryRepository.save(branchInventory);

            rgrn.getRgrnLines().add(line);
            totalReturnAmount = totalReturnAmount.add(lineTotal);
        }

        rgrn.setTotalReturnAmount(totalReturnAmount);
        rgrn = rgrnRepository.save(rgrn);
        log.info("RGRN created: {}", rgrn.getRgrnNumber());

        return rgrnMapper.toResponse(rgrn);
    }

    @Override
    @Transactional(readOnly = true)
    public RGRNResponse getById(Long id) {
        RGRN rgrn = rgrnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("RGRN not found"));
        return rgrnMapper.toResponse(rgrn);
    }

    @Override
    @Transactional(readOnly = true)
    public RGRNResponse getByRgrnNumber(String rgrnNumber) {
        RGRN rgrn = rgrnRepository.findByRgrnNumber(rgrnNumber)
                .orElseThrow(() -> new ResourceNotFoundException("RGRN not found"));
        return rgrnMapper.toResponse(rgrn);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<RGRNResponse> getAllRGRNs(Pageable pageable) {
        return rgrnRepository.findAll(pageable).map(rgrnMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public List<RGRNResponse> getBySupplier(Long supplierId) {
        return rgrnMapper.toResponseList(rgrnRepository.findBySupplierId(supplierId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<RGRNResponse> getByBranch(Long branchId) {
        return rgrnMapper.toResponseList(rgrnRepository.findByBranchId(branchId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<RGRNResponse> getByOriginalGrn(Long originalGrnId) {
        return rgrnMapper.toResponseList(rgrnRepository.findByOriginalGrnId(originalGrnId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<RGRNResponse> getByRefundStatus(PaymentStatus refundStatus) {
        return rgrnMapper.toResponseList(rgrnRepository.findByRefundStatus(refundStatus));
    }

    @Override
    @Transactional(readOnly = true)
    public List<RGRNResponse> getByDateRange(LocalDate startDate, LocalDate endDate) {
        return rgrnMapper.toResponseList(rgrnRepository.findByReturnDateBetween(startDate, endDate));
    }

    @Override
    public RGRNResponse updateRefundStatus(Long id, PaymentStatus refundStatus) {
        RGRN rgrn = rgrnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("RGRN not found"));

        rgrn.setRefundStatus(refundStatus);
        rgrn = rgrnRepository.save(rgrn);
        log.info("RGRN {} refund status updated to {}", rgrn.getRgrnNumber(), refundStatus);

        return rgrnMapper.toResponse(rgrn);
    }

    @Override
    public void deleteRGRN(Long id) {
        RGRN rgrn = rgrnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("RGRN not found"));

        if (rgrn.getRefundStatus() == PaymentStatus.PAID) {
            throw new IllegalStateException("Cannot delete RGRN with completed refund");
        }

        // Restore inventory before deleting
        for (RGRNLine line : rgrn.getRgrnLines()) {
            BranchInventory branchInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(line.getProduct().getId(), rgrn.getBranch().getId())
                    .orElse(null);

            if (branchInventory != null) {
                branchInventory.setQuantityAvailable(branchInventory.getQuantityAvailable() + line.getQuantityReturned());
                branchInventory.setQuantityOnHand(branchInventory.getQuantityOnHand() + line.getQuantityReturned());
                branchInventoryRepository.save(branchInventory);
            }
        }

        rgrnRepository.delete(rgrn);
        log.info("RGRN deleted: {}", rgrn.getRgrnNumber());
    }

    @Override
    public String generateRgrnNumber() {
        long count = rgrnRepository.count() + 1;
        return String.format("RGRN-%d-%05d", Year.now().getValue(), count);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\StockTransferService.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.request.inventory.ApproveStockTransferRequest;
import com.pharmacy.medlan.dto.request.inventory.CreateStockTransferRequest;
import com.pharmacy.medlan.dto.response.inventory.StockTransferResponse;
import com.pharmacy.medlan.enums.StockTransferStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

public interface StockTransferService {
    
    StockTransferResponse createStockTransfer(CreateStockTransferRequest request);
    
    StockTransferResponse getById(Long id);
    
    StockTransferResponse getByTransferNumber(String transferNumber);
    
    Page<StockTransferResponse> getAllStockTransfers(Pageable pageable);
    
    List<StockTransferResponse> getByFromBranch(Long fromBranchId);
    
    List<StockTransferResponse> getByToBranch(Long toBranchId);
    
    List<StockTransferResponse> getByBranch(Long branchId);
    
    List<StockTransferResponse> getByStatus(StockTransferStatus status);
    
    List<StockTransferResponse> getByDateRange(LocalDate startDate, LocalDate endDate);
    
    StockTransferResponse approveStockTransfer(Long id, ApproveStockTransferRequest request);
    
    StockTransferResponse receiveStockTransfer(Long id, Long receivedByUserId);
    
    StockTransferResponse rejectStockTransfer(Long id, String reason);
    
    StockTransferResponse cancelStockTransfer(Long id, String reason);
    
    String generateTransferNumber();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\inventory\StockTransferServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.inventory;

import com.pharmacy.medlan.dto.request.inventory.ApproveStockTransferRequest;
import com.pharmacy.medlan.dto.request.inventory.CreateStockTransferRequest;
import com.pharmacy.medlan.dto.response.inventory.StockTransferResponse;
import com.pharmacy.medlan.enums.StockTransferStatus;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.StockTransferMapper;
import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.inventory.StockTransfer;
import com.pharmacy.medlan.model.inventory.StockTransferItem;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.product.BranchInventoryRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.inventory.StockTransferRepository;
import com.pharmacy.medlan.repository.organization.BranchRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import com.pharmacy.medlan.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Year;
import java.util.ArrayList;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional
public class StockTransferServiceImpl implements StockTransferService {

    private final StockTransferRepository stockTransferRepository;
    private final BranchRepository branchRepository;
    private final ProductRepository productRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final BranchInventoryRepository branchInventoryRepository;
    private final UserRepository userRepository;
    private final StockTransferMapper stockTransferMapper;

    @Override
    public StockTransferResponse createStockTransfer(CreateStockTransferRequest request) {
        Branch fromBranch = branchRepository.findById(request.getFromBranchId())
                .orElseThrow(() -> new ResourceNotFoundException("Source branch not found"));
        Branch toBranch = branchRepository.findById(request.getToBranchId())
                .orElseThrow(() -> new ResourceNotFoundException("Destination branch not found"));
        
        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        StockTransfer stockTransfer = StockTransfer.builder()
                .transferNumber(generateTransferNumber())
                .fromBranch(fromBranch)
                .toBranch(toBranch)
                .transferDate(LocalDate.now())
                .expectedReceiptDate(request.getExpectedReceiptDate())
                .status(StockTransferStatus.PENDING)
                .initiatedBy(currentUser)
                .remarks(request.getRemarks())
                .items(new ArrayList<>())
                .build();

        for (CreateStockTransferRequest.StockTransferItemRequest itemRequest : request.getItems()) {
            Product product = productRepository.findById(itemRequest.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found: " + itemRequest.getProductId()));

            StockTransferItem item = StockTransferItem.builder()
                    .stockTransfer(stockTransfer)
                    .product(product)
                    .quantityTransferred(itemRequest.getQuantityTransferred())
                    .quantityReceived(0)
                    .remarks(itemRequest.getRemarks())
                    .build();

            if (itemRequest.getInventoryBatchId() != null) {
                InventoryBatch batch = inventoryBatchRepository.findById(itemRequest.getInventoryBatchId())
                        .orElseThrow(() -> new ResourceNotFoundException("Inventory batch not found"));
                item.setInventoryBatch(batch);
            }

            stockTransfer.getItems().add(item);
        }

        stockTransfer = stockTransferRepository.save(stockTransfer);
        log.info("Stock transfer created: {}", stockTransfer.getTransferNumber());

        return stockTransferMapper.toResponse(stockTransfer);
    }

    @Override
    @Transactional(readOnly = true)
    public StockTransferResponse getById(Long id) {
        StockTransfer stockTransfer = stockTransferRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Stock transfer not found"));
        return stockTransferMapper.toResponse(stockTransfer);
    }

    @Override
    @Transactional(readOnly = true)
    public StockTransferResponse getByTransferNumber(String transferNumber) {
        StockTransfer stockTransfer = stockTransferRepository.findByTransferNumber(transferNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Stock transfer not found"));
        return stockTransferMapper.toResponse(stockTransfer);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<StockTransferResponse> getAllStockTransfers(Pageable pageable) {
        return stockTransferRepository.findAll(pageable).map(stockTransferMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public List<StockTransferResponse> getByFromBranch(Long branchId) {
        return stockTransferMapper.toResponseList(stockTransferRepository.findByFromBranchId(branchId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<StockTransferResponse> getByToBranch(Long branchId) {
        return stockTransferMapper.toResponseList(stockTransferRepository.findByToBranchId(branchId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<StockTransferResponse> getByBranch(Long branchId) {
        List<StockTransfer> fromTransfers = stockTransferRepository.findByFromBranchId(branchId);
        List<StockTransfer> toTransfers = stockTransferRepository.findByToBranchId(branchId);
        List<StockTransfer> combined = new ArrayList<>(fromTransfers);
        combined.addAll(toTransfers);
        return stockTransferMapper.toResponseList(combined);
    }

    @Override
    @Transactional(readOnly = true)
    public List<StockTransferResponse> getByStatus(StockTransferStatus status) {
        return stockTransferMapper.toResponseList(stockTransferRepository.findByStatus(status));
    }

    @Override
    @Transactional(readOnly = true)
    public List<StockTransferResponse> getByDateRange(LocalDate startDate, LocalDate endDate) {
        return stockTransferMapper.toResponseList(stockTransferRepository.findByTransferDateBetween(startDate, endDate));
    }

    @Override
    public StockTransferResponse approveStockTransfer(Long id, ApproveStockTransferRequest request) {
        StockTransfer stockTransfer = stockTransferRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Stock transfer not found"));

        if (stockTransfer.getStatus() != StockTransferStatus.PENDING) {
            throw new IllegalStateException("Only PENDING transfers can be approved");
        }

        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        // Deduct from source branch inventory
        for (StockTransferItem item : stockTransfer.getItems()) {
            BranchInventory sourceInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(item.getProduct().getId(), stockTransfer.getFromBranch().getId())
                    .orElseThrow(() -> new ResourceNotFoundException(
                            "Source branch inventory not found for product: " + item.getProduct().getProductName()));

            if (sourceInventory.getQuantityAvailable() < item.getQuantityTransferred()) {
                throw new IllegalStateException("Insufficient stock in source branch for: " + item.getProduct().getProductName());
            }

            sourceInventory.setQuantityAvailable(sourceInventory.getQuantityAvailable() - item.getQuantityTransferred());
            sourceInventory.setQuantityAllocated(sourceInventory.getQuantityAllocated() + item.getQuantityTransferred());
            branchInventoryRepository.save(sourceInventory);
        }

        stockTransfer.setStatus(StockTransferStatus.APPROVED);
        stockTransfer.setApprovedBy(currentUser);
        stockTransfer.setApprovedAt(LocalDateTime.now());

        stockTransfer = stockTransferRepository.save(stockTransfer);
        log.info("Stock transfer approved: {}", stockTransfer.getTransferNumber());

        return stockTransferMapper.toResponse(stockTransfer);
    }

    @Override
    public StockTransferResponse receiveStockTransfer(Long id, Long receivedByUserId) {
        StockTransfer stockTransfer = stockTransferRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Stock transfer not found"));

        if (stockTransfer.getStatus() != StockTransferStatus.IN_TRANSIT && 
            stockTransfer.getStatus() != StockTransferStatus.APPROVED) {
            throw new IllegalStateException("Only IN_TRANSIT or APPROVED transfers can be received");
        }

        User receivedByUser = userRepository.findById(receivedByUserId)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        // Add to destination branch inventory, complete source deduction
        for (StockTransferItem item : stockTransfer.getItems()) {
            // Complete deduction from source
            BranchInventory sourceInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(item.getProduct().getId(), stockTransfer.getFromBranch().getId())
                    .orElse(null);

            if (sourceInventory != null) {
                sourceInventory.setQuantityAllocated(
                        Math.max(0, sourceInventory.getQuantityAllocated() - item.getQuantityTransferred()));
                sourceInventory.setQuantityOnHand(
                        Math.max(0, sourceInventory.getQuantityOnHand() - item.getQuantityTransferred()));
                branchInventoryRepository.save(sourceInventory);
            }

            // Add to destination
            BranchInventory destInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(item.getProduct().getId(), stockTransfer.getToBranch().getId())
                    .orElse(null);

            if (destInventory == null) {
                destInventory = BranchInventory.builder()
                        .product(item.getProduct())
                        .branch(stockTransfer.getToBranch())
                        .quantityOnHand(0)
                        .quantityAllocated(0)
                        .quantityAvailable(0)
                        .build();
            }

            destInventory.setQuantityOnHand(destInventory.getQuantityOnHand() + item.getQuantityTransferred());
            destInventory.setQuantityAvailable(destInventory.getQuantityAvailable() + item.getQuantityTransferred());
            branchInventoryRepository.save(destInventory);

            item.setQuantityReceived(item.getQuantityTransferred());
        }

        stockTransfer.setStatus(StockTransferStatus.RECEIVED);
        stockTransfer.setReceivedBy(receivedByUser);
        stockTransfer.setActualReceiptDate(LocalDate.now());

        stockTransfer = stockTransferRepository.save(stockTransfer);
        log.info("Stock transfer received: {}", stockTransfer.getTransferNumber());

        return stockTransferMapper.toResponse(stockTransfer);
    }

    @Override
    public StockTransferResponse rejectStockTransfer(Long id, String reason) {
        StockTransfer stockTransfer = stockTransferRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Stock transfer not found"));

        if (stockTransfer.getStatus() != StockTransferStatus.PENDING) {
            throw new IllegalStateException("Only PENDING transfers can be rejected");
        }

        stockTransfer.setStatus(StockTransferStatus.REJECTED);
        stockTransfer.setRemarks((stockTransfer.getRemarks() != null ? stockTransfer.getRemarks() + "\n" : "") + "Rejected: " + reason);

        stockTransfer = stockTransferRepository.save(stockTransfer);
        log.info("Stock transfer rejected: {}", stockTransfer.getTransferNumber());

        return stockTransferMapper.toResponse(stockTransfer);
    }

    @Override
    public StockTransferResponse cancelStockTransfer(Long id, String reason) {
        StockTransfer stockTransfer = stockTransferRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Stock transfer not found"));

        if (stockTransfer.getStatus() == StockTransferStatus.RECEIVED) {
            throw new IllegalStateException("Cannot cancel received transfers");
        }

        // Restore allocated inventory if it was approved
        if (stockTransfer.getStatus() == StockTransferStatus.APPROVED || 
            stockTransfer.getStatus() == StockTransferStatus.IN_TRANSIT) {
            for (StockTransferItem item : stockTransfer.getItems()) {
                BranchInventory sourceInventory = branchInventoryRepository
                        .findByProductIdAndBranchId(item.getProduct().getId(), stockTransfer.getFromBranch().getId())
                        .orElse(null);

                if (sourceInventory != null) {
                    sourceInventory.setQuantityAvailable(sourceInventory.getQuantityAvailable() + item.getQuantityTransferred());
                    sourceInventory.setQuantityAllocated(
                            Math.max(0, sourceInventory.getQuantityAllocated() - item.getQuantityTransferred()));
                    branchInventoryRepository.save(sourceInventory);
                }
            }
        }

        stockTransfer.setStatus(StockTransferStatus.CANCELLED);
        stockTransfer.setRemarks((stockTransfer.getRemarks() != null ? stockTransfer.getRemarks() + "\n" : "") + "Cancelled: " + reason);

        stockTransfer = stockTransferRepository.save(stockTransfer);
        log.info("Stock transfer cancelled: {}", stockTransfer.getTransferNumber());

        return stockTransferMapper.toResponse(stockTransfer);
    }

    @Override
    public String generateTransferNumber() {
        long count = stockTransferRepository.count() + 1;
        return String.format("ST-%d-%05d", Year.now().getValue(), count);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\migration\LegacyDataMigrationService.java"   & echo.. 
package com.pharmacy.medlan.service.migration;

public interface LegacyDataMigrationService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\migration\LegacyDataMigrationServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.migration;

public class LegacyDataMigrationServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\notification\NotificationService.java"   & echo.. 
package com.pharmacy.medlan.service.notification;

import com.pharmacy.medlan.dto.request.NotificationRequest;
import com.pharmacy.medlan.enums.NotificationType;
import com.pharmacy.medlan.model.notification.Notification;

import java.util.List;

/**
 * Service interface for handling notifications
 */
public interface NotificationService {
    
    /**
     * Send a notification to a user
     */
    Notification sendNotification(NotificationRequest request);
    
    /**
     * Send notification to multiple users
     */
    List<Notification> sendBulkNotifications(NotificationRequest request, List<Long> userIds);
    
    /**
     * Send notification to all users in a branch
     */
    List<Notification> sendToBranch(Long branchId, NotificationRequest request);
    
    /**
     * Send notification to users with specific role in a branch
     */
    List<Notification> sendToRole(Long branchId, String role, NotificationRequest request);
    
    /**
     * Get all notifications for a user
     */
    List<Notification> getUserNotifications(Long userId);
    
    /**
     * Get unread notifications for a user
     */
    List<Notification> getUnreadNotifications(Long userId);
    
    /**
     * Get unread notification count
     */
    int getUnreadCount(Long userId);
    
    /**
     * Mark notification as read
     */
    void markAsRead(Long notificationId);
    
    /**
     * Mark all notifications as read for a user
     */
    void markAllAsRead(Long userId);
    
    /**
     * Delete a notification
     */
    void deleteNotification(Long notificationId);
    
    /**
     * Delete all notifications for a user
     */
    void deleteAllNotifications(Long userId);
    
    /**
     * Send system alert notification
     */
    void sendSystemAlert(String title, String message, NotificationType type, Long branchId);
    
    /**
     * Send low stock alert
     */
    void sendLowStockAlert(Long productId, Long branchId, int currentStock, int reorderLevel);
    
    /**
     * Send expiry alert
     */
    void sendExpiryAlert(Long batchId, Long branchId, int daysToExpiry);
    
    /**
     * Send payment reminder
     */
    void sendPaymentReminder(Long invoiceId, Long customerId);
    
    /**
     * Send email notification
     */
    void sendEmailNotification(String to, String subject, String body);
    
    /**
     * Send SMS notification (if configured)
     */
    void sendSmsNotification(String phoneNumber, String message);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\notification\NotificationServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.notification;

import com.pharmacy.medlan.dto.request.NotificationRequest;
import com.pharmacy.medlan.enums.NotificationType;
import com.pharmacy.medlan.model.notification.Notification;
import com.pharmacy.medlan.model.user.BranchStaff;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.notification.NotificationRepository;
import com.pharmacy.medlan.repository.user.BranchStaffRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Implementation of NotificationService for handling all notification operations
 */
@Slf4j
@Service
@Transactional
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final UserRepository userRepository;
    private final BranchStaffRepository branchStaffRepository;
    private final JavaMailSender mailSender;

    @Autowired
    public NotificationServiceImpl(
            NotificationRepository notificationRepository,
            UserRepository userRepository,
            BranchStaffRepository branchStaffRepository,
            @Autowired(required = false) JavaMailSender mailSender) {
        this.notificationRepository = notificationRepository;
        this.userRepository = userRepository;
        this.branchStaffRepository = branchStaffRepository;
        this.mailSender = mailSender;
    }

    @Override
    public Notification sendNotification(NotificationRequest request) {
        log.debug("Sending notification to user: {}", request.getUserId());
        
        User user = null;
        if (request.getUserId() != null) {
            user = userRepository.findById(request.getUserId())
                    .orElseThrow(() -> new EntityNotFoundException("User not found: " + request.getUserId()));
        }
        
        Notification notification = Notification.builder()
                .user(user)
                .type(request.getType())
                .title(request.getTitle())
                .message(request.getMessage())
                .referenceId(request.getReferenceId())
                .referenceType(request.getReferenceType())
                .priority(request.getPriority() != null ? request.getPriority().name() : "NORMAL")
                .isRead(false)
                .build();
        
        Notification saved = notificationRepository.save(notification);
        log.info("Notification created with ID: {} for user: {}", saved.getId(), request.getUserId());
        
        return saved;
    }

    @Override
    public List<Notification> sendBulkNotifications(NotificationRequest request, List<Long> userIds) {
        log.debug("Sending bulk notifications to {} users", userIds.size());
        
        List<Notification> notifications = new ArrayList<>();
        
        for (Long userId : userIds) {
            try {
                User user = userRepository.findById(userId).orElse(null);
                if (user != null) {
                    Notification notification = Notification.builder()
                            .user(user)
                            .type(request.getType())
                            .title(request.getTitle())
                            .message(request.getMessage())
                            .referenceId(request.getReferenceId())
                            .referenceType(request.getReferenceType())
                            .priority(request.getPriority() != null ? request.getPriority().name() : "NORMAL")
                            .isRead(false)
                            .build();
                    notifications.add(notification);
                }
            } catch (Exception e) {
                log.warn("Failed to create notification for user {}: {}", userId, e.getMessage());
            }
        }
        
        List<Notification> saved = notificationRepository.saveAll(notifications);
        log.info("Created {} bulk notifications", saved.size());
        
        return saved;
    }

    @Override
    public List<Notification> sendToBranch(Long branchId, NotificationRequest request) {
        log.debug("Sending notification to all users in branch: {}", branchId);
        
        List<BranchStaff> branchStaff = branchStaffRepository.findByBranchId(branchId);
        List<Long> userIds = branchStaff.stream()
                .map(bs -> bs.getUser().getId())
                .distinct()
                .collect(Collectors.toList());
        
        return sendBulkNotifications(request, userIds);
    }

    @Override
    public List<Notification> sendToRole(Long branchId, String role, NotificationRequest request) {
        log.debug("Sending notification to role {} in branch: {}", role, branchId);
        
        List<BranchStaff> branchStaff = branchStaffRepository.findByBranchId(branchId);
        List<Long> userIds = branchStaff.stream()
                .filter(bs -> bs.getUser().getRole().name().equalsIgnoreCase(role))
                .map(bs -> bs.getUser().getId())
                .distinct()
                .collect(Collectors.toList());
        
        return sendBulkNotifications(request, userIds);
    }

    @Override
    @Transactional(readOnly = true)
    public List<Notification> getUserNotifications(Long userId) {
        log.debug("Fetching notifications for user: {}", userId);
        return notificationRepository.findByUserIdOrderByCreatedAtDesc(userId);
    }

    @Override
    @Transactional(readOnly = true)
    public List<Notification> getUnreadNotifications(Long userId) {
        log.debug("Fetching unread notifications for user: {}", userId);
        return notificationRepository.findByUserIdAndIsReadFalseOrderByCreatedAtDesc(userId);
    }

    @Override
    @Transactional(readOnly = true)
    public int getUnreadCount(Long userId) {
        log.debug("Counting unread notifications for user: {}", userId);
        return notificationRepository.countByUserIdAndIsReadFalse(userId);
    }

    @Override
    public void markAsRead(Long notificationId) {
        log.debug("Marking notification as read: {}", notificationId);
        
        Notification notification = notificationRepository.findById(notificationId)
                .orElseThrow(() -> new EntityNotFoundException("Notification not found: " + notificationId));
        
        notification.setIsRead(true);
        notification.setReadAt(LocalDateTime.now());
        notificationRepository.save(notification);
        
        log.info("Notification {} marked as read", notificationId);
    }

    @Override
    public void markAllAsRead(Long userId) {
        log.debug("Marking all notifications as read for user: {}", userId);
        notificationRepository.markAllAsReadByUserId(userId, LocalDateTime.now());
        log.info("All notifications marked as read for user: {}", userId);
    }

    @Override
    public void deleteNotification(Long notificationId) {
        log.debug("Deleting notification: {}", notificationId);
        
        if (!notificationRepository.existsById(notificationId)) {
            throw new EntityNotFoundException("Notification not found: " + notificationId);
        }
        
        notificationRepository.deleteById(notificationId);
        log.info("Notification {} deleted", notificationId);
    }

    @Override
    public void deleteAllNotifications(Long userId) {
        log.debug("Deleting all notifications for user: {}", userId);
        notificationRepository.deleteByUserId(userId);
        log.info("All notifications deleted for user: {}", userId);
    }

    @Override
    public void sendSystemAlert(String title, String message, NotificationType type, Long branchId) {
        log.info("Sending system alert: {} to branch: {}", title, branchId);
        
        NotificationRequest request = NotificationRequest.builder()
                .title(title)
                .message(message)
                .type(type)
                .build();
        
        if (branchId != null) {
            sendToBranch(branchId, request);
        } else {
            // Send to all active users
            List<User> activeUsers = userRepository.findByIsActiveTrue();
            List<Long> userIds = activeUsers.stream()
                    .map(User::getId)
                    .collect(Collectors.toList());
            sendBulkNotifications(request, userIds);
        }
    }

    @Override
    public void sendLowStockAlert(Long productId, Long branchId, int currentStock, int reorderLevel) {
        log.info("Sending low stock alert for product {} in branch {}", productId, branchId);
        
        String title = "Low Stock Alert";
        String message = String.format(
                "Product ID %d has low stock. Current: %d, Reorder Level: %d",
                productId, currentStock, reorderLevel
        );
        
        NotificationRequest request = NotificationRequest.builder()
                .title(title)
                .message(message)
                .type(NotificationType.LOW_STOCK)
                .referenceId(productId)
                .referenceType("PRODUCT")
                .build();
        
        sendToBranch(branchId, request);
    }

    @Override
    public void sendExpiryAlert(Long batchId, Long branchId, int daysToExpiry) {
        log.info("Sending expiry alert for batch {} in branch {}", batchId, branchId);
        
        String title = "Product Expiry Alert";
        String message = String.format(
                "Batch ID %d will expire in %d days",
                batchId, daysToExpiry
        );
        
        NotificationRequest request = NotificationRequest.builder()
                .title(title)
                .message(message)
                .type(NotificationType.EXPIRY_ALERT)
                .referenceId(batchId)
                .referenceType("BATCH")
                .build();
        
        sendToBranch(branchId, request);
    }

    @Override
    public void sendPaymentReminder(Long invoiceId, Long customerId) {
        log.info("Sending payment reminder for invoice {} to customer {}", invoiceId, customerId);
        
        String title = "Payment Reminder";
        String message = String.format("Invoice %d is due for payment", invoiceId);
        
        // Get customer's user if linked
        // For now, this creates a system notification
        NotificationRequest request = NotificationRequest.builder()
                .title(title)
                .message(message)
                .type(NotificationType.PAYMENT_DUE)
                .referenceId(invoiceId)
                .referenceType("INVOICE")
                .build();
        
        // Send to managers/admins
        List<User> managers = userRepository.findByIsActiveTrue().stream()
                .filter(u -> u.getRole().name().equals("MANAGER") || u.getRole().name().equals("ADMIN"))
                .collect(Collectors.toList());
        
        List<Long> userIds = managers.stream()
                .map(User::getId)
                .collect(Collectors.toList());
        
        sendBulkNotifications(request, userIds);
    }

    @Override
    @Async
    public void sendEmailNotification(String to, String subject, String body) {
        log.info("Sending email to: {}", to);
        
        if (mailSender == null) {
            log.warn("Email service is not configured. Cannot send email to: {}", to);
            return;
        }
        
        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setTo(to);
            message.setSubject(subject);
            message.setText(body);
            mailSender.send(message);
            log.info("Email sent successfully to: {}", to);
        } catch (Exception e) {
            log.error("Failed to send email to {}: {}", to, e.getMessage());
        }
    }

    @Override
    @Async
    public void sendSmsNotification(String phoneNumber, String message) {
        log.info("SMS notification requested for: {} (SMS service not configured)", phoneNumber);
        // SMS integration would go here
        // For now, log the request
        log.warn("SMS service is not configured. Message for {}: {}", phoneNumber, message);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\payroll\PayrollService.java"   & echo.. 
package com.pharmacy.medlan.service.payroll;

public interface PayrollService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\payroll\PayrollServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.payroll;

public class PayrollServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\CustomerPrescriptionService.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

public interface CustomerPrescriptionService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\CustomerPrescriptionServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

public class CustomerPrescriptionServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\CustomerService.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

import com.pharmacy.medlan.dto.request.pos.CreateCustomerRequest;
import com.pharmacy.medlan.dto.response.pos.CustomerResponse;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface CustomerService {

    CustomerResponse createCustomer(CreateCustomerRequest request);

    CustomerResponse updateCustomer(Long id, CreateCustomerRequest request);

    CustomerResponse getCustomerById(Long id);

    CustomerResponse getCustomerByCode(String customerCode);

    Page<CustomerResponse> getAllCustomers(Pageable pageable);

    List<CustomerResponse> searchCustomers(String search);

    List<CustomerResponse> getActiveCustomers();

    void deleteCustomer(Long id);

    void activateCustomer(Long id);

    void deactivateCustomer(Long id);

    String generateCustomerCode();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\CustomerServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

import com.pharmacy.medlan.dto.request.pos.CreateCustomerRequest;
import com.pharmacy.medlan.dto.response.pos.CustomerResponse;
import com.pharmacy.medlan.enums.CustomerStatus;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.CustomerMapper;
import com.pharmacy.medlan.model.pos.Customer;
import com.pharmacy.medlan.repository.pos.CustomerRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class CustomerServiceImpl implements CustomerService {

    private final CustomerRepository customerRepository;
    private final CustomerMapper customerMapper;

    @Override
    @Transactional
    public CustomerResponse createCustomer(CreateCustomerRequest request) {
        log.info("Creating customer: {}", request.getCustomerName());

        Customer customer = customerMapper.toEntity(request);
        customer.setCustomerCode(generateCustomerCode());

        Customer saved = customerRepository.save(customer);
        log.info("Customer created with code: {}", saved.getCustomerCode());

        return customerMapper.toResponse(saved);
    }

    @Override
    @Transactional
    public CustomerResponse updateCustomer(Long id, CreateCustomerRequest request) {
        log.info("Updating customer: {}", id);

        Customer customer = customerRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));

        customerMapper.updateEntityFromRequest(request, customer);
        Customer updated = customerRepository.save(customer);

        return customerMapper.toResponse(updated);
    }

    @Override
    public CustomerResponse getCustomerById(Long id) {
        Customer customer = customerRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
        return customerMapper.toResponse(customer);
    }

    @Override
    public CustomerResponse getCustomerByCode(String customerCode) {
        Customer customer = customerRepository.findByCustomerCode(customerCode)
                .orElseThrow(() -> new ResourceNotFoundException("Customer not found with code: " + customerCode));
        return customerMapper.toResponse(customer);
    }

    @Override
    public Page<CustomerResponse> getAllCustomers(Pageable pageable) {
        return customerRepository.findAll(pageable)
                .map(customerMapper::toResponse);
    }

    @Override
    public List<CustomerResponse> searchCustomers(String search) {
        return customerRepository.searchCustomers(search)
                .stream()
                .map(customerMapper::toResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<CustomerResponse> getActiveCustomers() {
        return customerRepository.findByStatus(CustomerStatus.ACTIVE)
                .stream()
                .map(customerMapper::toResponse)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void deleteCustomer(Long id) {
        log.info("Deleting customer: {}", id);

        Customer customer = customerRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));

        customer.setDeleted(true);
        customer.setStatus(CustomerStatus.INACTIVE);
        customerRepository.save(customer);
        log.info("Customer deleted: {}", id);
    }

    @Override
    @Transactional
    public void activateCustomer(Long id) {
        Customer customer = customerRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
        customer.setStatus(CustomerStatus.ACTIVE);
        customerRepository.save(customer);
    }

    @Override
    @Transactional
    public void deactivateCustomer(Long id) {
        Customer customer = customerRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + id));
        customer.setStatus(CustomerStatus.INACTIVE);
        customerRepository.save(customer);
    }

    @Override
    public String generateCustomerCode() {
        Long count = customerRepository.count();
        return String.format("CUST-%05d", count + 1);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\InvoiceService.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

import com.pharmacy.medlan.dto.response.pos.InvoiceResponse;
import com.pharmacy.medlan.enums.InvoiceStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

public interface InvoiceService {

    InvoiceResponse getInvoiceById(Long id);

    InvoiceResponse getInvoiceByNumber(String invoiceNumber);

    Page<InvoiceResponse> getAllInvoices(Pageable pageable);

    Page<InvoiceResponse> getInvoicesByBranch(Long branchId, Pageable pageable);

    Page<InvoiceResponse> getInvoicesByCustomer(Long customerId, Pageable pageable);

    List<InvoiceResponse> getInvoicesByDateRange(LocalDate startDate, LocalDate endDate);

    Page<InvoiceResponse> getInvoicesByStatus(InvoiceStatus status, Pageable pageable);

    Page<InvoiceResponse> getInvoicesByPaymentStatus(PaymentStatus paymentStatus, Pageable pageable);

    InvoiceResponse recordPayment(Long invoiceId, BigDecimal amount, String paymentReference);

    BigDecimal getTotalOutstandingByCustomer(Long customerId);

    List<InvoiceResponse> getOverdueInvoices();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\InvoiceServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

import com.pharmacy.medlan.dto.response.pos.InvoiceResponse;
import com.pharmacy.medlan.enums.InvoiceStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.exception.BusinessRuleViolationException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.InvoiceMapper;
import com.pharmacy.medlan.model.pos.Invoice;
import com.pharmacy.medlan.repository.pos.InvoiceRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional
public class InvoiceServiceImpl implements InvoiceService {

    private final InvoiceRepository invoiceRepository;
    private final InvoiceMapper invoiceMapper;

    @Override
    @Transactional(readOnly = true)
    public InvoiceResponse getInvoiceById(Long id) {
        Invoice invoice = invoiceRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Invoice not found with id: " + id));
        return invoiceMapper.toResponse(invoice);
    }

    @Override
    @Transactional(readOnly = true)
    public InvoiceResponse getInvoiceByNumber(String invoiceNumber) {
        Invoice invoice = invoiceRepository.findByInvoiceNumber(invoiceNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Invoice not found with number: " + invoiceNumber));
        return invoiceMapper.toResponse(invoice);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<InvoiceResponse> getAllInvoices(Pageable pageable) {
        return invoiceRepository.findAll(pageable).map(invoiceMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<InvoiceResponse> getInvoicesByBranch(Long branchId, Pageable pageable) {
        return invoiceRepository.findAll(pageable).map(invoiceMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<InvoiceResponse> getInvoicesByCustomer(Long customerId, Pageable pageable) {
        return invoiceRepository.findAll(pageable).map(invoiceMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public List<InvoiceResponse> getInvoicesByDateRange(LocalDate startDate, LocalDate endDate) {
        return invoiceMapper.toResponseList(invoiceRepository.findByInvoiceDateBetween(startDate, endDate));
    }

    @Override
    @Transactional(readOnly = true)
    public Page<InvoiceResponse> getInvoicesByStatus(InvoiceStatus status, Pageable pageable) {
        return invoiceRepository.findAll(pageable).map(invoiceMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<InvoiceResponse> getInvoicesByPaymentStatus(PaymentStatus paymentStatus, Pageable pageable) {
        return invoiceRepository.findAll(pageable).map(invoiceMapper::toResponse);
    }

    @Override
    public InvoiceResponse recordPayment(Long invoiceId, BigDecimal amount, String paymentReference) {
        Invoice invoice = invoiceRepository.findById(invoiceId)
                .orElseThrow(() -> new ResourceNotFoundException("Invoice not found with id: " + invoiceId));

        if (invoice.getStatus() == InvoiceStatus.CANCELLED || invoice.getStatus() == InvoiceStatus.VOID) {
            throw new BusinessRuleViolationException("Cannot record payment for " + invoice.getStatus() + " invoice");
        }

        BigDecimal newPaidAmount = invoice.getPaidAmount().add(amount);
        BigDecimal newBalance = invoice.getTotalAmount().subtract(newPaidAmount);

        if (newBalance.compareTo(BigDecimal.ZERO) < 0) {
            throw new BusinessRuleViolationException("Payment amount exceeds balance");
        }

        invoice.setPaidAmount(newPaidAmount);
        invoice.setBalanceAmount(newBalance);

        if (newBalance.compareTo(BigDecimal.ZERO) == 0) {
            invoice.setPaymentStatus(PaymentStatus.PAID);
        } else {
            invoice.setPaymentStatus(PaymentStatus.PARTIALLY_PAID);
        }

        log.info("Payment of {} recorded for invoice {}", amount, invoice.getInvoiceNumber());
        return invoiceMapper.toResponse(invoiceRepository.save(invoice));
    }

    @Override
    @Transactional(readOnly = true)
    public BigDecimal getTotalOutstandingByCustomer(Long customerId) {
        BigDecimal total = invoiceRepository.getTotalOutstandingByCustomer(customerId);
        return total != null ? total : BigDecimal.ZERO;
    }

    @Override
    @Transactional(readOnly = true)
    public List<InvoiceResponse> getOverdueInvoices() {
        List<Invoice> overdue = invoiceRepository.findByPaymentStatus(PaymentStatus.UNPAID);
        overdue.addAll(invoiceRepository.findByPaymentStatus(PaymentStatus.PARTIALLY_PAID));
        return invoiceMapper.toResponseList(
                overdue.stream()
                        .filter(i -> i.getDueDate() != null && i.getDueDate().isBefore(LocalDate.now()))
                        .toList()
        );
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\PatientNumberService.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

public class PatientNumberService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\PrescriptionService.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

public interface PrescriptionService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\PrescriptionServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

public class PrescriptionServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\SaleReturnService.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

import com.pharmacy.medlan.dto.request.pos.CreateSaleReturnRequest;
import com.pharmacy.medlan.dto.response.pos.SaleReturnResponse;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

public interface SaleReturnService {
    
    SaleReturnResponse createSaleReturn(CreateSaleReturnRequest request);
    
    SaleReturnResponse getById(Long id);
    
    SaleReturnResponse getByReturnNumber(String returnNumber);
    
    Page<SaleReturnResponse> getAllSaleReturns(Pageable pageable);
    
    List<SaleReturnResponse> getByCustomer(Long customerId);
    
    List<SaleReturnResponse> getByBranch(Long branchId);
    
    List<SaleReturnResponse> getByDateRange(LocalDate startDate, LocalDate endDate);
    
    void deleteSaleReturn(Long id);
    
    String generateReturnNumber();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\SaleReturnServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

import com.pharmacy.medlan.dto.request.pos.CreateSaleReturnRequest;
import com.pharmacy.medlan.dto.response.pos.SaleReturnResponse;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.SaleReturnMapper;
import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.pos.*;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.product.BranchInventoryRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.organization.BranchRepository;
import com.pharmacy.medlan.repository.pos.CustomerRepository;
import com.pharmacy.medlan.repository.pos.SaleItemRepository;
import com.pharmacy.medlan.repository.pos.SaleRepository;
import com.pharmacy.medlan.repository.pos.SaleReturnRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import com.pharmacy.medlan.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.Year;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional
public class SaleReturnServiceImpl implements SaleReturnService {

    private final SaleReturnRepository saleReturnRepository;
    private final SaleRepository saleRepository;
    private final SaleItemRepository saleItemRepository;
    private final BranchRepository branchRepository;
    private final CustomerRepository customerRepository;
    private final ProductRepository productRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final BranchInventoryRepository branchInventoryRepository;
    private final UserRepository userRepository;
    private final SaleReturnMapper saleReturnMapper;

    @Override
    public SaleReturnResponse createSaleReturn(CreateSaleReturnRequest request) {
        Branch branch = branchRepository.findById(request.getBranchId())
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found"));
        
        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        SaleReturn saleReturn = SaleReturn.builder()
                .returnNumber(generateReturnNumber())
                .branch(branch)
                .returnDate(LocalDate.now())
                .returnReason(request.getReturnReason())
                .processedBy(currentUser)
                .build();

        if (request.getOriginalSaleId() != null) {
            Sale originalSale = saleRepository.findById(request.getOriginalSaleId())
                    .orElseThrow(() -> new ResourceNotFoundException("Original sale not found"));
            saleReturn.setOriginalSale(originalSale);
            saleReturn.setCustomer(originalSale.getCustomer());
        } else if (request.getCustomerId() != null) {
            Customer customer = customerRepository.findById(request.getCustomerId())
                    .orElseThrow(() -> new ResourceNotFoundException("Customer not found"));
            saleReturn.setCustomer(customer);
        }

        BigDecimal totalReturnAmount = BigDecimal.ZERO;

        for (CreateSaleReturnRequest.SaleReturnItemRequest itemRequest : request.getItems()) {
            Product product = productRepository.findById(itemRequest.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found: " + itemRequest.getProductId()));

            BigDecimal lineTotal = itemRequest.getUnitPrice()
                    .multiply(BigDecimal.valueOf(itemRequest.getQuantityReturned()));

            SaleReturnItem item = SaleReturnItem.builder()
                    .saleReturn(saleReturn)
                    .product(product)
                    .quantityReturned(itemRequest.getQuantityReturned())
                    .unitPrice(itemRequest.getUnitPrice())
                    .totalAmount(lineTotal)
                    .returnReason(itemRequest.getReturnReason())
                    .build();

            if (itemRequest.getOriginalSaleItemId() != null) {
                SaleItem originalSaleItem = saleItemRepository.findById(itemRequest.getOriginalSaleItemId())
                        .orElseThrow(() -> new ResourceNotFoundException("Original sale item not found"));
                item.setOriginalSaleItem(originalSaleItem);
            }

            if (itemRequest.getInventoryBatchId() != null) {
                InventoryBatch batch = inventoryBatchRepository.findById(itemRequest.getInventoryBatchId())
                        .orElseThrow(() -> new ResourceNotFoundException("Inventory batch not found"));
                item.setInventoryBatch(batch);
            }

            // Restore inventory
            BranchInventory branchInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(product.getId(), branch.getId())
                    .orElse(null);

            if (branchInventory == null) {
                branchInventory = BranchInventory.builder()
                        .product(product)
                        .branch(branch)
                        .quantityOnHand(0)
                        .quantityAllocated(0)
                        .quantityAvailable(0)
                        .build();
            }

            branchInventory.setQuantityOnHand(branchInventory.getQuantityOnHand() + itemRequest.getQuantityReturned());
            branchInventory.setQuantityAvailable(branchInventory.getQuantityAvailable() + itemRequest.getQuantityReturned());
            branchInventoryRepository.save(branchInventory);

            saleReturn.getReturnItems().add(item);
            totalReturnAmount = totalReturnAmount.add(lineTotal);
        }

        saleReturn.setTotalReturnAmount(totalReturnAmount);
        saleReturn.setRefundAmount(totalReturnAmount); // Default to full refund
        
        saleReturn = saleReturnRepository.save(saleReturn);
        log.info("Sale return created: {}", saleReturn.getReturnNumber());

        return saleReturnMapper.toResponse(saleReturn);
    }

    @Override
    @Transactional(readOnly = true)
    public SaleReturnResponse getById(Long id) {
        SaleReturn saleReturn = saleReturnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Sale return not found"));
        return saleReturnMapper.toResponse(saleReturn);
    }

    @Override
    @Transactional(readOnly = true)
    public SaleReturnResponse getByReturnNumber(String returnNumber) {
        SaleReturn saleReturn = saleReturnRepository.findByReturnNumber(returnNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Sale return not found"));
        return saleReturnMapper.toResponse(saleReturn);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<SaleReturnResponse> getAllSaleReturns(Pageable pageable) {
        return saleReturnRepository.findAll(pageable).map(saleReturnMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public List<SaleReturnResponse> getByBranch(Long branchId) {
        return saleReturnMapper.toResponseList(saleReturnRepository.findByBranchId(branchId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<SaleReturnResponse> getByCustomer(Long customerId) {
        return saleReturnMapper.toResponseList(saleReturnRepository.findByCustomerId(customerId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<SaleReturnResponse> getByDateRange(LocalDate startDate, LocalDate endDate) {
        return saleReturnMapper.toResponseList(saleReturnRepository.findByReturnDateBetween(startDate, endDate));
    }

    @Override
    public void deleteSaleReturn(Long id) {
        SaleReturn saleReturn = saleReturnRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Sale return not found"));

        // Reverse inventory restoration
        for (SaleReturnItem item : saleReturn.getReturnItems()) {
            BranchInventory branchInventory = branchInventoryRepository
                    .findByProductIdAndBranchId(item.getProduct().getId(), saleReturn.getBranch().getId())
                    .orElse(null);

            if (branchInventory != null) {
                branchInventory.setQuantityOnHand(
                        Math.max(0, branchInventory.getQuantityOnHand() - item.getQuantityReturned()));
                branchInventory.setQuantityAvailable(
                        Math.max(0, branchInventory.getQuantityAvailable() - item.getQuantityReturned()));
                branchInventoryRepository.save(branchInventory);
            }
        }

        saleReturnRepository.delete(saleReturn);
        log.info("Sale return deleted: {}", saleReturn.getReturnNumber());
    }

    @Override
    public String generateReturnNumber() {
        long count = saleReturnRepository.count() + 1;
        return String.format("SR-%d-%05d", Year.now().getValue(), count);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\SaleService.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

import com.pharmacy.medlan.dto.request.pos.CreateSaleRequest;
import com.pharmacy.medlan.dto.response.pos.SaleResponse;
import com.pharmacy.medlan.enums.SaleStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

public interface SaleService {

    SaleResponse createSale(CreateSaleRequest request);

    SaleResponse getSaleById(Long id);

    SaleResponse getSaleBySaleNumber(String saleNumber);

    Page<SaleResponse> getAllSales(Pageable pageable);

    Page<SaleResponse> getSalesByBranch(Long branchId, Pageable pageable);

    Page<SaleResponse> getSalesByCustomer(Long customerId, Pageable pageable);

    List<SaleResponse> getSalesByDateRange(LocalDateTime startDate, LocalDateTime endDate);

    List<SaleResponse> getSalesByBranchAndDateRange(Long branchId, LocalDateTime startDate, LocalDateTime endDate);

    Page<SaleResponse> getSalesByStatus(SaleStatus status, Pageable pageable);

    SaleResponse cancelSale(Long id, String reason);

    SaleResponse voidSale(Long id, String reason);

    BigDecimal getTotalSalesByBranchAndDate(Long branchId, LocalDateTime startDate, LocalDateTime endDate);

    Long getSalesCountByBranchAndDate(Long branchId, LocalDateTime startDate, LocalDateTime endDate);

    String generateSaleNumber();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\pos\SaleServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.pos;

import com.pharmacy.medlan.dto.request.pos.CreateSaleRequest;
import com.pharmacy.medlan.dto.response.pos.SaleResponse;
import com.pharmacy.medlan.enums.InvoiceStatus;
import com.pharmacy.medlan.enums.PaymentStatus;
import com.pharmacy.medlan.enums.SaleStatus;
import com.pharmacy.medlan.exception.BusinessRuleViolationException;
import com.pharmacy.medlan.exception.InsufficientStockException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.SaleMapper;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.pos.*;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.organization.BranchRepository;
import com.pharmacy.medlan.repository.pos.*;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import com.pharmacy.medlan.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional
public class SaleServiceImpl implements SaleService {

    private final SaleRepository saleRepository;
    private final SaleItemRepository saleItemRepository;
    private final InvoiceRepository invoiceRepository;
    private final CustomerRepository customerRepository;
    private final ProductRepository productRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final BranchRepository branchRepository;
    private final UserRepository userRepository;
    private final SaleMapper saleMapper;

    @Override
    public SaleResponse createSale(CreateSaleRequest request) {
        log.info("Creating new sale for branch: {}", request.getBranchId());

        // Get current user
        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        // Get branch
        Branch branch = branchRepository.findById(request.getBranchId())
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found with id: " + request.getBranchId()));

        // Get customer if specified
        Customer customer = null;
        if (request.getCustomerId() != null) {
            customer = customerRepository.findById(request.getCustomerId())
                    .orElseThrow(() -> new ResourceNotFoundException("Customer not found with id: " + request.getCustomerId()));
        }

        // Create Invoice first
        Invoice invoice = createInvoice(branch, customer, request);

        // Create Sale
        Sale sale = Sale.builder()
                .saleNumber(generateSaleNumber())
                .invoice(invoice)
                .branch(branch)
                .customer(customer)
                .saleDate(LocalDateTime.now())
                .paymentMethod(request.getPaymentMethod())
                .status(SaleStatus.COMPLETED)
                .soldBy(currentUser)
                .patientName(request.getPatientName())
                .doctorName(request.getDoctorName())
                .remarks(request.getRemarks())
                .saleItems(new ArrayList<>())
                .build();

        // Process sale items
        BigDecimal subtotal = BigDecimal.ZERO;
        BigDecimal totalTax = BigDecimal.ZERO;

        for (CreateSaleRequest.SaleItemRequest itemRequest : request.getItems()) {
            Product product = productRepository.findById(itemRequest.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + itemRequest.getProductId()));

            // Get or determine batch
            InventoryBatch batch = determineBatch(product, branch, itemRequest);

            // Validate stock
            if (batch.getQuantityAvailable() < itemRequest.getQuantity()) {
                throw new InsufficientStockException("Insufficient stock for product: " + product.getProductName() +
                        ". Available: " + batch.getQuantityAvailable() + ", Requested: " + itemRequest.getQuantity());
            }

            // Calculate item amounts
            BigDecimal unitPrice = product.getSellingPrice();
            BigDecimal itemDiscount = itemRequest.getDiscountAmount() != null ? 
                    itemRequest.getDiscountAmount() : BigDecimal.ZERO;
            BigDecimal itemSubtotal = unitPrice.multiply(BigDecimal.valueOf(itemRequest.getQuantity()));
            BigDecimal itemTax = calculateTax(product, itemSubtotal.subtract(itemDiscount));
            BigDecimal itemTotal = itemSubtotal.subtract(itemDiscount).add(itemTax);

            SaleItem saleItem = SaleItem.builder()
                    .sale(sale)
                    .product(product)
                    .inventoryBatch(batch)
                    .productName(product.getProductName())
                    .batchNumber(batch.getBatchNumber())
                    .quantity(itemRequest.getQuantity())
                    .unitPrice(unitPrice)
                    .discountAmount(itemDiscount)
                    .taxAmount(itemTax)
                    .totalAmount(itemTotal)
                    .costPrice(batch.getPurchasePrice())
                    .profit(itemTotal.subtract(batch.getPurchasePrice().multiply(BigDecimal.valueOf(itemRequest.getQuantity()))))
                    .build();

            sale.getSaleItems().add(saleItem);

            // Reduce inventory
            batch.setQuantityAvailable(batch.getQuantityAvailable() - itemRequest.getQuantity());
            batch.setQuantitySold(batch.getQuantitySold() + itemRequest.getQuantity());
            inventoryBatchRepository.save(batch);

            subtotal = subtotal.add(itemSubtotal);
            totalTax = totalTax.add(itemTax);
        }

        // Apply sale-level discount
        BigDecimal saleDiscount = request.getDiscountAmount() != null ? 
                request.getDiscountAmount() : BigDecimal.ZERO;
        BigDecimal saleDiscountPercent = request.getDiscountPercent() != null ? 
                request.getDiscountPercent() : BigDecimal.ZERO;

        if (saleDiscountPercent.compareTo(BigDecimal.ZERO) > 0) {
            saleDiscount = subtotal.multiply(saleDiscountPercent)
                    .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);
        }

        BigDecimal totalAmount = subtotal.subtract(saleDiscount).add(totalTax);
        BigDecimal changeAmount = request.getPaidAmount().subtract(totalAmount);

        if (changeAmount.compareTo(BigDecimal.ZERO) < 0) {
            throw new BusinessRuleViolationException("Paid amount is less than total amount");
        }

        // Update sale amounts
        sale.setSubtotal(subtotal);
        sale.setDiscountAmount(saleDiscount);
        sale.setDiscountPercent(saleDiscountPercent);
        sale.setTaxAmount(totalTax);
        sale.setTotalAmount(totalAmount);
        sale.setPaidAmount(request.getPaidAmount());
        sale.setChangeAmount(changeAmount);

        // Update invoice
        invoice.setSubtotal(subtotal);
        invoice.setDiscount(saleDiscount);
        invoice.setTotalAmount(totalAmount);
        invoice.setPaidAmount(request.getPaidAmount());
        invoice.setBalanceAmount(BigDecimal.ZERO);
        invoice.setStatus(InvoiceStatus.PAID);
        invoice.setPaymentStatus(PaymentStatus.PAID);
        invoiceRepository.save(invoice);

        Sale savedSale = saleRepository.save(sale);
        log.info("Sale created successfully with number: {}", savedSale.getSaleNumber());

        return saleMapper.toResponse(savedSale);
    }

    private Invoice createInvoice(Branch branch, Customer customer, CreateSaleRequest request) {
        return invoiceRepository.save(Invoice.builder()
                .invoiceNumber(generateInvoiceNumber())
                .branch(branch)
                .customer(customer)
                .invoiceDate(LocalDate.now())
                .status(InvoiceStatus.DRAFT)
                .paymentStatus(PaymentStatus.UNPAID)
                .paymentType(request.getPaymentMethod())
                .subtotal(BigDecimal.ZERO)
                .discount(BigDecimal.ZERO)
                .totalAmount(BigDecimal.ZERO)
                .paidAmount(BigDecimal.ZERO)
                .balanceAmount(BigDecimal.ZERO)
                .build());
    }

    private InventoryBatch determineBatch(Product product, Branch branch, 
            CreateSaleRequest.SaleItemRequest itemRequest) {
        if (itemRequest.getInventoryBatchId() != null) {
            return inventoryBatchRepository.findById(itemRequest.getInventoryBatchId())
                    .orElseThrow(() -> new ResourceNotFoundException("InventoryBatch not found with id: " + 
                            itemRequest.getInventoryBatchId()));
        }

        // Get batch with earliest expiry (FEFO - First Expiry First Out)
        List<InventoryBatch> batches = inventoryBatchRepository
                .findAvailableBatchesByProductOrderByExpiryDateAsc(product.getId(), branch.getId());

        if (batches.isEmpty()) {
            throw new InsufficientStockException("No available stock for product: " + product.getProductName());
        }

        return batches.get(0);
    }

    private BigDecimal calculateTax(Product product, BigDecimal amount) {
        if (product.getTaxCategory() != null && product.getTaxCategory().getTaxRate() != null) {
            return amount.multiply(product.getTaxCategory().getTaxRate())
                    .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);
        }
        return BigDecimal.ZERO;
    }

    @Override
    @Transactional(readOnly = true)
    public SaleResponse getSaleById(Long id) {
        Sale sale = saleRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Sale not found with id: " + id));
        return saleMapper.toResponse(sale);
    }

    @Override
    @Transactional(readOnly = true)
    public SaleResponse getSaleBySaleNumber(String saleNumber) {
        Sale sale = saleRepository.findBySaleNumber(saleNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Sale not found with number: " + saleNumber));
        return saleMapper.toResponse(sale);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<SaleResponse> getAllSales(Pageable pageable) {
        return saleRepository.findAll(pageable).map(saleMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<SaleResponse> getSalesByBranch(Long branchId, Pageable pageable) {
        return saleRepository.findAll(pageable).map(saleMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<SaleResponse> getSalesByCustomer(Long customerId, Pageable pageable) {
        return saleRepository.findAll(pageable).map(saleMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public List<SaleResponse> getSalesByDateRange(LocalDateTime startDate, LocalDateTime endDate) {
        return saleMapper.toResponseList(saleRepository.findBySaleDateBetween(startDate, endDate));
    }

    @Override
    @Transactional(readOnly = true)
    public List<SaleResponse> getSalesByBranchAndDateRange(Long branchId, LocalDateTime startDate, 
            LocalDateTime endDate) {
        return saleMapper.toResponseList(
                saleRepository.findByBranchAndDateRange(branchId, startDate, endDate));
    }

    @Override
    @Transactional(readOnly = true)
    public Page<SaleResponse> getSalesByStatus(SaleStatus status, Pageable pageable) {
        return saleRepository.findAll(pageable).map(saleMapper::toResponse);
    }

    @Override
    public SaleResponse cancelSale(Long id, String reason) {
        Sale sale = saleRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Sale not found with id: " + id));

        if (sale.getStatus() == SaleStatus.CANCELLED) {
            throw new BusinessRuleViolationException("Sale is already cancelled");
        }

        // Restore inventory
        for (SaleItem item : sale.getSaleItems()) {
            if (item.getInventoryBatch() != null) {
                InventoryBatch batch = item.getInventoryBatch();
                batch.setQuantityAvailable(batch.getQuantityAvailable() + item.getQuantity());
                batch.setQuantitySold(batch.getQuantitySold() - item.getQuantity());
                inventoryBatchRepository.save(batch);
            }
        }

        sale.setStatus(SaleStatus.CANCELLED);
        sale.setRemarks((sale.getRemarks() != null ? sale.getRemarks() + "\n" : "") + 
                "Cancelled: " + reason);

        // Update invoice status
        if (sale.getInvoice() != null) {
            sale.getInvoice().setStatus(InvoiceStatus.CANCELLED);
            invoiceRepository.save(sale.getInvoice());
        }

        return saleMapper.toResponse(saleRepository.save(sale));
    }

    @Override
    public SaleResponse voidSale(Long id, String reason) {
        Sale sale = saleRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Sale not found with id: " + id));

        if (sale.getStatus() == SaleStatus.CANCELLED) {
            throw new BusinessRuleViolationException("Sale is already voided/cancelled");
        }

        // Restore inventory
        for (SaleItem item : sale.getSaleItems()) {
            if (item.getInventoryBatch() != null) {
                InventoryBatch batch = item.getInventoryBatch();
                batch.setQuantityAvailable(batch.getQuantityAvailable() + item.getQuantity());
                batch.setQuantitySold(batch.getQuantitySold() - item.getQuantity());
                inventoryBatchRepository.save(batch);
            }
        }

        sale.setStatus(SaleStatus.CANCELLED);
        sale.setRemarks((sale.getRemarks() != null ? sale.getRemarks() + "\n" : "") + 
                "Voided: " + reason);

        if (sale.getInvoice() != null) {
            sale.getInvoice().setStatus(InvoiceStatus.VOID);
            invoiceRepository.save(sale.getInvoice());
        }

        return saleMapper.toResponse(saleRepository.save(sale));
    }

    @Override
    @Transactional(readOnly = true)
    public BigDecimal getTotalSalesByBranchAndDate(Long branchId, LocalDateTime startDate, 
            LocalDateTime endDate) {
        BigDecimal total = saleRepository.getTotalSalesByBranchAndDate(branchId, startDate, endDate);
        return total != null ? total : BigDecimal.ZERO;
    }

    @Override
    @Transactional(readOnly = true)
    public Long getSalesCountByBranchAndDate(Long branchId, LocalDateTime startDate, 
            LocalDateTime endDate) {
        return (long) saleRepository.findByBranchAndDateRange(branchId, startDate, endDate).size();
    }

    @Override
    public String generateSaleNumber() {
        String prefix = "SALE-" + LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy")) + "-";
        Long count = saleRepository.count() + 1;
        return prefix + String.format("%05d", count);
    }

    private String generateInvoiceNumber() {
        String prefix = "INV-" + LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy")) + "-";
        Long count = invoiceRepository.count() + 1;
        return prefix + String.format("%05d", count);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\CategoryService.java"   & echo.. 
package com.pharmacy.medlan.service.product;

import com.pharmacy.medlan.dto.response.product.CategoryResponse;
import java.util.List;

public interface CategoryService {
    CategoryResponse createCategory(String categoryName, String categoryCode, String description);
    CategoryResponse updateCategory(Long id, String categoryName, String description);
    CategoryResponse getCategoryById(Long id);
    List<CategoryResponse> getAllCategories();
    List<CategoryResponse> getActiveCategories();
    void deleteCategory(Long id);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\CategoryServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.product;

import com.pharmacy.medlan.dto.response.product.CategoryResponse;
import com.pharmacy.medlan.exception.DuplicationResourceException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.ProductMapper;
import com.pharmacy.medlan.model.product.Category;
import com.pharmacy.medlan.repository.product.CategoryRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class CategoryServiceImpl implements CategoryService {

    private final CategoryRepository categoryRepository;
    private final ProductMapper productMapper;

    @Override
    @Transactional
    public CategoryResponse createCategory(String categoryName, String categoryCode, String description) {
        if (categoryRepository.existsByCategoryName(categoryName)) {
            throw new DuplicationResourceException("Category name already exists");
        }

        Category category = Category.builder()
                .categoryName(categoryName)
                .categoryCode(categoryCode)
                .description(description)
                .isActive(true)
                .build();

        Category saved = categoryRepository.save(category);
        return productMapper.toCategoryResponse(saved);
    }

    @Override
    @Transactional
    public CategoryResponse updateCategory(Long id, String categoryName, String description) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));

        category.setCategoryName(categoryName);
        category.setDescription(description);

        Category updated = categoryRepository.save(category);
        return productMapper.toCategoryResponse(updated);
    }

    @Override
    public CategoryResponse getCategoryById(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
        return productMapper.toCategoryResponse(category);
    }

    @Override
    public List<CategoryResponse> getAllCategories() {
        return categoryRepository.findAll()
                .stream()
                .map(productMapper::toCategoryResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<CategoryResponse> getActiveCategories() {
        return categoryRepository.findByIsActiveTrue()
                .stream()
                .map(productMapper::toCategoryResponse)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void deleteCategory(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
        category.setDeleted(true);
        category.setIsActive(false);
        categoryRepository.save(category);
    }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\ProducPricingService.java"   & echo.. 
package com.pharmacy.medlan.service.product;

public interface ProducPricingService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\ProductPricingServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.product;

public class ProductPricingServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\ProductService.java"   & echo.. 
package com.pharmacy.medlan.service.product;

import com.pharmacy.medlan.dto.request.product.CreateProductRequest;
import com.pharmacy.medlan.dto.request.product.UpdateProductRequest;
import com.pharmacy.medlan.dto.response.product.ProductResponse;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import java.util.List;

public interface ProductService {
    ProductResponse createProduct(CreateProductRequest request);
    ProductResponse updateProduct(Long id, UpdateProductRequest request);
    ProductResponse getProductById(Long id);
    ProductResponse getProductByCode(String productCode);
    Page<ProductResponse> getAllProducts(Pageable pageable);
    List<ProductResponse> searchProducts(String search);
    List<ProductResponse> getLowStockProducts(Long branchId);
    void deleteProduct(Long id);
    void discontinueProduct(Long id);
    String generateProductCode();
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\ProductServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.product;

import com.pharmacy.medlan.dto.request.product.CreateProductRequest;
import com.pharmacy.medlan.dto.request.product.UpdateProductRequest;
import com.pharmacy.medlan.dto.response.product.ProductResponse;
import com.pharmacy.medlan.exception.DuplicationResourceException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.ProductMapper;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.repository.product.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class ProductServiceImpl implements ProductService {

    private final ProductRepository productRepository;
    private final CategoryRepository categoryRepository;
    private final SubCategoryRepository subCategoryRepository;
    private final UnitRepository unitRepository;
    private final ProductMapper productMapper;

    @Override
    @Transactional
    public ProductResponse createProduct(CreateProductRequest request) {
        log.info("Creating product: {}", request.getProductName());

        if (request.getBarcode() != null && productRepository.existsByBarcode(request.getBarcode())) {
            throw new DuplicationResourceException("Barcode already exists");
        }

        Product product = productMapper.toEntity(request);
        product.setProductCode(generateProductCode());

        if (request.getCategoryId() != null) {
            product.setCategory(categoryRepository.findById(request.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category not found")));
        }

        if (request.getSubCategoryId() != null) {
            product.setSubCategory(subCategoryRepository.findById(request.getSubCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("SubCategory not found")));
        }

        if (request.getUnitId() != null) {
            product.setUnit(unitRepository.findById(request.getUnitId())
                    .orElseThrow(() -> new ResourceNotFoundException("Unit not found")));
        }

        Product saved = productRepository.save(product);
        log.info("Product created with code: {}", saved.getProductCode());

        return productMapper.toResponse(saved);
    }

    @Override
    @Transactional
    public ProductResponse updateProduct(Long id, UpdateProductRequest request) {
        log.info("Updating product: {}", id);

        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));

        productMapper.updateEntityFromRequest(request, product);

        if (request.getCategoryId() != null) {
            product.setCategory(categoryRepository.findById(request.getCategoryId())
                    .orElseThrow(() -> new ResourceNotFoundException("Category not found")));
        }

        Product updated = productRepository.save(product);
        return productMapper.toResponse(updated);
    }

    @Override
    public ProductResponse getProductById(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
        return productMapper.toResponse(product);
    }

    @Override
    public ProductResponse getProductByCode(String productCode) {
        Product product = productRepository.findByProductCode(productCode)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with code: " + productCode));
        return productMapper.toResponse(product);
    }

    @Override
    public Page<ProductResponse> getAllProducts(Pageable pageable) {
        return productRepository.findAll(pageable)
                .map(productMapper::toResponse);
    }

    @Override
    public List<ProductResponse> searchProducts(String search) {
        return productRepository.searchProducts(search)
                .stream()
                .map(productMapper::toResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<ProductResponse> getLowStockProducts(Long branchId) {
        return productRepository.findLowStockProducts(branchId)
                .stream()
                .map(productMapper::toResponse)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void deleteProduct(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
        product.setDeleted(true);
        productRepository.save(product);
        log.info("Product deleted: {}", id);
    }

    @Override
    @Transactional
    public void discontinueProduct(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
        product.setIsDiscontinued(true);
        product.setIsActive(false);
        productRepository.save(product);
        log.info("Product discontinued: {}", id);
    }

    @Override
    public String generateProductCode() {
        Long count = productRepository.count();
        return String.format("MED-%05d", count + 1);
    }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\SubCategoryService.java"   & echo.. 
package com.pharmacy.medlan.service.product;

import com.pharmacy.medlan.dto.response.product.SubCategoryResponse;
import java.util.List;

public interface SubCategoryService {
    SubCategoryResponse createSubCategory(Long categoryId, String subCategoryName, String subCategoryCode);
    SubCategoryResponse updateSubCategory(Long id, String subCategoryName);
    SubCategoryResponse getSubCategoryById(Long id);
    List<SubCategoryResponse> getAllSubCategories();
    List<SubCategoryResponse> getSubCategoriesByCategory(Long categoryId);
    void deleteSubCategory(Long id);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\SubCategoryServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.product;

import com.pharmacy.medlan.dto.response.product.SubCategoryResponse;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.ProductMapper;
import com.pharmacy.medlan.model.product.Category;
import com.pharmacy.medlan.model.product.SubCategory;
import com.pharmacy.medlan.repository.product.CategoryRepository;
import com.pharmacy.medlan.repository.product.SubCategoryRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class SubCategoryServiceImpl implements SubCategoryService {

    private final SubCategoryRepository subCategoryRepository;
    private final CategoryRepository categoryRepository;
    private final ProductMapper productMapper;

    @Override
    @Transactional
    public SubCategoryResponse createSubCategory(Long categoryId, String subCategoryName, String subCategoryCode) {
        Category category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));

        SubCategory subCategory = SubCategory.builder()
                .category(category)
                .subCategoryName(subCategoryName)
                .subCategoryCode(subCategoryCode)
                .isActive(true)
                .build();

        SubCategory saved = subCategoryRepository.save(subCategory);
        return productMapper.toSubCategoryResponse(saved);
    }

    @Override
    @Transactional
    public SubCategoryResponse updateSubCategory(Long id, String subCategoryName) {
        SubCategory subCategory = subCategoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SubCategory not found"));

        subCategory.setSubCategoryName(subCategoryName);
        SubCategory updated = subCategoryRepository.save(subCategory);
        return productMapper.toSubCategoryResponse(updated);
    }

    @Override
    public SubCategoryResponse getSubCategoryById(Long id) {
        SubCategory subCategory = subCategoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SubCategory not found"));
        return productMapper.toSubCategoryResponse(subCategory);
    }

    @Override
    public List<SubCategoryResponse> getAllSubCategories() {
        return subCategoryRepository.findAll()
                .stream()
                .map(productMapper::toSubCategoryResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<SubCategoryResponse> getSubCategoriesByCategory(Long categoryId) {
        return subCategoryRepository.findByCategoryId(categoryId)
                .stream()
                .map(productMapper::toSubCategoryResponse)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void deleteSubCategory(Long id) {
        SubCategory subCategory = subCategoryRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("SubCategory not found"));
        subCategory.setDeleted(true);
        subCategoryRepository.save(subCategory);
    }
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\UnitService.java"   & echo.. 
package com.pharmacy.medlan.service.product;

import com.pharmacy.medlan.model.product.Unit;
import java.util.List;

public interface UnitService {
    Unit createUnit(String unitName, String unitCode);
    Unit updateUnit(Long id, String unitName);
    Unit getUnitById(Long id);
    List<Unit> getAllUnits();
    List<Unit> getActiveUnits();
    void deleteUnit(Long id);
}.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\product\UnitServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.product;

import com.pharmacy.medlan.exception.DuplicationResourceException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.model.product.Unit;
import com.pharmacy.medlan.repository.product.UnitRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class UnitServiceImpl implements UnitService {

    private final UnitRepository unitRepository;

    @Override
    @Transactional
    public Unit createUnit(String unitName, String unitCode) {
        if (unitRepository.existsByUnitName(unitName)) {
            throw new DuplicationResourceException("Unit name already exists");
        }

        Unit unit = Unit.builder()
                .unitName(unitName)
                .unitCode(unitCode)
                .isActive(true)
                .build();

        return unitRepository.save(unit);
    }

    @Override
    @Transactional
    public Unit updateUnit(Long id, String unitName) {
        Unit unit = unitRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Unit not found"));
        unit.setUnitName(unitName);
        return unitRepository.save(unit);
    }

    @Override
    public Unit getUnitById(Long id) {
        return unitRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Unit not found"));
    }

    @Override
    public List<Unit> getAllUnits() {
        return unitRepository.findAll();
    }

    @Override
    public List<Unit> getActiveUnits() {
        return unitRepository.findByIsActiveTrue();
    }

    @Override
    @Transactional
    public void deleteUnit(Long id) {
        Unit unit = unitRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Unit not found"));
        unit.setDeleted(true);
        unit.setIsActive(false);
        unitRepository.save(unit);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\AlertService.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import java.util.List;
import java.util.Map;

public interface AlertService {
    
    // Stock alerts
    List<Map<String, Object>> getLowStockAlerts(Long branchId);
    List<Map<String, Object>> getOutOfStockAlerts(Long branchId);
    List<Map<String, Object>> getExpiryAlerts(Long branchId, int daysThreshold);
    
    // Financial alerts
    List<Map<String, Object>> getOverdueInvoiceAlerts(Long branchId);
    List<Map<String, Object>> getOverduePaymentAlerts(Long branchId);
    
    // System alerts
    List<Map<String, Object>> getPendingApprovalAlerts(Long branchId);
    List<Map<String, Object>> getRecentActivityAlerts(Long branchId, int limit);
    
    // Consolidated alerts
    Map<String, Object> getAllAlerts(Long branchId);
    int getAlertCount(Long branchId);
    
    // Mark as read/acknowledged
    void acknowledgeAlert(Long alertId);
    void acknowledgeAllAlerts(Long branchId, String alertType);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\AlertServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.model.pos.Invoice;
import com.pharmacy.medlan.repository.product.BranchInventoryRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import com.pharmacy.medlan.repository.pos.InvoiceRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.*;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class AlertServiceImpl implements AlertService {

    private final BranchInventoryRepository branchInventoryRepository;
    private final InventoryBatchRepository inventoryBatchRepository;
    private final InvoiceRepository invoiceRepository;

    @Override
    public List<Map<String, Object>> getLowStockAlerts(Long branchId) {
        List<BranchInventory> lowStock = branchInventoryRepository.findLowStockByBranch(branchId);
        return lowStock.stream()
                .map(bi -> {
                    Map<String, Object> alert = new HashMap<>();
                    alert.put("type", "LOW_STOCK");
                    alert.put("severity", "WARNING");
                    alert.put("productId", bi.getProduct().getId());
                    alert.put("productName", bi.getProduct().getProductName());
                    alert.put("currentStock", bi.getQuantityAvailable());
                    alert.put("minStockLevel", bi.getMinimumStock());
                    alert.put("message", String.format("Low stock for %s: %d units remaining (min: %d)",
                            bi.getProduct().getProductName(), bi.getQuantityAvailable(), bi.getMinimumStock()));
                    return alert;
                })
                .toList();
    }

    @Override
    public List<Map<String, Object>> getOutOfStockAlerts(Long branchId) {
        List<BranchInventory> outOfStock = branchInventoryRepository.findOutOfStockByBranch(branchId);
        return outOfStock.stream()
                .map(bi -> {
                    Map<String, Object> alert = new HashMap<>();
                    alert.put("type", "OUT_OF_STOCK");
                    alert.put("severity", "CRITICAL");
                    alert.put("productId", bi.getProduct().getId());
                    alert.put("productName", bi.getProduct().getProductName());
                    alert.put("message", String.format("Out of stock: %s", bi.getProduct().getProductName()));
                    return alert;
                })
                .toList();
    }

    @Override
    public List<Map<String, Object>> getExpiryAlerts(Long branchId, int daysThreshold) {
        LocalDate alertDate = LocalDate.now().plusDays(daysThreshold);
        List<InventoryBatch> expiringBatches = inventoryBatchRepository.findExpiringBatchesForAlert(branchId, alertDate);

        return expiringBatches.stream()
                .map(batch -> {
                    Map<String, Object> alert = new HashMap<>();
                    long daysToExpiry = java.time.temporal.ChronoUnit.DAYS.between(
                            LocalDate.now(), batch.getExpiryDate());
                    
                    alert.put("type", "EXPIRING_STOCK");
                    alert.put("severity", daysToExpiry <= 7 ? "CRITICAL" : "WARNING");
                    alert.put("productId", batch.getProduct().getId());
                    alert.put("productName", batch.getProduct().getProductName());
                    alert.put("batchNumber", batch.getBatchNumber());
                    alert.put("quantity", batch.getQuantityAvailable());
                    alert.put("expiryDate", batch.getExpiryDate());
                    alert.put("daysToExpiry", daysToExpiry);
                    alert.put("message", String.format("Batch %s of %s expires in %d days",
                            batch.getBatchNumber(), batch.getProduct().getProductName(), daysToExpiry));
                    return alert;
                })
                .toList();
    }

    @Override
    public List<Map<String, Object>> getOverdueInvoiceAlerts(Long branchId) {
        List<Invoice> overdueInvoices = invoiceRepository.findOverdueInvoices(LocalDate.now());
        return overdueInvoices.stream()
                .filter(invoice -> branchId == null || invoice.getBranch().getId().equals(branchId))
                .map(invoice -> {
                    Map<String, Object> alert = new HashMap<>();
                    long daysOverdue = java.time.temporal.ChronoUnit.DAYS.between(
                            invoice.getDueDate(), LocalDate.now());
                    
                    alert.put("type", "OVERDUE_INVOICE");
                    alert.put("severity", daysOverdue > 30 ? "CRITICAL" : "WARNING");
                    alert.put("invoiceId", invoice.getId());
                    alert.put("invoiceNumber", invoice.getInvoiceNumber());
                    alert.put("customerId", invoice.getCustomer() != null ? invoice.getCustomer().getId() : null);
                    alert.put("amount", invoice.getBalanceAmount());
                    alert.put("dueDate", invoice.getDueDate());
                    alert.put("daysOverdue", daysOverdue);
                    alert.put("message", String.format("Invoice %s is %d days overdue",
                            invoice.getInvoiceNumber(), daysOverdue));
                    return alert;
                })
                .toList();
    }

    @Override
    public List<Map<String, Object>> getOverduePaymentAlerts(Long branchId) {
        // Placeholder - would need supplier payment tracking
        return List.of();
    }

    @Override
    public List<Map<String, Object>> getPendingApprovalAlerts(Long branchId) {
        // Placeholder - would need approval workflow tracking
        return List.of();
    }

    @Override
    public List<Map<String, Object>> getRecentActivityAlerts(Long branchId, int limit) {
        // Placeholder - would need activity logging
        return List.of();
    }

    @Override
    public Map<String, Object> getAllAlerts(Long branchId) {
        Map<String, Object> allAlerts = new HashMap<>();
        
        allAlerts.put("lowStock", getLowStockAlerts(branchId));
        allAlerts.put("outOfStock", getOutOfStockAlerts(branchId));
        allAlerts.put("expiring", getExpiryAlerts(branchId, 30));
        allAlerts.put("overdueInvoices", getOverdueInvoiceAlerts(branchId));
        allAlerts.put("overduePayments", getOverduePaymentAlerts(branchId));
        allAlerts.put("pendingApprovals", getPendingApprovalAlerts(branchId));
        allAlerts.put("totalCount", getAlertCount(branchId));
        
        return allAlerts;
    }

    @Override
    public int getAlertCount(Long branchId) {
        int count = 0;
        count += getLowStockAlerts(branchId).size();
        count += getOutOfStockAlerts(branchId).size();
        count += getExpiryAlerts(branchId, 30).size();
        count += getOverdueInvoiceAlerts(branchId).size();
        count += getOverduePaymentAlerts(branchId).size();
        count += getPendingApprovalAlerts(branchId).size();
        return count;
    }

    @Override
    @Transactional
    public void acknowledgeAlert(Long alertId) {
        // Placeholder - would need alert persistence model
        log.info("Alert {} acknowledged", alertId);
    }

    @Override
    @Transactional
    public void acknowledgeAllAlerts(Long branchId, String alertType) {
        // Placeholder - would need alert persistence model
        log.info("All alerts of type {} acknowledged for branch {}", alertType, branchId);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\FinancialReportService.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

public interface FinancialReportService {
    
    // Revenue reports
    BigDecimal getTotalRevenue(Long branchId, LocalDate startDate, LocalDate endDate);
    Map<String, BigDecimal> getRevenueByCategory(Long branchId, LocalDate startDate, LocalDate endDate);
    Map<String, BigDecimal> getDailyRevenue(Long branchId, LocalDate startDate, LocalDate endDate);
    
    // Expense reports
    BigDecimal getTotalExpenses(Long branchId, LocalDate startDate, LocalDate endDate);
    Map<String, BigDecimal> getExpensesByCategory(Long branchId, LocalDate startDate, LocalDate endDate);
    
    // Profit reports
    Map<String, Object> getProfitAndLossReport(Long branchId, LocalDate startDate, LocalDate endDate);
    BigDecimal getGrossProfit(Long branchId, LocalDate startDate, LocalDate endDate);
    BigDecimal getNetProfit(Long branchId, LocalDate startDate, LocalDate endDate);
    
    // Cash flow
    Map<String, Object> getCashFlowReport(Long branchId, LocalDate startDate, LocalDate endDate);
    
    // Receivables and Payables
    BigDecimal getTotalReceivables(Long branchId);
    BigDecimal getTotalPayables(Long branchId);
    List<Map<String, Object>> getAgeingReport(Long branchId, String type); // type: receivables or payables
    
    // Tax reports
    Map<String, BigDecimal> getTaxSummary(Long branchId, LocalDate startDate, LocalDate endDate);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\FinancialReportServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import com.pharmacy.medlan.enums.InvoiceStatus;
import com.pharmacy.medlan.enums.SaleStatus;
import com.pharmacy.medlan.model.pos.Invoice;
import com.pharmacy.medlan.model.pos.Sale;
import com.pharmacy.medlan.model.pos.SaleItem;
import com.pharmacy.medlan.repository.pos.InvoiceRepository;
import com.pharmacy.medlan.repository.pos.SaleRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.*;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class FinancialReportServiceImpl implements FinancialReportService {

    private final SaleRepository saleRepository;
    private final InvoiceRepository invoiceRepository;

    @Override
    public BigDecimal getTotalRevenue(Long branchId, LocalDate startDate, LocalDate endDate) {
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(LocalTime.MAX);
        
        BigDecimal total = saleRepository.getTotalSalesByBranchAndDate(branchId, startDateTime, endDateTime);
        return total != null ? total : BigDecimal.ZERO;
    }

    @Override
    public Map<String, BigDecimal> getRevenueByCategory(Long branchId, LocalDate startDate, LocalDate endDate) {
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(LocalTime.MAX);
        
        List<Sale> sales = saleRepository.findByBranchAndDateRange(branchId, startDateTime, endDateTime);
        Map<String, BigDecimal> categoryRevenue = new HashMap<>();
        
        for (Sale sale : sales) {
            if (sale.getStatus() == SaleStatus.COMPLETED && sale.getSaleItems() != null) {
                for (SaleItem item : sale.getSaleItems()) {
                    String categoryName = item.getProduct().getCategory() != null ?
                            item.getProduct().getCategory().getCategoryName() : "Uncategorized";
                    categoryRevenue.merge(categoryName, item.getTotalAmount(), BigDecimal::add);
                }
            }
        }
        return categoryRevenue;
    }

    @Override
    public Map<String, BigDecimal> getDailyRevenue(Long branchId, LocalDate startDate, LocalDate endDate) {
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(LocalTime.MAX);
        
        List<Sale> sales = saleRepository.findByBranchAndDateRange(branchId, startDateTime, endDateTime);
        Map<String, BigDecimal> dailyRevenue = new TreeMap<>();
        
        for (Sale sale : sales) {
            if (sale.getStatus() == SaleStatus.COMPLETED) {
                String dateKey = sale.getSaleDate().toLocalDate().toString();
                dailyRevenue.merge(dateKey, sale.getTotalAmount(), BigDecimal::add);
            }
        }
        return dailyRevenue;
    }

    @Override
    public BigDecimal getTotalExpenses(Long branchId, LocalDate startDate, LocalDate endDate) {
        // Would need expense tracking - placeholder
        return BigDecimal.ZERO;
    }

    @Override
    public Map<String, BigDecimal> getExpensesByCategory(Long branchId, LocalDate startDate, LocalDate endDate) {
        // Would need expense tracking - placeholder
        return Map.of();
    }

    @Override
    public Map<String, Object> getProfitAndLossReport(Long branchId, LocalDate startDate, LocalDate endDate) {
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(LocalTime.MAX);
        
        List<Sale> sales = saleRepository.findByBranchAndDateRange(branchId, startDateTime, endDateTime);
        
        BigDecimal totalRevenue = BigDecimal.ZERO;
        BigDecimal totalCost = BigDecimal.ZERO;
        
        for (Sale sale : sales) {
            if (sale.getStatus() == SaleStatus.COMPLETED) {
                totalRevenue = totalRevenue.add(sale.getTotalAmount());
                
                if (sale.getSaleItems() != null) {
                    for (SaleItem item : sale.getSaleItems()) {
                        if (item.getCostPrice() != null) {
                            totalCost = totalCost.add(
                                    item.getCostPrice().multiply(BigDecimal.valueOf(item.getQuantity())));
                        }
                    }
                }
            }
        }
        
        BigDecimal grossProfit = totalRevenue.subtract(totalCost);
        BigDecimal profitMargin = totalRevenue.compareTo(BigDecimal.ZERO) > 0 ?
                grossProfit.multiply(BigDecimal.valueOf(100)).divide(totalRevenue, 2, RoundingMode.HALF_UP) :
                BigDecimal.ZERO;
        
        Map<String, Object> report = new HashMap<>();
        report.put("startDate", startDate);
        report.put("endDate", endDate);
        report.put("totalRevenue", totalRevenue);
        report.put("totalCost", totalCost);
        report.put("grossProfit", grossProfit);
        report.put("profitMargin", profitMargin);
        
        return report;
    }

    @Override
    public BigDecimal getGrossProfit(Long branchId, LocalDate startDate, LocalDate endDate) {
        Map<String, Object> pnl = getProfitAndLossReport(branchId, startDate, endDate);
        return (BigDecimal) pnl.get("grossProfit");
    }

    @Override
    public BigDecimal getNetProfit(Long branchId, LocalDate startDate, LocalDate endDate) {
        BigDecimal grossProfit = getGrossProfit(branchId, startDate, endDate);
        BigDecimal expenses = getTotalExpenses(branchId, startDate, endDate);
        return grossProfit.subtract(expenses);
    }

    @Override
    public Map<String, Object> getCashFlowReport(Long branchId, LocalDate startDate, LocalDate endDate) {
        BigDecimal totalSales = getTotalRevenue(branchId, startDate, endDate);
        
        // Get paid invoices
        List<Invoice> invoices = invoiceRepository.findByBranchAndDateRange(branchId, startDate, endDate);
        BigDecimal cashReceived = invoices.stream()
                .filter(inv -> inv.getStatus() == InvoiceStatus.PAID)
                .map(Invoice::getPaidAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        Map<String, Object> summary = new HashMap<>();
        summary.put("startDate", startDate);
        summary.put("endDate", endDate);
        summary.put("totalSales", totalSales);
        summary.put("cashReceived", cashReceived);
        summary.put("cashPayments", BigDecimal.ZERO); // Would need payment tracking
        summary.put("netCashFlow", cashReceived);
        
        return summary;
    }

    @Override
    public BigDecimal getTotalReceivables(Long branchId) {
        BigDecimal outstanding = invoiceRepository.getTotalOutstandingByBranch(branchId);
        return outstanding != null ? outstanding : BigDecimal.ZERO;
    }

    @Override
    public BigDecimal getTotalPayables(Long branchId) {
        // Would need supplier payment tracking - placeholder
        return BigDecimal.ZERO;
    }

    @Override
    public List<Map<String, Object>> getAgeingReport(Long branchId, String type) {
        if ("receivables".equalsIgnoreCase(type)) {
            List<Invoice> invoices = invoiceRepository.findByBranchId(branchId);
            List<Map<String, Object>> agingReport = new ArrayList<>();
            LocalDate today = LocalDate.now();
            
            for (Invoice invoice : invoices) {
                if (invoice.getStatus() == InvoiceStatus.ISSUED || 
                    invoice.getStatus() == InvoiceStatus.PARTIALLY_PAID ||
                    invoice.getStatus() == InvoiceStatus.OVERDUE) {
                    
                    Map<String, Object> item = new HashMap<>();
                    item.put("invoiceId", invoice.getId());
                    item.put("invoiceNumber", invoice.getInvoiceNumber());
                    item.put("customerName", invoice.getCustomer() != null ? invoice.getCustomer().getCustomerName() : "N/A");
                    item.put("totalAmount", invoice.getTotalAmount());
                    item.put("balanceAmount", invoice.getBalanceAmount());
                    
                    if (invoice.getDueDate() != null) {
                        long daysOverdue = java.time.temporal.ChronoUnit.DAYS.between(invoice.getDueDate(), today);
                        item.put("daysOverdue", Math.max(0, daysOverdue));
                        
                        String agingBucket;
                        if (daysOverdue <= 0) agingBucket = "Current";
                        else if (daysOverdue <= 30) agingBucket = "1-30 Days";
                        else if (daysOverdue <= 60) agingBucket = "31-60 Days";
                        else if (daysOverdue <= 90) agingBucket = "61-90 Days";
                        else agingBucket = "90+ Days";
                        item.put("agingBucket", agingBucket);
                    } else {
                        item.put("daysOverdue", 0);
                        item.put("agingBucket", "Current");
                    }
                    
                    agingReport.add(item);
                }
            }
            return agingReport;
        }
        return List.of(); // Payables would need supplier payment tracking
    }

    @Override
    public Map<String, BigDecimal> getTaxSummary(Long branchId, LocalDate startDate, LocalDate endDate) {
        LocalDateTime startDateTime = startDate.atStartOfDay();
        LocalDateTime endDateTime = endDate.atTime(LocalTime.MAX);
        
        List<Sale> sales = saleRepository.findByBranchAndDateRange(branchId, startDateTime, endDateTime);
        
        BigDecimal totalTaxCollected = BigDecimal.ZERO;
        Map<String, BigDecimal> taxByRate = new HashMap<>();
        
        for (Sale sale : sales) {
            if (sale.getStatus() == SaleStatus.COMPLETED && sale.getTaxAmount() != null) {
                totalTaxCollected = totalTaxCollected.add(sale.getTaxAmount());
            }
        }
        
        Map<String, BigDecimal> summary = new HashMap<>();
        summary.put("totalTaxCollected", totalTaxCollected);
        summary.put("totalTaxPayable", BigDecimal.ZERO); // Would need input tax tracking
        summary.put("netTax", totalTaxCollected);
        
        return summary;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\InventoryReportService.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

public interface InventoryReportService {
    
    // Stock value reports
    BigDecimal getTotalStockValue(Long branchId);
    Map<String, BigDecimal> getStockValueByCategory(Long branchId);
    
    // Stock movement reports
    List<Map<String, Object>> getStockMovementReport(Long branchId, LocalDate startDate, LocalDate endDate);
    
    // Low stock and expiry reports
    List<Map<String, Object>> getLowStockReport(Long branchId);
    List<Map<String, Object>> getExpiringStockReport(Long branchId, int daysToExpiry);
    List<Map<String, Object>> getExpiredStockReport(Long branchId);
    
    // Stock turnover analysis
    Map<String, Object> getStockTurnoverReport(Long branchId, LocalDate startDate, LocalDate endDate);
    
    // Dead stock report
    List<Map<String, Object>> getDeadStockReport(Long branchId, int daysSinceLastSale);
    
    // Stock summary
    Map<String, Object> getInventorySummary(Long branchId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\InventoryReportServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import com.pharmacy.medlan.model.product.BranchInventory;
import com.pharmacy.medlan.model.product.InventoryBatch;
import com.pharmacy.medlan.repository.product.BranchInventoryRepository;
import com.pharmacy.medlan.repository.product.InventoryBatchRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.*;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class InventoryReportServiceImpl implements InventoryReportService {

    private final BranchInventoryRepository branchInventoryRepository;
    private final InventoryBatchRepository inventoryBatchRepository;

    @Override
    public BigDecimal getTotalStockValue(Long branchId) {
        List<BranchInventory> inventories = branchInventoryRepository.findByBranchId(branchId);
        BigDecimal totalValue = BigDecimal.ZERO;
        
        for (BranchInventory bi : inventories) {
            List<InventoryBatch> batches = inventoryBatchRepository.findByProductIdAndBranchId(
                    bi.getProduct().getId(), branchId);
            for (InventoryBatch batch : batches) {
                if (batch.getQuantityAvailable() > 0) {
                    totalValue = totalValue.add(
                            batch.getPurchasePrice().multiply(BigDecimal.valueOf(batch.getQuantityAvailable())));
                }
            }
        }
        return totalValue;
    }

    @Override
    public Map<String, BigDecimal> getStockValueByCategory(Long branchId) {
        List<BranchInventory> inventories = branchInventoryRepository.findByBranchId(branchId);
        Map<String, BigDecimal> categoryValues = new HashMap<>();
        
        for (BranchInventory bi : inventories) {
            String categoryName = bi.getProduct().getCategory() != null ?
                    bi.getProduct().getCategory().getCategoryName() : "Uncategorized";
            
            List<InventoryBatch> batches = inventoryBatchRepository.findByProductIdAndBranchId(
                    bi.getProduct().getId(), branchId);
            BigDecimal itemValue = batches.stream()
                    .filter(b -> b.getQuantityAvailable() > 0)
                    .map(b -> b.getPurchasePrice().multiply(BigDecimal.valueOf(b.getQuantityAvailable())))
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            
            categoryValues.merge(categoryName, itemValue, BigDecimal::add);
        }
        return categoryValues;
    }

    @Override
    public List<Map<String, Object>> getStockMovementReport(Long branchId, LocalDate startDate, LocalDate endDate) {
        // Would need to query InventoryTransaction or bin card for movements
        // Placeholder implementation
        return List.of();
    }

    @Override
    public List<Map<String, Object>> getLowStockReport(Long branchId) {
        List<BranchInventory> lowStockItems = branchInventoryRepository.findLowStockByBranch(branchId);
        return lowStockItems.stream()
                .map(bi -> {
                    Map<String, Object> item = new HashMap<>();
                    item.put("productId", bi.getProduct().getId());
                    item.put("productName", bi.getProduct().getProductName());
                    item.put("productCode", bi.getProduct().getProductCode());
                    item.put("currentStock", bi.getQuantityAvailable());
                    item.put("reorderLevel", bi.getReorderLevel());
                    item.put("minimumStock", bi.getMinimumStock());
                    item.put("shortfall", bi.getReorderLevel() - bi.getQuantityAvailable());
                    return item;
                })
                .toList();
    }

    @Override
    public List<Map<String, Object>> getExpiringStockReport(Long branchId, int daysToExpiry) {
        LocalDate alertDate = LocalDate.now().plusDays(daysToExpiry);
        List<InventoryBatch> expiringBatches = inventoryBatchRepository.findExpiringBatchesForAlert(branchId, alertDate);
        
        return expiringBatches.stream()
                .map(batch -> {
                    Map<String, Object> item = new HashMap<>();
                    item.put("productId", batch.getProduct().getId());
                    item.put("productName", batch.getProduct().getProductName());
                    item.put("batchNumber", batch.getBatchNumber());
                    item.put("quantity", batch.getQuantityAvailable());
                    item.put("expiryDate", batch.getExpiryDate());
                    item.put("daysToExpiry", java.time.temporal.ChronoUnit.DAYS.between(
                            LocalDate.now(), batch.getExpiryDate()));
                    item.put("value", batch.getPurchasePrice().multiply(
                            BigDecimal.valueOf(batch.getQuantityAvailable())));
                    return item;
                })
                .toList();
    }

    @Override
    public List<Map<String, Object>> getExpiredStockReport(Long branchId) {
        List<InventoryBatch> expiredBatches = inventoryBatchRepository.findExpiredBatches(LocalDate.now());
        
        return expiredBatches.stream()
                .filter(batch -> branchId == null || batch.getBranch().getId().equals(branchId))
                .map(batch -> {
                    Map<String, Object> item = new HashMap<>();
                    item.put("productId", batch.getProduct().getId());
                    item.put("productName", batch.getProduct().getProductName());
                    item.put("batchNumber", batch.getBatchNumber());
                    item.put("quantity", batch.getQuantityAvailable());
                    item.put("expiryDate", batch.getExpiryDate());
                    item.put("value", batch.getPurchasePrice().multiply(
                            BigDecimal.valueOf(batch.getQuantityAvailable())));
                    return item;
                })
                .toList();
    }

    @Override
    public Map<String, Object> getStockTurnoverReport(Long branchId, LocalDate startDate, LocalDate endDate) {
        // Would need sales history analysis - placeholder
        Map<String, Object> report = new HashMap<>();
        report.put("period", Map.of("startDate", startDate, "endDate", endDate));
        report.put("message", "Stock turnover report requires sales history integration");
        return report;
    }

    @Override
    public List<Map<String, Object>> getDeadStockReport(Long branchId, int daysSinceLastSale) {
        // Would need to track last sale date - placeholder
        List<BranchInventory> inventories = branchInventoryRepository.findByBranchId(branchId);
        return inventories.stream()
                .filter(bi -> bi.getQuantityOnHand() > 0)
                .map(bi -> {
                    Map<String, Object> item = new HashMap<>();
                    item.put("productId", bi.getProduct().getId());
                    item.put("productName", bi.getProduct().getProductName());
                    item.put("quantity", bi.getQuantityOnHand());
                    item.put("daysSinceLastSale", daysSinceLastSale); // placeholder
                    return item;
                })
                .limit(20) // Limit results
                .toList();
    }

    @Override
    public Map<String, Object> getInventorySummary(Long branchId) {
        List<BranchInventory> inventories = branchInventoryRepository.findByBranchId(branchId);
        
        int totalProducts = inventories.size();
        int totalQuantity = inventories.stream()
                .mapToInt(BranchInventory::getQuantityOnHand)
                .sum();
        
        int lowStockCount = (int) inventories.stream()
                .filter(bi -> bi.getQuantityAvailable() < bi.getReorderLevel() && bi.getQuantityAvailable() > 0)
                .count();
        
        int outOfStockCount = (int) inventories.stream()
                .filter(bi -> bi.getQuantityAvailable() <= 0)
                .count();
        
        LocalDate alertDate = LocalDate.now().plusDays(30);
        int expiringCount = inventoryBatchRepository.findExpiringBatchesForAlert(branchId, alertDate).size();
        int expiredCount = inventoryBatchRepository.findExpiredBatches(LocalDate.now()).stream()
                .filter(b -> branchId == null || b.getBranch().getId().equals(branchId))
                .toList().size();
        
        BigDecimal totalValue = getTotalStockValue(branchId);
        
        Map<String, Object> summary = new HashMap<>();
        summary.put("totalProducts", totalProducts);
        summary.put("totalQuantity", totalQuantity);
        summary.put("totalValue", totalValue);
        summary.put("lowStockCount", lowStockCount);
        summary.put("outOfStockCount", outOfStockCount);
        summary.put("expiringCount", expiringCount);
        summary.put("expiredCount", expiredCount);
        
        return summary;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\PdfGenerationService.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import com.pharmacy.medlan.dto.response.report.ExportResponse;

import java.time.LocalDate;
import java.util.List;

/**
 * Service for generating PDF reports and documents.
 */
public interface PdfGenerationService {

    /**
     * Generate PDF invoice with barcode
     */
    ExportResponse generateInvoicePdf(Long invoiceId);

    /**
     * Generate PDF invoice with QR code
     */
    ExportResponse generateInvoiceWithQR(Long invoiceId);

    /**
     * Generate daily sales report PDF
     */
    ExportResponse generateDailySalesReport(Long branchId, LocalDate date);

    /**
     * Generate stock report PDF
     */
    ExportResponse generateStockReport(Long branchId);

    /**
     * Generate expiry report PDF
     */
    ExportResponse generateExpiryReport(Long branchId, int daysThreshold);

    /**
     * Generate low stock report PDF
     */
    ExportResponse generateLowStockReport(Long branchId);

    /**
     * Generate product catalog PDF
     */
    ExportResponse generateProductCatalog(Long categoryId);

    /**
     * Generate barcode labels PDF for printing
     */
    ExportResponse generateBarcodeLabels(List<Long> productIds, String labelFormat);

    /**
     * Generate GRN document PDF
     */
    ExportResponse generateGRNDocument(Long grnId);

    /**
     * Generate Purchase Order PDF
     */
    ExportResponse generatePurchaseOrderPdf(Long poId);

    /**
     * Generate stock transfer document
     */
    ExportResponse generateStockTransferDocument(Long transferId);

    /**
     * Generate prescription label
     */
    ExportResponse generatePrescriptionLabel(Long saleItemId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\SalesReportService.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import com.pharmacy.medlan.dto.response.pos.SaleResponse;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;

public interface SalesReportService {

    BigDecimal getTotalSales(Long branchId, LocalDate startDate, LocalDate endDate);

    Long getSalesCount(Long branchId, LocalDate startDate, LocalDate endDate);

    List<SaleResponse> getSalesReport(Long branchId, LocalDate startDate, LocalDate endDate);

    Map<String, BigDecimal> getDailySalesSummary(Long branchId, LocalDate startDate, LocalDate endDate);

    List<Map<String, Object>> getTopSellingProducts(Long branchId, LocalDate startDate, LocalDate endDate, int limit);

    List<Map<String, Object>> getSalesByPaymentMethod(Long branchId, LocalDate startDate, LocalDate endDate);

    Map<String, Object> getSalesComparison(Long branchId, LocalDate startDate1, LocalDate endDate1, 
                                            LocalDate startDate2, LocalDate endDate2);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\report\SalesReportServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.report;

import com.pharmacy.medlan.dto.response.pos.SaleResponse;
import com.pharmacy.medlan.mapper.SaleMapper;
import com.pharmacy.medlan.model.pos.Sale;
import com.pharmacy.medlan.repository.pos.SaleRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class SalesReportServiceImpl implements SalesReportService {

    private final SaleRepository saleRepository;
    private final SaleMapper saleMapper;

    @Override
    public BigDecimal getTotalSales(Long branchId, LocalDate startDate, LocalDate endDate) {
        BigDecimal total = saleRepository.getTotalSalesByBranchAndDate(
                branchId, startDate.atStartOfDay(), endDate.atTime(LocalTime.MAX));
        return total != null ? total : BigDecimal.ZERO;
    }

    @Override
    public Long getSalesCount(Long branchId, LocalDate startDate, LocalDate endDate) {
        return (long) saleRepository.findByBranchAndDateRange(
                branchId, startDate.atStartOfDay(), endDate.atTime(LocalTime.MAX)).size();
    }

    @Override
    public List<SaleResponse> getSalesReport(Long branchId, LocalDate startDate, LocalDate endDate) {
        List<Sale> sales = saleRepository.findByBranchAndDateRange(
                branchId, startDate.atStartOfDay(), endDate.atTime(LocalTime.MAX));
        return saleMapper.toResponseList(sales);
    }

    @Override
    public Map<String, BigDecimal> getDailySalesSummary(Long branchId, LocalDate startDate, LocalDate endDate) {
        Map<String, BigDecimal> dailySales = new LinkedHashMap<>();
        LocalDate current = startDate;

        while (!current.isAfter(endDate)) {
            BigDecimal dailyTotal = saleRepository.getTotalSalesByBranchAndDate(
                    branchId, current.atStartOfDay(), current.atTime(LocalTime.MAX));
            dailySales.put(current.toString(), dailyTotal != null ? dailyTotal : BigDecimal.ZERO);
            current = current.plusDays(1);
        }

        return dailySales;
    }

    @Override
    public List<Map<String, Object>> getTopSellingProducts(Long branchId, LocalDate startDate, 
            LocalDate endDate, int limit) {
        // Simplified implementation - returns placeholder
        return List.of();
    }

    @Override
    public List<Map<String, Object>> getSalesByPaymentMethod(Long branchId, LocalDate startDate, 
            LocalDate endDate) {
        List<Sale> sales = saleRepository.findByBranchAndDateRange(
                branchId, startDate.atStartOfDay(), endDate.atTime(LocalTime.MAX));

        Map<String, BigDecimal> byMethod = sales.stream()
                .collect(Collectors.groupingBy(
                        s -> s.getPaymentMethod().name(),
                        Collectors.reducing(BigDecimal.ZERO, Sale::getTotalAmount, BigDecimal::add)
                ));

        return byMethod.entrySet().stream()
                .map(e -> {
                    Map<String, Object> map = new HashMap<>();
                    map.put("paymentMethod", e.getKey());
                    map.put("total", e.getValue());
                    return map;
                })
                .collect(Collectors.toList());
    }

    @Override
    public Map<String, Object> getSalesComparison(Long branchId, LocalDate startDate1, LocalDate endDate1,
            LocalDate startDate2, LocalDate endDate2) {
        BigDecimal period1Total = getTotalSales(branchId, startDate1, endDate1);
        BigDecimal period2Total = getTotalSales(branchId, startDate2, endDate2);

        Map<String, Object> comparison = new HashMap<>();
        comparison.put("period1", Map.of("start", startDate1, "end", endDate1, "total", period1Total));
        comparison.put("period2", Map.of("start", startDate2, "end", endDate2, "total", period2Total));
        
        BigDecimal difference = period2Total.subtract(period1Total);
        comparison.put("difference", difference);
        
        if (period1Total.compareTo(BigDecimal.ZERO) != 0) {
            BigDecimal percentChange = difference.multiply(BigDecimal.valueOf(100))
                    .divide(period1Total, 2, java.math.RoundingMode.HALF_UP);
            comparison.put("percentChange", percentChange);
        } else {
            comparison.put("percentChange", BigDecimal.ZERO);
        }

        return comparison;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\supplier\GoodsReceiptService.java"   & echo.. 
package com.pharmacy.medlan.service.supplier;

public interface GoodsReceiptService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\supplier\GoodsReceiptServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.supplier;

public class GoodsReceiptServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\supplier\PurchaseOrderService.java"   & echo.. 
package com.pharmacy.medlan.service.supplier;

import com.pharmacy.medlan.dto.request.supplier.CreatePurchaseOrderRequest;
import com.pharmacy.medlan.dto.response.supplier.PurchaseOrderResponse;
import com.pharmacy.medlan.enums.PurchaseOrderStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

public interface PurchaseOrderService {
    
    PurchaseOrderResponse createPurchaseOrder(CreatePurchaseOrderRequest request);
    
    PurchaseOrderResponse getById(Long id);
    
    PurchaseOrderResponse getByPoNumber(String poNumber);
    
    Page<PurchaseOrderResponse> getAllPurchaseOrders(Pageable pageable);
    
    List<PurchaseOrderResponse> getBySupplier(Long supplierId);
    
    List<PurchaseOrderResponse> getByBranch(Long branchId);
    
    List<PurchaseOrderResponse> getByStatus(PurchaseOrderStatus status);
    
    List<PurchaseOrderResponse> getByDateRange(LocalDate startDate, LocalDate endDate);
    
    PurchaseOrderResponse updateStatus(Long id, PurchaseOrderStatus status);
    
    PurchaseOrderResponse approvePurchaseOrder(Long id);
    
    PurchaseOrderResponse rejectPurchaseOrder(Long id, String reason);
    
    void deletePurchaseOrder(Long id);
    
    String generatePoNumber();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\supplier\PurchaseOrderServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.supplier;

import com.pharmacy.medlan.dto.request.supplier.CreatePurchaseOrderRequest;
import com.pharmacy.medlan.dto.response.supplier.PurchaseOrderResponse;
import com.pharmacy.medlan.enums.PurchaseOrderStatus;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.PurchaseOrderMapper;
import com.pharmacy.medlan.model.organization.Branch;
import com.pharmacy.medlan.model.product.Product;
import com.pharmacy.medlan.model.supplier.PurchaseOrder;
import com.pharmacy.medlan.model.supplier.PurchaseOrderItem;
import com.pharmacy.medlan.model.supplier.Supplier;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.organization.BranchRepository;
import com.pharmacy.medlan.repository.product.ProductRepository;
import com.pharmacy.medlan.repository.supplier.PurchaseOrderRepository;
import com.pharmacy.medlan.repository.supplier.SupplierRepository;
import com.pharmacy.medlan.repository.user.UserRepository;
import com.pharmacy.medlan.security.SecurityUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Year;
import java.util.List;

@Service
@Slf4j
@RequiredArgsConstructor
@Transactional
public class PurchaseOrderServiceImpl implements PurchaseOrderService {

    private final PurchaseOrderRepository purchaseOrderRepository;
    private final SupplierRepository supplierRepository;
    private final BranchRepository branchRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;
    private final PurchaseOrderMapper purchaseOrderMapper;

    @Override
    public PurchaseOrderResponse createPurchaseOrder(CreatePurchaseOrderRequest request) {
        Supplier supplier = supplierRepository.findById(request.getSupplierId())
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found"));
        Branch branch = branchRepository.findById(request.getBranchId())
                .orElseThrow(() -> new ResourceNotFoundException("Branch not found"));

        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        // SUPER_ADMIN doesn't need approval - auto-approve
        boolean isSuperAdmin = currentUser.getRole().name().equals("SUPER_ADMIN");
        PurchaseOrderStatus initialStatus = isSuperAdmin ? PurchaseOrderStatus.APPROVED : PurchaseOrderStatus.DRAFT;

        PurchaseOrder po = PurchaseOrder.builder()
                .poNumber(generatePoNumber())
                .supplier(supplier)
                .branch(branch)
                .orderDate(LocalDate.now())
                .expectedDeliveryDate(request.getExpectedDeliveryDate())
                .status(initialStatus)
                .createdByUser(currentUser)
                .remarks(request.getRemarks())
                .supplierReference(request.getSupplierReference())
                .discountAmount(request.getDiscountAmount() != null ? request.getDiscountAmount() : BigDecimal.ZERO)
                .build();

        // If SUPER_ADMIN, set approval details immediately
        if (isSuperAdmin) {
            po.setApprovedByUser(currentUser);
            po.setApprovedAt(LocalDateTime.now());
        }

        BigDecimal totalAmount = BigDecimal.ZERO;
        BigDecimal totalTax = BigDecimal.ZERO;

        for (CreatePurchaseOrderRequest.PurchaseOrderItemRequest itemRequest : request.getItems()) {
            Product product = productRepository.findById(itemRequest.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product not found: " + itemRequest.getProductId()));

            BigDecimal lineAmount = itemRequest.getUnitPrice()
                    .multiply(BigDecimal.valueOf(itemRequest.getQuantityOrdered()));
            
            BigDecimal discountPercent = itemRequest.getDiscountPercent() != null ? 
                    itemRequest.getDiscountPercent() : BigDecimal.ZERO;
            BigDecimal discountAmount = lineAmount.multiply(discountPercent)
                    .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);
            
            BigDecimal afterDiscount = lineAmount.subtract(discountAmount);
            BigDecimal gstAmount = afterDiscount.multiply(itemRequest.getGstRate())
                    .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);
            BigDecimal itemTotal = afterDiscount.add(gstAmount);

            PurchaseOrderItem item = PurchaseOrderItem.builder()
                    .purchaseOrder(po)
                    .product(product)
                    .quantityOrdered(itemRequest.getQuantityOrdered())
                    .quantityReceived(0)
                    .unitPrice(itemRequest.getUnitPrice())
                    .discountPercent(discountPercent)
                    .discountAmount(discountAmount)
                    .gstRate(itemRequest.getGstRate())
                    .gstAmount(gstAmount)
                    .totalAmount(itemTotal)
                    .remarks(itemRequest.getRemarks())
                    .build();

            po.getItems().add(item);
            totalAmount = totalAmount.add(lineAmount);
            totalTax = totalTax.add(gstAmount);
        }

        po.setTotalAmount(totalAmount);
        po.setTaxAmount(totalTax);
        po.setNetAmount(totalAmount.subtract(po.getDiscountAmount()).add(totalTax));

        po = purchaseOrderRepository.save(po);
        if (isSuperAdmin) {
            log.info("Purchase order created and auto-approved by SUPER_ADMIN: {}", po.getPoNumber());
        } else {
            log.info("Purchase order created: {}", po.getPoNumber());
        }

        return purchaseOrderMapper.toResponse(po);
    }

    @Override
    @Transactional(readOnly = true)
    public PurchaseOrderResponse getById(Long id) {
        PurchaseOrder po = purchaseOrderRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Purchase order not found"));
        return purchaseOrderMapper.toResponse(po);
    }

    @Override
    @Transactional(readOnly = true)
    public PurchaseOrderResponse getByPoNumber(String poNumber) {
        PurchaseOrder po = purchaseOrderRepository.findByPoNumber(poNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Purchase order not found"));
        return purchaseOrderMapper.toResponse(po);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<PurchaseOrderResponse> getAllPurchaseOrders(Pageable pageable) {
        return purchaseOrderRepository.findAll(pageable).map(purchaseOrderMapper::toResponse);
    }

    @Override
    @Transactional(readOnly = true)
    public List<PurchaseOrderResponse> getBySupplier(Long supplierId) {
        return purchaseOrderMapper.toResponseList(purchaseOrderRepository.findBySupplierId(supplierId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<PurchaseOrderResponse> getByBranch(Long branchId) {
        return purchaseOrderMapper.toResponseList(purchaseOrderRepository.findByBranchId(branchId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<PurchaseOrderResponse> getByStatus(PurchaseOrderStatus status) {
        return purchaseOrderMapper.toResponseList(purchaseOrderRepository.findByStatus(status));
    }

    @Override
    @Transactional(readOnly = true)
    public List<PurchaseOrderResponse> getByDateRange(LocalDate startDate, LocalDate endDate) {
        return purchaseOrderMapper.toResponseList(purchaseOrderRepository.findByOrderDateBetween(startDate, endDate));
    }

    @Override
    public PurchaseOrderResponse updateStatus(Long id, PurchaseOrderStatus status) {
        PurchaseOrder po = purchaseOrderRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Purchase order not found"));

        po.setStatus(status);
        po = purchaseOrderRepository.save(po);
        log.info("Purchase order {} status updated to {}", po.getPoNumber(), status);

        return purchaseOrderMapper.toResponse(po);
    }

    @Override
    public PurchaseOrderResponse approvePurchaseOrder(Long id) {
        PurchaseOrder po = purchaseOrderRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Purchase order not found"));

        if (po.getStatus() != PurchaseOrderStatus.DRAFT && po.getStatus() != PurchaseOrderStatus.PENDING_APPROVAL) {
            throw new IllegalStateException("Only draft or pending approval orders can be approved");
        }

        User currentUser = SecurityUtils.getCurrentUser(userRepository);

        po.setStatus(PurchaseOrderStatus.APPROVED);
        po.setApprovedByUser(currentUser);
        po.setApprovedAt(LocalDateTime.now());

        po = purchaseOrderRepository.save(po);
        log.info("Purchase order approved: {}", po.getPoNumber());

        return purchaseOrderMapper.toResponse(po);
    }

    @Override
    public PurchaseOrderResponse rejectPurchaseOrder(Long id, String reason) {
        PurchaseOrder po = purchaseOrderRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Purchase order not found"));

        if (po.getStatus() != PurchaseOrderStatus.PENDING_APPROVAL) {
            throw new IllegalStateException("Only pending approval orders can be rejected");
        }

        po.setStatus(PurchaseOrderStatus.CANCELLED);
        po.setRemarks(po.getRemarks() + "\nRejection reason: " + reason);

        po = purchaseOrderRepository.save(po);
        log.info("Purchase order rejected: {}", po.getPoNumber());

        return purchaseOrderMapper.toResponse(po);
    }

    @Override
    public void deletePurchaseOrder(Long id) {
        PurchaseOrder po = purchaseOrderRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Purchase order not found"));

        if (po.getStatus() != PurchaseOrderStatus.DRAFT) {
            throw new IllegalStateException("Only draft orders can be deleted");
        }

        purchaseOrderRepository.delete(po);
        log.info("Purchase order deleted: {}", po.getPoNumber());
    }

    @Override
    public String generatePoNumber() {
        long count = purchaseOrderRepository.count() + 1;
        return String.format("PO-%d-%05d", Year.now().getValue(), count);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\supplier\SupplierPaymentService.java"   & echo.. 
package com.pharmacy.medlan.service.supplier;

public interface SupplierPaymentService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\supplier\SupplierPaymentServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.supplier;

public class SupplierPaymentServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\supplier\SupplierService.java"   & echo.. 
package com.pharmacy.medlan.service.supplier;

import com.pharmacy.medlan.dto.request.supplier.CreateSupplierRequest;
import com.pharmacy.medlan.dto.response.supplier.SupplierResponse;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface SupplierService {

    SupplierResponse createSupplier(CreateSupplierRequest request);

    SupplierResponse updateSupplier(Long id, CreateSupplierRequest request);

    SupplierResponse getSupplierById(Long id);

    SupplierResponse getSupplierByCode(String supplierCode);

    Page<SupplierResponse> getAllSuppliers(Pageable pageable, Boolean isActive, String search);

    List<SupplierResponse> searchSuppliers(String search);

    List<SupplierResponse> getActiveSuppliers();

    void deleteSupplier(Long id);

    void activateSupplier(Long id);

    void deactivateSupplier(Long id);

    String generateSupplierCode();
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\supplier\SupplierServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.supplier;

import com.pharmacy.medlan.dto.request.supplier.CreateSupplierRequest;
import com.pharmacy.medlan.dto.response.supplier.SupplierResponse;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.SupplierMapper;
import com.pharmacy.medlan.model.supplier.Supplier;
import com.pharmacy.medlan.repository.supplier.SupplierRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class SupplierServiceImpl implements SupplierService {

    private final SupplierRepository supplierRepository;
    private final SupplierMapper supplierMapper;

    @Override
    @Transactional
    public SupplierResponse createSupplier(CreateSupplierRequest request) {
        log.info("Creating supplier: {}", request.getSupplierName());

        Supplier supplier = supplierMapper.toEntity(request);
        supplier.setSupplierCode(generateSupplierCode());

        Supplier saved = supplierRepository.save(supplier);
        log.info("Supplier created with code: {}", saved.getSupplierCode());

        return supplierMapper.toResponse(saved);
    }

    @Override
    @Transactional
    public SupplierResponse updateSupplier(Long id, CreateSupplierRequest request) {
        log.info("Updating supplier: {}", id);

        Supplier supplier = supplierRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found with id: " + id));

        supplierMapper.updateEntityFromRequest(request, supplier);
        Supplier updated = supplierRepository.save(supplier);

        return supplierMapper.toResponse(updated);
    }

    @Override
    public SupplierResponse getSupplierById(Long id) {
        Supplier supplier = supplierRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found with id: " + id));
        return supplierMapper.toResponse(supplier);
    }

    @Override
    public SupplierResponse getSupplierByCode(String supplierCode) {
        Supplier supplier = supplierRepository.findBySupplierCode(supplierCode)
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found with code: " + supplierCode));
        return supplierMapper.toResponse(supplier);
    }

    @Override
    public Page<SupplierResponse> getAllSuppliers(Pageable pageable, Boolean isActive, String search) {
        // If no filters, return all
        if (isActive == null && (search == null || search.trim().isEmpty())) {
            return supplierRepository.findAll(pageable)
                    .map(supplierMapper::toResponse);
        }
        
        // Build specification for filtering
        return supplierRepository.findAll((root, query, criteriaBuilder) -> {
            var predicates = new java.util.ArrayList<jakarta.persistence.criteria.Predicate>();
            
            // Filter by active status if provided
            if (isActive != null) {
                predicates.add(criteriaBuilder.equal(root.get("isActive"), isActive));
            }
            
            // Filter by search query if provided
            if (search != null && !search.trim().isEmpty()) {
                String searchPattern = "%" + search.toLowerCase() + "%";
                var searchPredicate = criteriaBuilder.or(
                    criteriaBuilder.like(criteriaBuilder.lower(root.get("supplierName")), searchPattern),
                    criteriaBuilder.like(criteriaBuilder.lower(root.get("supplierCode")), searchPattern),
                    criteriaBuilder.like(criteriaBuilder.lower(root.get("contactPerson")), searchPattern),
                    criteriaBuilder.like(criteriaBuilder.lower(root.get("email")), searchPattern)
                );
                predicates.add(searchPredicate);
            }
            
            return criteriaBuilder.and(predicates.toArray(new jakarta.persistence.criteria.Predicate[0]));
        }, pageable).map(supplierMapper::toResponse);
    }

    @Override
    public List<SupplierResponse> searchSuppliers(String search) {
        return supplierRepository.searchSuppliers(search)
                .stream()
                .map(supplierMapper::toResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<SupplierResponse> getActiveSuppliers() {
        return supplierRepository.findByIsActiveTrue()
                .stream()
                .map(supplierMapper::toResponse)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void deleteSupplier(Long id) {
        log.info("Deleting supplier: {}", id);

        Supplier supplier = supplierRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found with id: " + id));

        supplier.setDeleted(true);
        supplier.setIsActive(false);
        supplierRepository.save(supplier);
        log.info("Supplier deleted: {}", id);
    }

    @Override
    @Transactional
    public void activateSupplier(Long id) {
        Supplier supplier = supplierRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found with id: " + id));
        supplier.setIsActive(true);
        supplierRepository.save(supplier);
    }

    @Override
    @Transactional
    public void deactivateSupplier(Long id) {
        Supplier supplier = supplierRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Supplier not found with id: " + id));
        supplier.setIsActive(false);
        supplierRepository.save(supplier);
    }

    @Override
    public String generateSupplierCode() {
        Long count = supplierRepository.count();
        return String.format("SUP-%05d", count + 1);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\sync\SyncService.java"   & echo.. 
package com.pharmacy.medlan.service.sync;

public interface SyncService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\sync\SyncServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.sync;

public class SyncServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\user\AuthService.java"   & echo.. 
package com.pharmacy.medlan.service.user;

import com.pharmacy.medlan.dto.request.auth.ChangePasswordRequest;
import com.pharmacy.medlan.dto.request.auth.LoginRequest;
import com.pharmacy.medlan.dto.request.auth.RegisterRequest;
import com.pharmacy.medlan.dto.response.auth.LoginResponse;
import com.pharmacy.medlan.dto.response.user.UserResponse;

public interface AuthService {

    LoginResponse login(LoginRequest request);

    UserResponse register(RegisterRequest request);

    LoginResponse refreshToken(String refreshToken);

    void changePassword(String username, ChangePasswordRequest request);

    void logout(String username);

    UserResponse getCurrentUser(String username);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\user\AuthServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.user;

import com.pharmacy.medlan.dto.request.auth.ChangePasswordRequest;
import com.pharmacy.medlan.dto.request.auth.LoginRequest;
import com.pharmacy.medlan.dto.request.auth.RegisterRequest;
import com.pharmacy.medlan.dto.response.auth.LoginResponse;
import com.pharmacy.medlan.dto.response.user.UserResponse;
import com.pharmacy.medlan.enums.Role;
import com.pharmacy.medlan.exception.DuplicationResourceException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.exception.ValidationException;
import com.pharmacy.medlan.mapper.UserMapper;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.user.UserRepository;
import com.pharmacy.medlan.security.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class AuthServiceImpl implements AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;
    private final AuthenticationManager authenticationManager;
    private final UserMapper userMapper;

    @Override
    @Transactional
    public LoginResponse login(LoginRequest request) {
        log.info("Login attempt for user: {}", request.getUsername());

        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
        );

        SecurityContextHolder.getContext().setAuthentication(authentication);

        User user = userRepository.findByUsername(request.getUsername())
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        // Update last login date
        user.setLastLoginDate(LocalDate.now());
        userRepository.save(user);

        String accessToken = jwtTokenProvider.generateToken(authentication);
        String refreshToken = jwtTokenProvider.generateRefreshToken(request.getUsername());

        log.info("User {} logged in successfully", request.getUsername());

        return LoginResponse.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .tokenType("Bearer")
                .expiresIn(jwtTokenProvider.getExpirationTime())
                .userId(user.getId())
                .username(user.getUsername())
                .fullName(user.getFullName())
                .email(user.getEmail())
                .role(user.getRole())
                .build();
    }

    @Override
    @Transactional
    public UserResponse register(RegisterRequest request) {
        log.info("Registering new user: {}", request.getUsername());

        if (userRepository.existsByUsername(request.getUsername())) {
            throw new DuplicationResourceException("Username already exists");
        }

        if (request.getEmail() != null && userRepository.existsByEmail(request.getEmail())) {
            throw new DuplicationResourceException("Email already exists");
        }

        if (request.getEmployeeCode() != null && userRepository.existsByEmployeeCode(request.getEmployeeCode())) {
            throw new DuplicationResourceException("Employee code already exists");
        }

        User user = User.builder()
                .username(request.getUsername())
                .password(passwordEncoder.encode(request.getPassword()))
                .fullName(request.getFullName())
                .email(request.getEmail())
                .phoneNumber(request.getPhoneNumber())
                .role(request.getRole() != null ? request.getRole() : Role.CASHIER)
                .employeeCode(request.getEmployeeCode())
                .discountLimit(request.getDiscountLimit())
                .creditTransactionLimit(request.getCreditTransactionLimit())
                .isActive(true)
                .build();

        User saved = userRepository.save(user);
        log.info("User {} registered successfully with id: {}", saved.getUsername(), saved.getId());

        return userMapper.toUserResponse(saved);
    }

    @Override
    public LoginResponse refreshToken(String refreshToken) {
        log.info("Refreshing token");

        if (!jwtTokenProvider.validateToken(refreshToken)) {
            throw new ValidationException("Invalid or expired refresh token");
        }

        String username = jwtTokenProvider.getUsernameFromToken(refreshToken);
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        String newAccessToken = jwtTokenProvider.generateTokenFromUsername(
                username, "ROLE_" + user.getRole().name());
        String newRefreshToken = jwtTokenProvider.generateRefreshToken(username);

        return LoginResponse.builder()
                .accessToken(newAccessToken)
                .refreshToken(newRefreshToken)
                .tokenType("Bearer")
                .expiresIn(jwtTokenProvider.getExpirationTime())
                .userId(user.getId())
                .username(user.getUsername())
                .fullName(user.getFullName())
                .email(user.getEmail())
                .role(user.getRole())
                .build();
    }

    @Override
    @Transactional
    public void changePassword(String username, ChangePasswordRequest request) {
        log.info("Changing password for user: {}", username);

        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));

        if (!passwordEncoder.matches(request.getCurrentPassword(), user.getPassword())) {
            throw new ValidationException("Current password is incorrect");
        }

        if (!request.getNewPassword().equals(request.getConfirmPassword())) {
            throw new ValidationException("New password and confirm password do not match");
        }

        user.setPassword(passwordEncoder.encode(request.getNewPassword()));
        userRepository.save(user);
        log.info("Password changed successfully for user: {}", username);
    }

    @Override
    @Transactional
    public void logout(String username) {
        log.info("User {} logged out", username);
        SecurityContextHolder.clearContext();
    }

    @Override
    public UserResponse getCurrentUser(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));
        return userMapper.toUserResponse(user);
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\user\EmployeeAuthorizationService.java"   & echo.. 
package com.pharmacy.medlan.service.user;

public interface EmployeeAuthorizationService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\user\EmployeeAuthorizationServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.user;

public class EmployeeAuthorizationServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\user\UserService.java"   & echo.. 
package com.pharmacy.medlan.service.user;

import com.pharmacy.medlan.dto.request.user.CreateUserRequest;
import com.pharmacy.medlan.dto.request.user.UpdateUserRequest;
import com.pharmacy.medlan.dto.response.user.UserResponse;
import com.pharmacy.medlan.enums.Role;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface UserService {

    UserResponse createUser(CreateUserRequest request);

    UserResponse updateUser(Long id, UpdateUserRequest request);

    UserResponse getUserById(Long id);

    UserResponse getUserByUsername(String username);

    Page<UserResponse> getAllUsers(Pageable pageable);

    List<UserResponse> getUsersByRole(Role role);

    List<UserResponse> getActiveUsers();

    void deleteUser(Long id);

    void activateUser(Long id);

    void deactivateUser(Long id);

    void resetPassword(Long id, String newPassword);

    List<UserResponse> getUsersByBranch(Long branchId);
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\user\UserServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.user;

import com.pharmacy.medlan.dto.request.user.CreateUserRequest;
import com.pharmacy.medlan.dto.request.user.UpdateUserRequest;
import com.pharmacy.medlan.dto.response.user.UserResponse;
import com.pharmacy.medlan.enums.Role;
import com.pharmacy.medlan.exception.DuplicationResourceException;
import com.pharmacy.medlan.exception.ResourceNotFoundException;
import com.pharmacy.medlan.mapper.UserMapper;
import com.pharmacy.medlan.model.user.User;
import com.pharmacy.medlan.repository.user.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;

    @Override
    @Transactional
    public UserResponse createUser(CreateUserRequest request) {
        log.info("Creating user: {}", request.getUsername());

        if (userRepository.existsByUsername(request.getUsername())) {
            throw new DuplicationResourceException("Username already exists");
        }

        if (request.getEmail() != null && userRepository.existsByEmail(request.getEmail())) {
            throw new DuplicationResourceException("Email already exists");
        }

        User user = userMapper.toEntity(request);
        user.setPassword(passwordEncoder.encode(request.getPassword()));

        User saved = userRepository.save(user);
        log.info("User created: {}", saved.getUsername());

        return userMapper.toUserResponse(saved);
    }

    @Override
    @Transactional
    public UserResponse updateUser(Long id, UpdateUserRequest request) {
        log.info("Updating user: {}", id);

        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));

        userMapper.updateEntityFromRequest(request, user);
        User updated = userRepository.save(user);

        return userMapper.toUserResponse(updated);
    }

    @Override
    public UserResponse getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        return userMapper.toUserResponse(user);
    }

    @Override
    public UserResponse getUserByUsername(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with username: " + username));
        return userMapper.toUserResponse(user);
    }

    @Override
    public Page<UserResponse> getAllUsers(Pageable pageable) {
        return userRepository.findAll(pageable)
                .map(userMapper::toUserResponse);
    }

    @Override
    public List<UserResponse> getUsersByRole(Role role) {
        return userRepository.findByRole(role)
                .stream()
                .map(userMapper::toUserResponse)
                .collect(Collectors.toList());
    }

    @Override
    public List<UserResponse> getActiveUsers() {
        return userRepository.findByIsActiveTrue()
                .stream()
                .map(userMapper::toUserResponse)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void deleteUser(Long id) {
        log.info("Deleting user: {}", id);

        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));

        user.setDeleted(true);
        user.setIsActive(false);
        userRepository.save(user);
        log.info("User deleted: {}", id);
    }

    @Override
    @Transactional
    public void activateUser(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        user.setIsActive(true);
        userRepository.save(user);
    }

    @Override
    @Transactional
    public void deactivateUser(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));
        user.setIsActive(false);
        userRepository.save(user);
    }

    @Override
    @Transactional
    public void resetPassword(Long id, String newPassword) {
        log.info("Resetting password for user: {}", id);

        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found with id: " + id));

        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);
        log.info("Password reset for user: {}", id);
    }

    @Override
    public List<UserResponse> getUsersByBranch(Long branchId) {
        return userRepository.findUsersByBranch(branchId)
                .stream()
                .map(userMapper::toUserResponse)
                .collect(Collectors.toList());
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\user\UserSessionService.java"   & echo.. 
package com.pharmacy.medlan.service.user;

public interface UserSessionService {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\service\user\UserSessionServiceImpl.java"   & echo.. 
package com.pharmacy.medlan.service.user;

public class UserSessionServiceImpl {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\BarcodeGenerator.java"   & echo.. 
package com.pharmacy.medlan.util;

public class BarcodeGenerator {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\DateUtil.java"   & echo.. 
package com.pharmacy.medlan.util;

public class DateUtil {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\EncryptionUtil.java"   & echo.. 
package com.pharmacy.medlan.util;

public class EncryptionUtil {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\ExcelExportUtil.java"   & echo.. 
package com.pharmacy.medlan.util;

public class ExcelExportUtil {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\FileUploadUtil.java"   & echo.. 
package com.pharmacy.medlan.util;

public class FileUploadUtil {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\InvoiceNumberGenerator.java"   & echo.. 
package com.pharmacy.medlan.util;

public class InvoiceNumberGenerator {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\NumberUtil.java"   & echo.. 
package com.pharmacy.medlan.util;

public class NumberUtil {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\ResponseUtil.java"   & echo.. 
package com.pharmacy.medlan.util;

public class ResponseUtil {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\util\StringUtil.java"   & echo.. 
package com.pharmacy.medlan.util;

public class StringUtil {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\annotation\FutureDate.java"   & echo.. 
package com.pharmacy.medlan.validation.annotation;

import com.pharmacy.medlan.validation.validator.FutureDateValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Validates that a date is in the future.
 * 
 * Useful for:
 * - Expiry dates
 * - Scheduled dates
 * - Appointment dates
 */
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = FutureDateValidator.class)
@Documented
public @interface FutureDate {
    
    String message() default "Date must be in the future";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
    
    /**
     * Allow null values
     */
    boolean allowNull() default true;
    
    /**
     * Allow today's date (future or equal to today)
     */
    boolean allowToday() default false;
    
    /**
     * Minimum days in future
     */
    int minDaysInFuture() default 0;
    
    /**
     * Maximum days in future (0 = no limit)
     */
    int maxDaysInFuture() default 0;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\annotation\RateLimit.java"   & echo.. 
package com.pharmacy.medlan.validation.annotation;

import java.lang.annotation.*;

/**
 * Annotation for rate limiting API endpoints.
 * 
 * Usage:
 * @RateLimit(requests = 10, duration = 60) // 10 requests per 60 seconds
 * @RateLimit(key = "report", capacity = 10, refillTokens = 10, refillSeconds = 60)
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RateLimit {
    
    /**
     * Maximum number of requests allowed (legacy)
     */
    int requests() default 100;
    
    /**
     * Time window in seconds (legacy)
     */
    int duration() default 60;
    
    /**
     * Rate limit scope
     */
    Scope scope() default Scope.IP;
    
    /**
     * Custom bucket name (for shared limits across endpoints)
     */
    String bucket() default "";
    
    /**
     * Key for the rate limit bucket (new Bucket4j style)
     */
    String key() default "default";
    
    /**
     * Maximum capacity of tokens in the bucket
     */
    int capacity() default 100;
    
    /**
     * Number of tokens to add on refill
     */
    int refillTokens() default 100;
    
    /**
     * Refill interval in seconds
     */
    int refillSeconds() default 60;
    
    enum Scope {
        /**
         * Rate limit per IP address
         */
        IP,
        
        /**
         * Rate limit per authenticated user
         */
        USER,
        
        /**
         * Global rate limit for the endpoint
         */
        GLOBAL
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\annotation\ValidDrugLicense.java"   & echo.. 
package com.pharmacy.medlan.validation.annotation;

import com.pharmacy.medlan.validation.validator.DrugLicenseValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Validates Indian Drug License Number format.
 * 
 * Common formats:
 * - Retail Drug License: 20B/XXX/XXX or similar
 * - Wholesale Drug License: 21B/XXX/XXX or similar
 * 
 * Format varies by state but generally contains:
 * - License type code
 * - District/Division code
 * - Serial number
 * - Year (sometimes)
 */
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = DrugLicenseValidator.class)
@Documented
public @interface ValidDrugLicense {
    
    String message() default "Invalid drug license number format";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
    
    /**
     * Allow empty values
     */
    boolean allowEmpty() default true;
    
    /**
     * License type (RETAIL, WHOLESALE, BOTH)
     */
    LicenseType type() default LicenseType.BOTH;
    
    enum LicenseType {
        RETAIL,      // Form 20/21
        WHOLESALE,   // Form 20B/21B
        BOTH
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\annotation\ValidEmail.java"   & echo.. 
package com.pharmacy.medlan.validation.annotation;

import com.pharmacy.medlan.validation.validator.EmailValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Enhanced email validation beyond standard @Email annotation.
 * 
 * Features:
 * - Stricter pattern validation
 * - Optional domain whitelist/blacklist
 * - Disposable email detection
 * - Length limits
 */
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EmailValidator.class)
@Documented
public @interface ValidEmail {
    
    String message() default "Invalid email format";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
    
    /**
     * Allow empty values
     */
    boolean allowEmpty() default true;
    
    /**
     * Block disposable email providers
     */
    boolean blockDisposable() default false;
    
    /**
     * Maximum allowed length
     */
    int maxLength() default 254;
    
    /**
     * Allowed domains (empty means all domains allowed)
     */
    String[] allowedDomains() default {};
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\annotation\ValidGSTIN.java"   & echo.. 
package com.pharmacy.medlan.validation.annotation;

import com.pharmacy.medlan.validation.validator.GSTINValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Validates Indian GSTIN (Goods and Services Tax Identification Number).
 * 
 * GSTIN Format: 15-character alphanumeric
 * - Characters 1-2: State code (01-37)
 * - Characters 3-12: PAN number
 * - Character 13: Entity number (1-9 or A-Z)
 * - Character 14: 'Z' by default
 * - Character 15: Check digit (0-9 or A-Z)
 * 
 * Example: 27AAPFU0939F1ZV
 */
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = GSTINValidator.class)
@Documented
public @interface ValidGSTIN {
    
    String message() default "Invalid GSTIN format. Must be a valid 15-character Indian GSTIN";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
    
    /**
     * Allow empty values
     */
    boolean allowEmpty() default true;
    
    /**
     * Validate check digit (strict validation)
     */
    boolean validateCheckDigit() default true;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\annotation\ValidPhone.java"   & echo.. 
package com.pharmacy.medlan.validation.annotation;

import com.pharmacy.medlan.validation.validator.PhoneValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Validates Indian phone number formats:
 * - 10-digit mobile number (e.g., 9876543210)
 * - With country code (e.g., +919876543210 or 919876543210)
 * - Landline formats (e.g., 044-12345678)
 */
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PhoneValidator.class)
@Documented
public @interface ValidPhone {
    
    String message() default "Invalid phone number format. Must be a valid Indian phone number";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
    
    /**
     * Allow empty values
     */
    boolean allowEmpty() default true;
    
    /**
     * Allow landline numbers
     */
    boolean allowLandline() default true;
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\annotation\ValidPincode.java"   & echo.. 
package com.pharmacy.medlan.validation.annotation;

import com.pharmacy.medlan.validation.validator.PincodeValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.*;

/**
 * Validates Indian Pincode (Postal Index Number).
 * 
 * Format: 6 digits
 * - First digit: Region (1-8)
 * - Second digit: Sub-region
 * - Third digit: District
 * - Last 3 digits: Post office
 * 
 * First digit mapping:
 * 1 - Delhi, Haryana, Punjab, HP, J&K
 * 2 - UP, Uttarakhand
 * 3 - Rajasthan, Gujarat
 * 4 - Maharashtra, Goa, MP, Chhattisgarh
 * 5 - Andhra Pradesh, Telangana, Karnataka
 * 6 - Tamil Nadu, Kerala
 * 7 - West Bengal, Odisha, Northeastern states
 * 8 - Bihar, Jharkhand
 */
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PincodeValidator.class)
@Documented
public @interface ValidPincode {
    
    String message() default "Invalid pincode. Must be a valid 6-digit Indian pincode";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
    
    /**
     * Allow empty values
     */
    boolean allowEmpty() default true;
    
    /**
     * Allowed region codes (first digit). Empty = all regions allowed
     */
    int[] allowedRegions() default {};
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\validator\DrugLicenseValidator.java"   & echo.. 
package com.pharmacy.medlan.validation.validator;

import com.pharmacy.medlan.validation.annotation.ValidDrugLicense;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.util.regex.Pattern;

/**
 * Validator for Indian Drug License Numbers.
 * 
 * Valid formats (examples):
 * - 20B/KA/2023/0001 (Karnataka retail)
 * - 21B/MH/2023/0001 (Maharashtra wholesale)
 * - DL-20-123456 (Delhi)
 * - FDCA-GJ-20-12345 (Gujarat)
 * - Form variations with state codes
 */
public class DrugLicenseValidator implements ConstraintValidator<ValidDrugLicense, String> {

    // Generic pattern - allows various state formats
    private static final Pattern DRUG_LICENSE_PATTERN = Pattern.compile(
            "^[A-Z0-9]{2,6}[-/][A-Z]{2}[-/]?\\d{2,4}[-/]?\\d{3,6}$|" +  // Standard format
            "^\\d{2}[AB]?[-/][A-Z]{2,4}[-/]\\d{4}[-/]\\d{4,6}$|" +       // Form number based
            "^[A-Z]{2,5}[-/]\\d{2,4}[-/]\\d{4,8}$|" +                    // State prefix format
            "^[A-Z0-9]{5,20}$",                                          // Some states use alphanumeric only
            Pattern.CASE_INSENSITIVE
    );
    
    // Retail license patterns (Form 20, 21)
    private static final Pattern RETAIL_PATTERN = Pattern.compile(
            ".*\\b(20|21)\\b.*",
            Pattern.CASE_INSENSITIVE
    );
    
    // Wholesale license patterns (Form 20B, 21B)
    private static final Pattern WHOLESALE_PATTERN = Pattern.compile(
            ".*\\b(20B|21B)\\b.*",
            Pattern.CASE_INSENSITIVE
    );

    private boolean allowEmpty;
    private ValidDrugLicense.LicenseType type;

    @Override
    public void initialize(ValidDrugLicense constraintAnnotation) {
        this.allowEmpty = constraintAnnotation.allowEmpty();
        this.type = constraintAnnotation.type();
    }

    @Override
    public boolean isValid(String licenseNumber, ConstraintValidatorContext context) {
        if (licenseNumber == null || licenseNumber.trim().isEmpty()) {
            return allowEmpty;
        }

        String cleaned = licenseNumber.trim().toUpperCase();

        // Check minimum length
        if (cleaned.length() < 5 || cleaned.length() > 30) {
            return false;
        }

        // Basic pattern validation
        if (!DRUG_LICENSE_PATTERN.matcher(cleaned).matches()) {
            // Allow more flexible validation for unrecognized but reasonable formats
            if (!cleaned.matches("^[A-Z0-9\\-/]+$") || cleaned.length() < 5) {
                return false;
            }
        }

        // Type-specific validation
        return switch (type) {
            case RETAIL -> isRetailLicense(cleaned);
            case WHOLESALE -> isWholesaleLicense(cleaned);
            case BOTH -> true; // Already passed basic validation
        };
    }

    private boolean isRetailLicense(String license) {
        // Retail licenses typically have form 20 or 21 (without B suffix)
        return RETAIL_PATTERN.matcher(license).matches() && 
               !WHOLESALE_PATTERN.matcher(license).matches();
    }

    private boolean isWholesaleLicense(String license) {
        // Wholesale licenses have form 20B or 21B
        return WHOLESALE_PATTERN.matcher(license).matches();
    }

    /**
     * Extract license type from license number
     */
    public static String extractLicenseType(String licenseNumber) {
        if (licenseNumber == null) return "UNKNOWN";
        
        String upper = licenseNumber.toUpperCase();
        if (upper.contains("20B") || upper.contains("21B")) {
            return "WHOLESALE";
        } else if (upper.contains("20") || upper.contains("21")) {
            return "RETAIL";
        }
        return "UNKNOWN";
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\validator\EmailValidator.java"   & echo.. 
package com.pharmacy.medlan.validation.validator;

import com.pharmacy.medlan.validation.annotation.ValidEmail;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * Enhanced email validator with additional security features.
 * 
 * Validates:
 * - RFC 5322 compliant email format
 * - Domain validation
 * - Disposable email blocking
 * - Length constraints
 */
public class EmailValidator implements ConstraintValidator<ValidEmail, String> {

    // RFC 5322 compliant email pattern (simplified but strict)
    private static final Pattern EMAIL_PATTERN = Pattern.compile(
            "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$"
    );
    
    // Common disposable email domains (partial list - extend as needed)
    private static final Set<String> DISPOSABLE_DOMAINS = Set.of(
            "tempmail.com", "throwaway.email", "guerrillamail.com", "mailinator.com",
            "10minutemail.com", "fakeinbox.com", "trashmail.com", "temp-mail.org",
            "dispostable.com", "yopmail.com", "sharklasers.com", "guerrillamail.info",
            "grr.la", "pokemail.net", "spam4.me", "anonymbox.net", "getairmail.com",
            "mailnesia.com", "tempr.email", "discard.email", "discardmail.com",
            "tempail.com", "tmails.net", "emailondeck.com", "getnada.com",
            "mohmal.com", "tempinbox.com", "mailcatch.com", "spamgourmet.com"
    );

    private boolean allowEmpty;
    private boolean blockDisposable;
    private int maxLength;
    private Set<String> allowedDomains;

    @Override
    public void initialize(ValidEmail constraintAnnotation) {
        this.allowEmpty = constraintAnnotation.allowEmpty();
        this.blockDisposable = constraintAnnotation.blockDisposable();
        this.maxLength = constraintAnnotation.maxLength();
        this.allowedDomains = new HashSet<>(Arrays.asList(constraintAnnotation.allowedDomains()));
    }

    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null || email.trim().isEmpty()) {
            return allowEmpty;
        }

        String cleanedEmail = email.trim().toLowerCase();

        // Check length
        if (cleanedEmail.length() > maxLength) {
            customMessage(context, "Email must not exceed " + maxLength + " characters");
            return false;
        }

        // Check basic pattern
        if (!EMAIL_PATTERN.matcher(cleanedEmail).matches()) {
            customMessage(context, "Invalid email format");
            return false;
        }

        // Extract domain
        String domain = extractDomain(cleanedEmail);
        if (domain == null) {
            return false;
        }

        // Check domain whitelist if specified
        if (!allowedDomains.isEmpty() && !allowedDomains.contains(domain)) {
            customMessage(context, "Email domain not allowed");
            return false;
        }

        // Check disposable email
        if (blockDisposable && isDisposableDomain(domain)) {
            customMessage(context, "Disposable email addresses are not allowed");
            return false;
        }

        // Additional validation
        return validateEmailParts(cleanedEmail, context);
    }

    private String extractDomain(String email) {
        int atIndex = email.lastIndexOf('@');
        if (atIndex < 1 || atIndex >= email.length() - 1) {
            return null;
        }
        return email.substring(atIndex + 1);
    }

    private boolean isDisposableDomain(String domain) {
        // Check exact match
        if (DISPOSABLE_DOMAINS.contains(domain)) {
            return true;
        }
        
        // Check subdomain
        for (String disposable : DISPOSABLE_DOMAINS) {
            if (domain.endsWith("." + disposable)) {
                return true;
            }
        }
        
        return false;
    }

    private boolean validateEmailParts(String email, ConstraintValidatorContext context) {
        int atIndex = email.lastIndexOf('@');
        String localPart = email.substring(0, atIndex);
        String domain = email.substring(atIndex + 1);

        // Local part validation
        if (localPart.length() > 64) {
            customMessage(context, "Local part of email must not exceed 64 characters");
            return false;
        }

        // No consecutive dots
        if (localPart.contains("..") || domain.contains("..")) {
            customMessage(context, "Email cannot contain consecutive dots");
            return false;
        }

        // Cannot start or end with dot
        if (localPart.startsWith(".") || localPart.endsWith(".")) {
            customMessage(context, "Email local part cannot start or end with a dot");
            return false;
        }

        // Domain must have at least one dot (TLD)
        if (!domain.contains(".")) {
            customMessage(context, "Email domain must include a TLD");
            return false;
        }

        // Domain labels validation
        String[] labels = domain.split("\\.");
        for (String label : labels) {
            if (label.isEmpty() || label.length() > 63) {
                customMessage(context, "Invalid domain label length");
                return false;
            }
            if (label.startsWith("-") || label.endsWith("-")) {
                customMessage(context, "Domain labels cannot start or end with hyphen");
                return false;
            }
        }

        // TLD must be at least 2 characters and only letters
        String tld = labels[labels.length - 1];
        if (tld.length() < 2 || !tld.matches("[a-zA-Z]+")) {
            customMessage(context, "Invalid top-level domain");
            return false;
        }

        return true;
    }

    private void customMessage(ConstraintValidatorContext context, String message) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate(message).addConstraintViolation();
    }

    /**
     * Utility method to normalize email (lowercase, trim)
     */
    public static String normalizeEmail(String email) {
        if (email == null) return null;
        return email.trim().toLowerCase();
    }

    /**
     * Utility method to mask email for display (privacy)
     * Example: john.doe@gmail.com -> jo***@gmail.com
     */
    public static String maskEmail(String email) {
        if (email == null || !email.contains("@")) {
            return email;
        }
        
        int atIndex = email.indexOf('@');
        String localPart = email.substring(0, atIndex);
        String domain = email.substring(atIndex);
        
        if (localPart.length() <= 2) {
            return localPart.charAt(0) + "***" + domain;
        }
        
        return localPart.substring(0, 2) + "***" + domain;
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\validator\FutureDateValidator.java"   & echo.. 
package com.pharmacy.medlan.validation.validator;

import com.pharmacy.medlan.validation.annotation.FutureDate;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.time.temporal.ChronoUnit;
import java.time.temporal.Temporal;
import java.util.Date;

/**
 * Validator for future date constraints.
 * Supports: LocalDate, LocalDateTime, ZonedDateTime, Date
 */
public class FutureDateValidator implements ConstraintValidator<FutureDate, Object> {

    private boolean allowNull;
    private boolean allowToday;
    private int minDaysInFuture;
    private int maxDaysInFuture;

    @Override
    public void initialize(FutureDate constraintAnnotation) {
        this.allowNull = constraintAnnotation.allowNull();
        this.allowToday = constraintAnnotation.allowToday();
        this.minDaysInFuture = constraintAnnotation.minDaysInFuture();
        this.maxDaysInFuture = constraintAnnotation.maxDaysInFuture();
    }

    @Override
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        if (value == null) {
            return allowNull;
        }

        LocalDate dateToValidate = extractDate(value);
        if (dateToValidate == null) {
            return false;
        }

        LocalDate today = LocalDate.now();
        long daysFromToday = ChronoUnit.DAYS.between(today, dateToValidate);

        // Check if date is in the future (or today if allowed)
        if (allowToday) {
            if (dateToValidate.isBefore(today)) {
                customMessage(context, "Date must be today or in the future");
                return false;
            }
        } else {
            if (!dateToValidate.isAfter(today)) {
                customMessage(context, "Date must be in the future");
                return false;
            }
        }

        // Check minimum days in future
        if (minDaysInFuture > 0 && daysFromToday < minDaysInFuture) {
            customMessage(context, "Date must be at least " + minDaysInFuture + " days in the future");
            return false;
        }

        // Check maximum days in future
        if (maxDaysInFuture > 0 && daysFromToday > maxDaysInFuture) {
            customMessage(context, "Date must be within " + maxDaysInFuture + " days from today");
            return false;
        }

        return true;
    }

    private LocalDate extractDate(Object value) {
        if (value instanceof LocalDate) {
            return (LocalDate) value;
        }
        if (value instanceof LocalDateTime) {
            return ((LocalDateTime) value).toLocalDate();
        }
        if (value instanceof ZonedDateTime) {
            return ((ZonedDateTime) value).toLocalDate();
        }
        if (value instanceof Date) {
            return new java.sql.Date(((Date) value).getTime()).toLocalDate();
        }
        if (value instanceof java.sql.Date) {
            return ((java.sql.Date) value).toLocalDate();
        }
        return null;
    }

    private void customMessage(ConstraintValidatorContext context, String message) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate(message).addConstraintViolation();
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\validator\GSTINValidator.java"   & echo.. 
package com.pharmacy.medlan.validation.validator;

import com.pharmacy.medlan.validation.annotation.ValidGSTIN;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.util.Set;
import java.util.regex.Pattern;

/**
 * Validator for Indian GSTIN (Goods and Services Tax Identification Number).
 * 
 * Format: 15 characters
 * - Positions 1-2: State code (01-37, specific valid codes)
 * - Positions 3-12: PAN number (AAAPZ1234C format)
 * - Position 13: Entity number (1-9, A-Z)
 * - Position 14: 'Z' (default)
 * - Position 15: Check digit (calculated using mod 36)
 */
public class GSTINValidator implements ConstraintValidator<ValidGSTIN, String> {

    // GSTIN Pattern: 2 digits (state) + 10 chars (PAN) + 1 alphanum + Z + 1 alphanum
    private static final Pattern GSTIN_PATTERN = Pattern.compile(
            "^[0-9]{2}[A-Z]{5}[0-9]{4}[A-Z]{1}[0-9A-Z]{1}Z[0-9A-Z]{1}$"
    );
    
    // Valid Indian state codes (01-37 plus special codes)
    private static final Set<String> VALID_STATE_CODES = Set.of(
            "01", "02", "03", "04", "05", "06", "07", "08", "09", "10",
            "11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
            "21", "22", "23", "24", "25", "26", "27", "28", "29", "30",
            "31", "32", "33", "34", "35", "36", "37",
            "97", "96" // Special codes for special economic zones
    );

    private boolean allowEmpty;
    private boolean validateCheckDigit;

    @Override
    public void initialize(ValidGSTIN constraintAnnotation) {
        this.allowEmpty = constraintAnnotation.allowEmpty();
        this.validateCheckDigit = constraintAnnotation.validateCheckDigit();
    }

    @Override
    public boolean isValid(String gstin, ConstraintValidatorContext context) {
        if (gstin == null || gstin.trim().isEmpty()) {
            return allowEmpty;
        }

        String cleanedGstin = gstin.toUpperCase().trim();

        // Check length
        if (cleanedGstin.length() != 15) {
            return false;
        }

        // Check basic pattern
        if (!GSTIN_PATTERN.matcher(cleanedGstin).matches()) {
            return false;
        }

        // Validate state code
        String stateCode = cleanedGstin.substring(0, 2);
        if (!VALID_STATE_CODES.contains(stateCode)) {
            return false;
        }

        // Validate PAN portion (positions 3-12)
        String panPortion = cleanedGstin.substring(2, 12);
        if (!isValidPANFormat(panPortion)) {
            return false;
        }

        // Validate 14th character is 'Z'
        if (cleanedGstin.charAt(13) != 'Z') {
            return false;
        }

        // Validate check digit if strict validation is enabled
        if (validateCheckDigit) {
            return isValidCheckDigit(cleanedGstin);
        }

        return true;
    }

    /**
     * Validates PAN format (first 10 characters of GSTIN)
     * Format: AAAAA9999A
     * - First 5 characters: Letters
     * - Next 4 characters: Numbers
     * - Last character: Letter
     */
    private boolean isValidPANFormat(String pan) {
        if (pan == null || pan.length() != 10) {
            return false;
        }
        
        // First 5 must be letters
        for (int i = 0; i < 5; i++) {
            if (!Character.isLetter(pan.charAt(i))) {
                return false;
            }
        }
        
        // Next 4 must be digits
        for (int i = 5; i < 9; i++) {
            if (!Character.isDigit(pan.charAt(i))) {
                return false;
            }
        }
        
        // Last must be letter
        return Character.isLetter(pan.charAt(9));
    }

    /**
     * Validates GSTIN check digit using mod 36 algorithm
     */
    private boolean isValidCheckDigit(String gstin) {
        String chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        int sum = 0;
        
        for (int i = 0; i < 14; i++) {
            int index = chars.indexOf(gstin.charAt(i));
            int factor = (i % 2 == 0) ? 1 : 2;
            int product = index * factor;
            sum += (product / 36) + (product % 36);
        }
        
        int remainder = sum % 36;
        int checkDigit = (36 - remainder) % 36;
        char expectedCheckDigit = chars.charAt(checkDigit);
        
        return gstin.charAt(14) == expectedCheckDigit;
    }

    /**
     * Utility method to extract PAN from GSTIN
     * @param gstin Valid GSTIN
     * @return PAN number
     */
    public static String extractPAN(String gstin) {
        if (gstin == null || gstin.length() != 15) {
            return null;
        }
        return gstin.substring(2, 12);
    }

    /**
     * Utility method to get state name from GSTIN
     * @param gstin Valid GSTIN
     * @return State name or null
     */
    public static String getStateName(String gstin) {
        if (gstin == null || gstin.length() < 2) {
            return null;
        }
        
        String stateCode = gstin.substring(0, 2);
        return switch (stateCode) {
            case "01" -> "Jammu & Kashmir";
            case "02" -> "Himachal Pradesh";
            case "03" -> "Punjab";
            case "04" -> "Chandigarh";
            case "05" -> "Uttarakhand";
            case "06" -> "Haryana";
            case "07" -> "Delhi";
            case "08" -> "Rajasthan";
            case "09" -> "Uttar Pradesh";
            case "10" -> "Bihar";
            case "11" -> "Sikkim";
            case "12" -> "Arunachal Pradesh";
            case "13" -> "Nagaland";
            case "14" -> "Manipur";
            case "15" -> "Mizoram";
            case "16" -> "Tripura";
            case "17" -> "Meghalaya";
            case "18" -> "Assam";
            case "19" -> "West Bengal";
            case "20" -> "Jharkhand";
            case "21" -> "Odisha";
            case "22" -> "Chhattisgarh";
            case "23" -> "Madhya Pradesh";
            case "24" -> "Gujarat";
            case "25" -> "Daman & Diu"; // Now part of Dadra and Nagar Haveli and Daman and Diu
            case "26" -> "Dadra & Nagar Haveli"; // Now part of Dadra and Nagar Haveli and Daman and Diu
            case "27" -> "Maharashtra";
            case "28" -> "Andhra Pradesh (Old)";
            case "29" -> "Karnataka";
            case "30" -> "Goa";
            case "31" -> "Lakshadweep";
            case "32" -> "Kerala";
            case "33" -> "Tamil Nadu";
            case "34" -> "Puducherry";
            case "35" -> "Andaman & Nicobar Islands";
            case "36" -> "Telangana";
            case "37" -> "Andhra Pradesh (New)";
            case "38" -> "Ladakh";
            case "97" -> "Other Territory";
            default -> null;
        };
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\validator\PhoneValidator.java"   & echo.. 
package com.pharmacy.medlan.validation.validator;

import com.pharmacy.medlan.validation.annotation.ValidPhone;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.util.regex.Pattern;

/**
 * Validator for Indian phone numbers.
 * Supports:
 * - 10-digit mobile: 9876543210, 7876543210, 8876543210, 6876543210
 * - With country code: +919876543210, 919876543210, 0919876543210
 * - Landline: 044-12345678, 011-12345678
 * - With spaces/dashes: 98765 43210, 987-654-3210
 */
public class PhoneValidator implements ConstraintValidator<ValidPhone, String> {

    // Indian mobile number starting with 6, 7, 8, or 9
    private static final Pattern MOBILE_PATTERN = Pattern.compile(
            "^(?:\\+?91[\\s.-]?)?[6-9]\\d{9}$"
    );
    
    // Indian landline with STD code
    private static final Pattern LANDLINE_PATTERN = Pattern.compile(
            "^(?:\\+?91[\\s.-]?)?0?[1-9]\\d{1,4}[\\s.-]?\\d{6,8}$"
    );
    
    // Generic pattern allowing spaces and dashes
    private static final Pattern FLEXIBLE_PATTERN = Pattern.compile(
            "^(?:\\+?91)?[\\s.-]?[6-9]\\d{2}[\\s.-]?\\d{3}[\\s.-]?\\d{4}$"
    );

    private boolean allowEmpty;
    private boolean allowLandline;

    @Override
    public void initialize(ValidPhone constraintAnnotation) {
        this.allowEmpty = constraintAnnotation.allowEmpty();
        this.allowLandline = constraintAnnotation.allowLandline();
    }

    @Override
    public boolean isValid(String phoneNumber, ConstraintValidatorContext context) {
        if (phoneNumber == null || phoneNumber.trim().isEmpty()) {
            return allowEmpty;
        }

        // Remove all spaces and common separators for validation
        String cleanedPhone = phoneNumber.replaceAll("[\\s.()-]", "");
        
        // Check if it's a valid mobile number
        if (isValidMobile(cleanedPhone)) {
            return true;
        }
        
        // Check landline if allowed
        if (allowLandline && isValidLandline(cleanedPhone)) {
            return true;
        }
        
        // Try flexible pattern
        return FLEXIBLE_PATTERN.matcher(phoneNumber.replaceAll("[\\s.-]", "")).matches();
    }

    private boolean isValidMobile(String phone) {
        // Remove country code prefix if present
        if (phone.startsWith("+91")) {
            phone = phone.substring(3);
        } else if (phone.startsWith("91") && phone.length() > 10) {
            phone = phone.substring(2);
        } else if (phone.startsWith("0") && phone.length() == 11) {
            phone = phone.substring(1);
        }
        
        // Must be 10 digits starting with 6, 7, 8, or 9
        return phone.length() == 10 && 
               phone.matches("[6-9]\\d{9}");
    }

    private boolean isValidLandline(String phone) {
        // Remove country code if present
        if (phone.startsWith("+91")) {
            phone = phone.substring(3);
        } else if (phone.startsWith("91") && phone.length() > 11) {
            phone = phone.substring(2);
        }
        
        // Remove leading 0 if present
        if (phone.startsWith("0")) {
            phone = phone.substring(1);
        }
        
        // Landline: STD code (2-4 digits) + number (6-8 digits) = 8-12 digits total
        return phone.length() >= 8 && phone.length() <= 12 && phone.matches("\\d+");
    }

    /**
     * Utility method to normalize phone number to E.164 format
     * @param phoneNumber The phone number to normalize
     * @return Normalized phone number in +91XXXXXXXXXX format
     */
    public static String normalizeToE164(String phoneNumber) {
        if (phoneNumber == null) return null;
        
        String cleaned = phoneNumber.replaceAll("[\\s.()-]", "");
        
        // Remove country code prefix
        if (cleaned.startsWith("+91")) {
            cleaned = cleaned.substring(3);
        } else if (cleaned.startsWith("91") && cleaned.length() > 10) {
            cleaned = cleaned.substring(2);
        } else if (cleaned.startsWith("0") && cleaned.length() == 11) {
            cleaned = cleaned.substring(1);
        }
        
        // Return in E.164 format
        if (cleaned.length() == 10) {
            return "+91" + cleaned;
        }
        
        return phoneNumber; // Return original if can't normalize
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\validation\validator\PincodeValidator.java"   & echo.. 
package com.pharmacy.medlan.validation.validator;

import com.pharmacy.medlan.validation.annotation.ValidPincode;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Validator for Indian Pincode (PIN - Postal Index Number).
 * 
 * Valid pincodes:
 * - Exactly 6 digits
 * - First digit between 1-8 (no region starts with 0 or 9)
 * - Cannot be all same digits
 * - Cannot be sequential (123456)
 */
public class PincodeValidator implements ConstraintValidator<ValidPincode, String> {

    private boolean allowEmpty;
    private Set<Integer> allowedRegions;

    @Override
    public void initialize(ValidPincode constraintAnnotation) {
        this.allowEmpty = constraintAnnotation.allowEmpty();
        this.allowedRegions = Arrays.stream(constraintAnnotation.allowedRegions())
                .boxed()
                .collect(Collectors.toSet());
    }

    @Override
    public boolean isValid(String pincode, ConstraintValidatorContext context) {
        if (pincode == null || pincode.trim().isEmpty()) {
            return allowEmpty;
        }

        String cleaned = pincode.trim();

        // Must be exactly 6 digits
        if (!cleaned.matches("^[1-8]\\d{5}$")) {
            customMessage(context, "Pincode must be 6 digits and start with 1-8");
            return false;
        }

        int firstDigit = Character.getNumericValue(cleaned.charAt(0));

        // Validate region if restrictions specified
        if (!allowedRegions.isEmpty() && !allowedRegions.contains(firstDigit)) {
            customMessage(context, "Pincode region not allowed");
            return false;
        }

        // Check for invalid patterns
        if (isAllSameDigits(cleaned)) {
            customMessage(context, "Invalid pincode pattern");
            return false;
        }

        if (isSequential(cleaned)) {
            customMessage(context, "Invalid pincode pattern");
            return false;
        }

        return true;
    }

    private boolean isAllSameDigits(String pincode) {
        char first = pincode.charAt(0);
        return pincode.chars().allMatch(c -> c == first);
    }

    private boolean isSequential(String pincode) {
        // Check ascending sequence
        if (pincode.equals("123456")) return true;
        // Check descending sequence
        if (pincode.equals("654321")) return true;
        return false;
    }

    private void customMessage(ConstraintValidatorContext context, String message) {
        context.disableDefaultConstraintViolation();
        context.buildConstraintViolationWithTemplate(message).addConstraintViolation();
    }

    /**
     * Get region name from pincode
     */
    public static String getRegionName(String pincode) {
        if (pincode == null || pincode.length() < 1) {
            return "Unknown";
        }
        
        char firstDigit = pincode.charAt(0);
        return switch (firstDigit) {
            case '1' -> "Northern Region (Delhi, Punjab, Haryana, HP, J&K)";
            case '2' -> "Northern Region (Uttar Pradesh, Uttarakhand)";
            case '3' -> "Western Region (Rajasthan, Gujarat)";
            case '4' -> "Western Region (Maharashtra, Goa, MP, Chhattisgarh)";
            case '5' -> "Southern Region (Andhra Pradesh, Telangana, Karnataka)";
            case '6' -> "Southern Region (Tamil Nadu, Kerala)";
            case '7' -> "Eastern Region (West Bengal, Odisha, Northeast)";
            case '8' -> "Eastern Region (Bihar, Jharkhand)";
            default -> "Unknown Region";
        };
    }

    /**
     * Get state hints from pincode
     */
    public static String[] getPossibleStates(String pincode) {
        if (pincode == null || pincode.length() < 2) {
            return new String[]{"Unknown"};
        }
        
        String prefix = pincode.substring(0, 2);
        return switch (prefix) {
            case "11" -> new String[]{"Delhi"};
            case "12", "13" -> new String[]{"Haryana"};
            case "14", "15", "16" -> new String[]{"Punjab"};
            case "17" -> new String[]{"Himachal Pradesh"};
            case "18", "19" -> new String[]{"Jammu & Kashmir"};
            case "20", "21", "22", "23", "24", "25", "26", "27", "28" -> new String[]{"Uttar Pradesh"};
            case "30", "31", "32", "33", "34" -> new String[]{"Rajasthan"};
            case "36", "37", "38", "39" -> new String[]{"Gujarat"};
            case "40", "41", "42", "43", "44" -> new String[]{"Maharashtra"};
            case "45", "46", "47", "48", "49" -> new String[]{"Madhya Pradesh"};
            case "50", "51", "52" -> new String[]{"Telangana", "Andhra Pradesh"};
            case "53" -> new String[]{"Andhra Pradesh"};
            case "56", "57", "58", "59" -> new String[]{"Karnataka"};
            case "60", "61", "62", "63", "64" -> new String[]{"Tamil Nadu"};
            case "67", "68", "69" -> new String[]{"Kerala"};
            case "70", "71", "72", "73", "74" -> new String[]{"West Bengal"};
            case "75", "76", "77" -> new String[]{"Odisha"};
            case "78" -> new String[]{"Assam"};
            case "79" -> new String[]{"Northeastern States"};
            case "80", "81", "82", "83", "84", "85" -> new String[]{"Bihar", "Jharkhand"};
            default -> new String[]{"Unknown"};
        };
    }
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\websocket\NotificationWebSocketHandler.java"   & echo.. 
package com.pharmacy.medlan.websocket;

public class NotificationWebSocketHandler {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\websocket\SyncWebSocketHandler.java"   & echo.. 
package com.pharmacy.medlan.websocket;

public class SyncWebSocketHandler {
}
.

D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy>type "D:\PentX\Pharmarcy - Medlan\medlan\pharmacy-medlan\backend\src\main\java\com\pharmacy\medlan\websocket\WebSocketHandler.java"   & echo.. 
package com.pharmacy.medlan.websocket;

public class WebSocketHandler {
}
.
